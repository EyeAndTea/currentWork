REMEMBER
	- V3.0 MAKES SOME ABI CHANGES.
	- FAVOR V2.X SYMBOL NAMES OVER THOSE OF V3.X

RELEASE
	- 2.8.0: (2006-12-22)
	- 2.9.1: (2012-05-27)
	- 2.10.0: (2016-09-18)
	- 2.11.0: (2018-08-08)
	- 3.0.0: (2018-08-08)

POSIX MACROS LIKE "_POSIX_THREAD_ATTR_STACKADDR" COULD SET TO -1 TO INDICATE TO NO SUPPORT. V3.0
		OF THIS LIBRARY FIXES THAT.

MACRO "PTW32_GET_ERRNO" AND "PTW32_SET_ERRNO" APPEAR SAFE TO USE INSTEAD OF errno
	- SOME SOURCES SUGGEST ONLY AVAILABLE ON VISTA AND UP. OTHER SOURCES SUGGEST THAT IT WAS
			AVAILABLE ON XP, AND IS INSTEAD TIED TO THE MS CRT VERSION. UNSURE, BUT THE MACRO
			STILL APPEARS SAFE TO USE.
	- LESS THAN <VS2005 DO NOT SEEM TO HAVE _set_errno().
			SEE https://github.com/curl/curl/issues/895
			I AM ASSUMING THE SAME FOR _get_errno()
	- UNSURE ABOUT THE USAGE OF _set_errno AND SetLastError  TOGETHER IN THE MACRO
			PTW32_SET_ERRNO. SEE https://github.com/curl/curl/issues/895
	- errno IS PART OF THE CRT, WHILE GetLastError()/SetLastError() IS PART OF WIN32. THEIR VALUES
			ARE NOT NECESSARILY THE SAME
	- QUOTE:
					"On some ancient systems, <errno.h> was not present or did not
					declare errno, so that it was necessary to declare errno manually
					(i.e., extern int errno).  Do not do this.  It long ago ceased to
					be necessary, and it will cause problems with modern versions of
					the C library."{SRC: https://man7.org/linux/man-pages/man3/errno.3.html"
			THIE MIGHT HAPPEN IF errno HAPPENS TO BE A MACRO FOR EXAMPLE, OR HAD OTHER MODIFIERS
			ATTACHED TO ITS DECLERATION.
			CONFIRMED THAT THE LIBRARY ONLY HAS SUCH AN EXPLICIT DECLERATION, MEANING 
			"extern int errno", SEE "_ptw32.h", IF THE HEADER IS AUTOMATICALLY DETECTED NOT TO 
			EXIST BY autoconf, OR NEED_ERRNO IS DEFINED.

IT APPEARS THAT THE MICROSOFT LONGLONG TYPE DEF EVALUATES TO THE INT64 TYPE AND CAN BE ASSUMED TO DO 
		SO ON VISUAL STUDIO 6 EVEN WHEN THE MIDL COMPILER IS USED. IT APPEARS THAT THE MIDL 
		COMPILER V2, AND NOT THE MIDL LANGUAGE V2, HAS SUPPORT FOR INT64. THE VERSION OF THE 
		COMPILER THAT COMES WITH VISUAL STUDIO 6 IS 5.X. CHATGPT THINKS V1 WAS RELASED IN October 1991
		AND V2 WAS RELEASED IN 1996 BUT IT ALSO THINKS V3 WAS RELEASED IN October 11, 1993.
		HOWEVER WITH ALLOWING THE USE OF uint64_t INSTEAD OF LONGLONG, THE LIBRARY IS GOING TO BE
		DEPENDENT ON CRX. (NOTE: THIS WORK WAS TRIGGERED BY THE CHANGE IN ptw32_timespec.c WHERE
		V3.0.0 USES uint64_t INSTEAD OF THE TYPE DEF LONGLONG, BUT NOTE THAT LONGLONG EVALUATES TO
		__int64 (int64_t), NOT unsigned __int64. THIE IS RELATED TO
				"Do not cast a pointer to a FILETIME structure to either a ULARGE_INTEGER* or 
				__int64* value because it can cause alignment faults on 64-bit Windows."
				{SOURCE: https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime}
		YOU CAN CAST FROM INT 64 TO FILETIME BUT NOT THE OTHER WAY ARROUND. FILETIME IS MADE UP OF
		TWO DWORDS, AND EACH DWORD IS uin32_t OR IN MICROSOFT HEADERS, unsigned long WHICH ASSUMES
		long IS 32BITS. REMEMBER, ON SOME SYSTEMS, LONG CAN BE 64BITS. THIS DEPEND ON THE INTEGRAL
		DATA MODEL FOLLOWED, WHETHER LLP64, OR LP64. SEE MY C++ NOTES.
		AFTER FURTHER ANALYSIS, DWORD USAGE IN V2.8.0 MUST BE KEPT AS IS. THIS ISSUE PERTAINS TO
		pthread.h WHERE V3.0.0 CHANGES DWORD TO unsigned long, BUT WHEN EXAMINING THE REST OF THE
		CODE, IT CONTINUES TO USE DWORD. FOR EXAMPLE A FUNCTION DECLERATION WOULD USE unsigned long,
		BUT THE DEFINITION ELSEWHERE WOULD USE DWORD. THIS IS FORBIDDEN PER THE STANDARD.

CHECK:
	pthread_attr_t::stackaddr IS INDEED USED AS STACK ADDRESS AND NOT STACK SIZE.
	THAT ptw32_throw DOES CALL CloseHandle EVENTUALLY IF NEEDED, AND THIS IS NEEDED WHEN USING
			_endthreadex INSTEAD OF _endthread SEE pthread_exit.c TO ENSURE MATCHING CONDITIONS
			ALSO SEE ptw32_threadDestroy.c TO ENSURE THE SAME.
	NEED_FTIME: THIS MACRO, WHICH APPEARS TO BE CONFIGURATION MACRO, WAS REMOVED LATER AND TREATED
			AS IF ALWAYS DEFINED. CHECK WHY IT EXISTED IN THE FIRST PLACE AS AN OPTION.
		UPDATE: THE STRUCTURE timespec WHICH IS TO BE FROM <time.h> IS NOT IN VISUAL STUDIO 6.
				NEWER VERSIONS OF THIS LIBRARY CONTINUE TO DETECT FOR THE MACRO
				HAVE_STRUCT_TIMESPEC, BUT DO NOT PROVIDE THEIR OWN DEFINITION OF THE timespec WHEN
				NECESSARY. THIS WAS DONE IN pthread.h. BROUGHT BACK THE CODE FROM THERE BUT INTO
				THE CrxOs LIBRARY.
				
				WITH THE ABOVE FIXES IN pthread.h PERTAINING TO timespec, THIS MACRO MIGHT NOW BE SAFE
					TO ASSUME THAT IT IS ALWAYS SET. WITH THIS, THE WORK ON THE FOLLOWING WHERE 
					MARKED, IS DONE:
							FILE(V2.8.0)				IS DONE
							config.h					Y
							implement.h					Y
							mutex.c
							pthread.h					Y
							ptw32_relmillisecs.c		Y
							ptw32_timespec.c			Y
							semaphore.c
							
				timespec MEMBER, ALTHOUGH SIGNED, SHOULD NEVER BE NEGATIVE. SEE
						/*SOURCE: https://www.gnu.org/software/libc/manual/html_node/Time-Types.html*/
						/*SOURCE: https://lkml.org/lkml/2010/6/28/169*/
						
				UPDATE: NOTE THAT AFTER V2.8.0 THE DEFINITION OF timespec WAS MOVED TO sched.h,
						AND CHANGED SLIGHTLY
		UPDATE:
			- UNDER V2.8.0 NEED_FTIME WAS A MACRO FOR SAYING WHETHER _ftime() EXISTS OR NOT
			- I WAS UNABLE TO FIGURE OUT WHY OLDER CODE WOULD HAVE FAVORED _ftime() INSTEAD OF 
					SIMPLY RELYING ON GetSystemTimeAsFileTime, OR BOTH OF GetSystemTime AND 
					SystemTimeToFileTime. GetSystemTimeAsFileTime() DOES NOT EXIST ON WINCE, BUT 
					NEITHER DOES _ftime(). IT SEEMS THAT IT WAS SIMPLY FAVORED FOR CONVENIENCE. 
					CHATGPT SUGGESTS THAT IT IS FASTER OVERALL. 
					MICROSOFT DOCUMENTATION SUGGESTS GetSystemTimeAsFileTime() IS EFFICIENT.
					AFTER ROUGHLY Visual Studio.NET 2005, _ftime() IS IMPLEMENTED USING 
					GetSystemTimeAsFileTime(). IN OTHER WORDS, THIS HAS NOT ALWAYS BEEN THE CASE.
			- IMPORTANT AFFECTED FILES: "ptw32_relmillisecs.c", "pthread.h"
			- DECIDED TO KEEP WHAT V3.0.0 HAS DONE, AND NO LONGER USE _ftime OR SUPPORT THE MACRO, 
					NEED_FTIME. THIS IS EQUIVILANT TO ASSUMING NEED_FTIME IS ALWAYS SET.
					NOTE THAT V3.0.0 STILL HAS USAGES OF _ftime IN ITS TEST CASES.

	pthread.h: LATER VERSIONS MOVED SOME OF THIS FILE'S CONTENT INTO THE config.h FILE, AND THE
			_ptw32.h FILE.
		IT ASSUMED THAT THE FILE config.h WHICH USED TO BE ADDED WITHIN IN pthread.h WILL ALWAYS BE
				ADDED AFTER config.h
		THIS FILES USED TO INCLUDE windows.h SOMETIMES, BUT NOT WE ALWAYS INCLUDE IT OURSELVES
				PER THE NEW VERSION, AND PER MY WORK USING CRXOS.
		THIS FILE EVENTUALLY INCLUDES winsock.h, AND THEREFORE IN windows.h NEEDS TO BE INCLUDED
				EARLY, BEFORE IT, IF I AM NOT WRONG, TO ATLEAST ENSURE THE CONFIGURATION IN
				CRXOS. THE INCLUDESION IS ONLY TO READ THE VALUE OF THE MACRO WSAETIMEDOUT
				NOTE THAT V2.8.0 AVOIDED INCLUDING winsock.h. 
				THE LIBRARY Boost.Asio IS ONE EXAMPLE THAT SUFFERS FROM THIS INCLUSION OF 
				winsock.h.
		IF YOU FIND THAT YOU CAN SUPPORT A NEW POSIX FEATURE INTRODUCED FROM V3.0.0
				MAKE SURE TO UPDATE THE POSIX MACROS IN THIS FILE.
		THE V3.0.0 FILE DOES NOT SEEM TO HAVE extern C WRAPPER WHEN THE LANGUAGE IS C++. MAKE
				SURE THAT THIS CONTINUES TO BE HANDLED CORRECTLY.
				THE EXISTS PThreadCleanup, A C++ CLASS, AND THAT EXISTANCE IS ILL DEFINED, AND 
				SHOULD BE FIXED. THIS COULD BE RELATED TO WHY extern C WAS REMOVED WHEN LANGUAGE
				IS C++.
				NOTE THAT V3.0.0 USES THE MACROS __PTW32_BEGIN_C_DECLS AND
				__PTW32_END_C_DECLS INSTEAD OF extern "C". THESE ARE DEFINED IN _ptw32.h .
		V3.0.0 MODIFIES THE STRUCTURE pthread_once_t_, AND ptw32_handle_t.
				THE MACRO __PTW32_VERSION_MAJOR HOWEVER ALLOWS CODE TO USE THE OLD VERSIONS
				OF THESE STRUCTURES.
		THE FILE ATTEMPTS TO AVOID LOADING windows.h AND PROVIDES ITS OWN DEFINITION OF HANDLE
				AND DWORD. V3.0.0 REMOVES THAT, AND AVOID USING THESE TWO MICROSOFT TYPES, AND
				INSTEAD USES THEIR UNDERLYING TYPES. HOWEVER, ELSEWHERE IN THE CODE, THE MICROSOFT
				TYPES ARE USED. HENCE, REVERTING THE CHANGE TO USE MICROSOFT TYPES AGAIN FOR
				HANDLE AND DWORD.
		YOU WILL LIKELY NEED TO FIX pthread_cleanup_push AND pthread_cleanup_pop BECAUSE OF
				THEIR USE OF THE finally CONSTRUCT WHICH IS AN ILL DEFINED CONSTRUCT AS
				PROVEN IN THE STANDARD. 
		v2.8.0 IGNORES NEED_ERRNO IF _UWIN IS DEFINED. THIS IS NOT THE CASE WITH V3.0.0.
		UNDER V2.8.0 IF NEED_ERRNO IS DEFINED, AND _UWIN IS NOT DEFINED, THE FOLLOWING IS DECLARED
				NO MATTER WHAT,
						PTW32_DLLPORT int * PTW32_CDECL _errno( void );
				HOWEVER, UNDER V3.0.0 THE DECLERATION ONLY HAPPENS IF
						((defined(_MT) || defined(_MD) || defined(_DLL)) && !defined(_MAC))
				KEEPING THINGS AS THEY ARE IN V3.0.0 FOR NOW.
		UNDER V3.0.0 PTW32_DLLPORT CAN BE DEFINED TWICE, ONCE IN need_errno.h AND ONCE IN pthread.h
		UNDER V2.8.0 THERE WERE THE MACROS strtok_r, asctime_r, ctime_r, gmtime_r, localtime_r,
				rand_r DEFINED BUT NOT USED IN CODE. THESE ARE LINUX FUNCTIONS THAT ARE THREAD SAFE,
				BUT UNDER WINDOWS, AND WITHOUT THE EXTENSION, THEY ARE ALREADY THREAD SAFE. FOR
				EXAMPLE strtok_r IS THREAD SAFE UNDER LINUX, BUT NOT strtok. UNDER WINDOWS, strtok
				IS THREAD SAFE.
	implement.h
		IMPORTANT: V2.8.0 DEFINES PTW32_INTERLOCKED_LONG DIFFERENTLY THAT V3.0.0. APPEARS TO AFFECT 
				VC6 SUPPORT. ALSO THIS IS RELATED TO THE IMPORTANT 
				ptw32_InterlockedCompareExchange() THAT NEEDS TO BE BROUGHT BACK TO V3.0.0
		IMPORTANT: V2.8.0 DEFINES PTW32_INTERLOCKED_LPLONG BUT V3.0.0 DOES NOT
		V3.0.0 INCLUDES "<sys/types.h>". THIS MIGHT REQUIRE FURTHER INVESTIGATION.
		THE ENUM VALUE PThreadStateException IN V2.8.0 APPEARS TO HAVE BEEN RENAMED TO
				PThreadStateExiting
		STRUCTURE ptw32_thread_t_/ptw32_thread_t:  
			- BETWEEN 2.8.0 TO 3.0.0 HAS THE FOLLOWING CHANGES:
				- TYPE OF threadLock CHANGED FROM pthread_mutex_t TO ptw32_mcs_lock_t
				- TYPE OF cancelLock CHANGED FROM pthread_mutex_t TO ptw32_mcs_lock_t AND APPEARS
						TO HAVE BEEN RENAMED TO stateLock
				- seqNumber EXISTS ONLY IN V3.0.0
					- THIS IS USED FOR IMPLEMENTING pthread_getunique_np() WHICH IS HIGHLY NON
							PORTABLE. REMOVED pthread_getunique_np(), BUT KEEPING THIS DATA
							MEMBER FOR NOW.
				- robustMxListLock EXISTS ONLY IN V3.0.0
				- robustMxList EXISTS ONLY IN V3.0.0
				- cpuset EXISTS ONLY IN V3.0.0
				- name EXISTS ONLY IN V3.0.0. NOTE THAT I SHALL NOT BE USING THIS BECAUSE
						THREAD NAMES CAN NOT BE SUPPORTED. HOWEVER, KEEPING THE MEMBER FOR NOW.
				- align EXISTS ONLY IN V3.0.0
			- UNSURE WHAT THE MEMBER dummy IS FOR
			- BE CAREFUL WITH THE threadH DATA MEMBER. UNDER WINDOWS CE, THIS MEMBER IS NOT SAFE
					TO PASS TO OTHER THREADS, AND HAS A DIFFERENT TYPE FROM OPERATING SYSTEM
					PERSPECTIVE. SEE pthread_self.c
		STRUCTURE sem_t_
			- BETWEEN 2.8.0 TO 3.0.0 HAS THE FOLLOWING CHANGES:
				- TYPE OF lock CHANGED FROM pthread_mutex_t TO ptw32_mcs_lock_t
		STRUCTURE pthread_mutex_t_
			- BETWEEN 2.8.0 TO 3.0.0 HAS THE FOLLOWING CHANGES:
				- robustNode EXISTS ONLY IN V3.0.0
				- kind CAN BE NEGATIVE IN V3.0.0 TO INDICATE A "ROBUST" MUTEX, AND ALL THE
						POSITIVE VALUES OF KIND END UP BEING MAPPED TO NEGATIVE VALUES.
						kind IS SUPPOSED TO HOLD A VALUE OF THE NAMELESS ENUM "Mutex types"
						IN pthread.h. THIS LIBRARY SIMPLY TREATS ENUM VALUES AS INTEGERS
		STRUCTURE pthread_mutexattr_t_
			- BETWEEN 2.8.0 TO 3.0.0 HAS THE FOLLOWING CHANGES:
				- robustness EXISTS ONLY IN V3.0.0
		STRUCTURE pthread_barrier_t_
			- BETWEEN 2.8.0 TO 3.0.0 HAS THE FOLLOWING CHANGES:
				- iStep NO LONGER EXISTS IN V3.0.0
				- TYPE OF semBarrierBreeched CHANGED FROM sem_t[2] TO sem_t
				- lock EXISTS ONLY IN V3.0.0
				- proxynode EXISTS ONLY IN V3.0.0
		STRUCTURE pthread_key_t_
			- BETWEEN 2.8.0 TO 3.0.0 HAS THE FOLLOWING CHANGES:
				- TYPE OF keyLock CHANGED FROM pthread_mutex_t TO ptw32_mcs_lock_t
		STRUCTURE pthread_attr_t_
			- BETWEEN 2.8.0 TO 3.0.0 HAS THE FOLLOWING CHANGES:
				- cpuset EXISTS ONLY IN V3.0.0
				- thrname EXISTS ONLY IN V3.0.0
					- I SHALL NOT BE REQUIRING THIS, BUT KEEPING FOR NOW IN CASE I ADD SUPPORT
							THROW A NORMALIZING LAYER LATER. SEE THE ISSUE RELATED TO
							"pthread_attr_setname_np()"							
		MACRO, PTW32_SPIN_INVALID, WHICH ACTS AS A MACRO, WAS INTRODUCED IN V3.0.0, 
				AND HAS THE VALUE 0. HOWEVER IN V2.8.0 IT SEEMS THAT THE MACRO
				PTW32_OBJECT_INVALID SHOULD BE USED, AND THAT HAD A VALUE OF NULL.
				REMEMBER THAT NULL IS NOT NECESSARILY 0.
		IMPORTANT: 
					ptw32_interlocked_compare_exchange 		FUNCTION POINTER		(WILL NOT BE ADDED)
					ptw32_InterlockedCompareExchange		FUNCTION				(DONE)
					ptw32_InterlockedExchange										(DONE)
					PTW32_INTERLOCKED_COMPARE_EXCHANGE								(DONE, RENAMED)
				WERE REMOVED IN V3.0.0 AND NEED TO BE BROUGHT BACK.	
					NOTE PTW32_INTERLOCKED_COMPARE_EXCHANGE EFFICETEVLY RENAMED TO 
							PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG BUT NOW DOES CALL A FALLBACK
							FUNCTION INSTEAD OF THE BUILT IN InterlockedCompareExchange.
							UNLIKE THE V2.8.0 IMPLEMENTATION WHICH FAVORS InterlockedCompareExchange
							IF IT EXISTS, THIS FORK FAVOR ptw32_InterlockedExchange, MEANING
							THE FALLBACK, INSTEAD.
					TODO: PART OF THIS ADDED MACROS FOR GCC IN implement.h FOR SINGLE PROCESSORS,
							BUT CONTINUED TO USE THE "memory" AND "cc" FEATURE FROM GCC'S
							ASSEMBLER. THESE NEED INVESTIGATION AND PROBABLY "memory" ATLEAST NEEDS
							TO BE REMOVED. THIS WOULD BE CONSISTENT WITH REMOVING lock ON THE
							COMPARE EXCHANGE INSTRUCTION. HOWEVER, REMEMBER, SUCH THING REMAINS
							DANGEROUS IF SOMETHING, OTHER THAN THE CPU, ENDS UP WRITING TO RAM.
				YOU WILL HAVE TO MAKE THE MACRO PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG
						RESOLVE TO ptw32_interlocked_compare_exchange OR 
						ptw32_InterlockedCompareExchange. REMEMBER long IS int UNDER WINDOWS
						YOU ALSO WANT IT TO RESOLVE TO InterlockedCompareExchange IF THE FUNCTION
						IS AVAILABLE.
				IMPLEMENT PTW32_INTERLOCKED_EXCHANGE_ADD_LONG FOUND IN V3.0.0 WITH ASSEMBLY AND
						USE THE INSTRUCTION XADD WITH PREFIX LOCK, AND USE THE WINDOWS 
						InterlockedExchangeAdd IF AVAILABLE. TODO(DONE).
				IMPLEMENT __PTW32_INTERLOCKED_INCREMENT_LONG FOUND IN V3.0.0 WITH ASSEMBLY AND
						USE THE INSTRUCTION XADD WITH PREFIX LOCK, AND USE THE WINDOWS 
						InterlockedIncrement IS VALID. ON WINDOWS 95, THIS FUNCTION DID NOT RETURN 
						THE NEW VALUE, AND SIMPLY RETURNED A VALUE WHOSE
						SIGN IS THE CORRECT SIGN PER THE NEW VALUE. ON WINDOWS 98, THIS WAS ALSO
						THE CASE DEPENDING ON THE PROCESSOR. ESSENTIALY, SINCE PENTIUM 1, OR THE
						INSTRUCTION SET 80486, "LOCK XADD" COULD BE USED INSTEAD OF "LOCK INC",
						AND THAT COULD BE USED TO RETURN THE NEW VALUE. ASSUME THAT YOU ARE ONLY
						RUNNING ON PENTIUM 1 AND UP, AND AVOID InterlockedIncrement ON WINDOWS 98
						AND BELOW, OR PERHAPS ALL OF WINDOWS 9X.
						IT APPEARS THAT THE LOCK PREFIX ALSO APPLIES A FULL MEMORY BARRIER ON 
						X86 AS REQUIRED BY InterlockedIncrement
						TODO(DONE).
				IMPLEMENT __PTW32_INTERLOCKED_DECREMENT_LONG FOUND IN V3.0.0. SEE NOTES ABOVE FOR
						IMPLEMENTING __PTW32_INTERLOCKED_INCREMENT_LONG. TODO(DONE).
				IMPLEMENT PTW32_INTERLOCKED_COMPARE_EXCHANGE_PTR FOUND IN V3.0.0 WHICH USES
						InterlockedCompareExchange IF THE MACRO "PTW32_CONFIG_MSVC6" IS SET OR
						InterlockedCompareExchangePointer IF NOT. InterlockedCompareExchangePointer
						IS WIN2K AND UP. TODO(DONE).
				
		TYPE OF 
						ptw32_thread_reuse_lock
						ptw32_mutex_test_init_lock
						ptw32_cond_list_lock
						ptw32_cond_test_init_lock
						ptw32_rwlock_test_init_lock
						ptw32_spinlock_test_init_lock
				CHANGED FROM CRITICAL_SECTION TO ptw32_mcs_lock_t	
				THESE ARE INITIALIZED IN "ptw32_processInitialize.c" USING 
				InitializeCriticalSection() IN V2.8.0, AND SIMPLY SET TO ZERO IN V3.0.0
		IMPORTANT: IF MACRO NEED_CALLOC IS SET, DEFINES ITS OWN MACRO calloc AND A FUNCTION
				ptw32_calloc. THAT FUNCTION ALSO MOVED FROM misc.c TO pthw32_calloc.c IN
				V3.0.0
		ptw32_throw MOVED FROM private.c TO ptw32_throw.c IN V3.0.0
		
		IT IS UNCLEAR WHY __PTW32_INTERLOCKED_VOLATILE, WHICH IS RELATED TO VC6, IS NECESSARY.		
	global.c
		ADDED BACK ptw32_smp_system FROM V2.8.0.
		ptw32_interlocked_compare_exchange WILL NOT BE ADED BACK. SEE DICUSSION ELSEWHERE.
		THIS FILE IS A GOOD CANDIDATE TO ADD MY NEEDED GLOBAL VARIABLES FUNCTIONALITY ONCE
				THIS WORK IS DONE.
		ptw32_register_cancelation FROM V2.8.0 WAS RENAMED TO ptw32_register_cancellation.
				MIGHT ADD BACK THE OLD NAME IN THE FUTURE WHILE THE NEW NAME ALSO.
	[SEMAPHORE FILES]:
		GENERAL
			- NOTE THAT THE FUNCTIONS DEAL WITH A POINTER TO A POINTER TO THE ACTUAL sem_t_ STRUCTURE
					sem_t IS A POINTER TO sem_t_, AND THE FUNCTION DEAL WITH "sem_t *".
			- IN V2.8.0, sem_destroy() WILL SET THE UNDERLYING sem_t, NOT sem_t_, TO NULL WHEN
					DONE WHILE HOLDING THE SEMAPHORE SPECIFIC LOCK IF THERE ARE NO OTHER
					THREADS WAITING TO RUN. THIS IS WHY WHEN OTHER FUNCTIONS AQUIRE THE LOCK, THEY 
					MUST RECHECK THE UNDERLYING sem_t AGAINST NULL BEFORE DOING ANYTHING.
					IN V2.8.0 THE EXTRA LOOP OF EXPLICITLY CALLING Sleep() IS BECUASE RELEASING
					THE MUTXES, CALLING THE FUNCTION pthread_mutex_destroy() CAN RETURN IMMEDIATELY 
					WITH A BUSY MESSAGE, EBUSY. THIS CAN HAPPEN IF THE MUTEX IS HELD MULTIPLE TIMES
					BY THE SAME THREAD, OR IS CURRENTLY HELD BY ANOTHER THREAD. ON THE OTHER HAND, 
					ptw32_mcs_lock_release() GUARANTEES TO HAVE RELEASED ITS TICKET OF THE LOCK 
					BEFORE FINISHING. THIS MEANS THAT V2.8.0 IS MORE GUARANTEED, AT LEAST, TO BE 
					COMPLETELY DONE WITH THE LOCK BEFORE FINALLY FREEING THE sem_t_ STRUCTURE THAT 
					IS HOLDING THE LOCK. THIS IS NOT THE CASE WITH V3.0.0.
					NEITHER OF V2.8.0 AND V3.0.0 WILL TRY TO RECOVER IF CloseHandle ON THE
					UNDERLYING WINDOWS SEMAPHORE FAILS.
					BECAUSE OF THE ABOVE, SEMAPHORE FUNCTIONS IN V2.8.0 WILL KEEP A LOCAL COPY
					OF THE UNDERLYING sem_t, NOT sem_t_, IN CASE sem_destroy() WAS CALLED AND
					ALREADY SET IT TO NULL. IN THE MEAN TIME, THE OTHER FUNCTIONS CAN CONTINUE
					TO DO THEIR THING, WHILE sem_destroy() PROCEEDS TO WAIT FOR THEM TO FINISH
					BEFORE RETURNING TO ITS CALLER.
					HENCE ALSO WHY SUCH FUNCTIONS IN V2.8.0 CHECK WHETHER THE POINTER TO THE
					UNDERLYING sem_t THAT IS PASSED IS NOT POINTING TO A sem_t THAT IS ITSELF
					NULL RIGHT UPON ENTERING THE FUNCTION. HOWEVER, USING sem_getvalue() AS
					AN EXAMPLE, THIS WAS STILL A BUG IN V2.8.0 BECAUSE THE FUNCTION STILL SAVES
					A LOCAL COPY OF sem_t, AND USES IT TO AQUIRE THE LOCK WHICH IS
					STORED ON THE sem_t_ POINTED TO BY THE sem_t. IT IS POSSIBLE THAT DURING THAT 
					TIME THE UNDERLYING sem_t WAS ALREADY SET TO NULL. THE FIX IS TO RECHECK
					FOR NULL AGAIN ON THE LOCAL COPY OF sem_t.
					NOTE THAT NEITHER OF THESE BEHAVIORS ARE A VIOLATION OF POSIX FROM WHAT I COULD
					TELL.
					TODO: THIS OLD BEHAVIOR MIGHT BE DESIRABLE TO BRING BACK.
		sem_init.c
			NOTE THAT THE SEMAPHORE ESSENTIALY RELIES NOW ON THE MCS LOCK INSTEAD OF ON THE PTHREAD 
			MUTEX IN V3.0.0 COMPARED TO V2.8.0. HENCE sem_init() IN V3.0.0, UNLIKE V2.8.0, NO LONGER 
			INITIALIZES THE lock DATA MEMBER WITH A pthread_mutex_init(). 
	ptw32_relmillisecs.c
		ptw32_relmillisecs() IN V2.8.0 CAN RETURN 0 IN SITUATIONS WHERE THE SAME FUNCTION IN
		V3.0.0 WOULD RETURN 1. V3.0.0 ROUNDS UP (0,1] TO 1. THERE IS AN ASSUMED USAGE FOR 
		ptw32_relmillisecs(), WHICH IS CONTRARY TO THE FUNCTION NAME. THEREFORE THIS FUNCTION IS A 
		POTENTIAL FOR BUGS. TODO(DONE), DOUBLE CHECK THIS FUNCTION'S USAGE THROUGH OUT THE CODE.
		NOTE: VALUE OF MICROSOFT'S "INFINITE" IS FOR THE TYPE DWORD, WHICH SHOULD BE THE MAXIMUM
				VALUE FOR UNSIGNED 32BIT.
		NOTE: THIS FUNCTION IS MEANT TO RETURNT HE DIFFERENCE BETWEEN NOW AND THE DATE PASSED TO IT
				WHICH IS SUPPOSED TO BE IN THE FUTURE. A TIMEOUT VALUE.
	ptw32_throw.c
		ptw32_throw() ALWAYS ESCAPE WHAT CALLS IT, FROM WHAT I CAN TELL. IN OTHER WHERE IT GET
				CALLED, THE NEXT LINE IS GUARANTEED NOT TO EXECUTE. IF YOU MODIFY THE FUNCTION SUCH
				AS THIS IS NOT LONGER THE CASE, YOU NEED TO EXAMINE THE CODE CAREFULY WHERE
				THIS FUNCTION IS CALLED.
	[BARRIER FILES]
		pthread_barrier_destroy.c
			THERE IS AN ISSUE WHERE THE REQUIRED NUMBER OF THREADS REACH THE BARRIER, AND THEY 
			ARE ALL, EXCEPT THE LAST THREAD TO REACH THE BARRIER, CURRENTLY INSIDE THE 
			ptw32_semwait() WHICH GOT CALLED WHEN EACH THREAD CALLED pthread_barrier_wait(). 
			NOW THE LAST THREAD CALL TO pthread_barrier_wait() RETURNS IMMEDIATELY. IF THE
			THREAD HAPPENS TO CALL pthread_barrier_destroy() AND FINISH, WHILE ANOTHER THREAD IS 
			STILL INSIDE pthread_barrier_wait() AND BEFORE THE CALL TO ptw32_semwait(), THAT CALL
			WILL HAPPEN ON A SEMAPHORE THAT IS NO LONGER VALID BECAUSE pthread_barrier_destroy()
			WOULD HAVE FREEED THE BARRIER STRUCTURE ALONG WITH THE SEMAPHORE INSIDE IT.
			NOTE THAT THIS PROBLEM ALSO EXISTS IN THE V2.8.0 IMPLEMENTATION BASED ON MY ANALYSIS, 
			NOT JUST THE NEW ONE.
			
			IF I AM NOT WRONG, THE SOLUTION TO THIS IS TO HAVE A COUNTER INSIDE THE BARRIER
			STRUCTURE INITIALIZED TO ZERO, AND HAVE IT ATOMICALLY INCREMENTED INSIDE 
			pthread_barrier_wait() BEFORE THE LOCK IS AQUIRED, AND DECREMENTED AFTER BOTH THE LOCK 
			IS AQUIRED AND EITHER OF ptw32_semwait() OR sem_post_multiple() IS CALLED. 
			pthread_barrier_destroy() CAN THEN ATOMICALLY CHECK ON THIS VALUE BEFORE PROCEEDING
			TO DESTROY THE BARRIER, WHICH WOULD ONLY BE ALLOWED IF THE VALUE IS ZERO.
			UPDATE: UPON FURTHER INSPECTION, IT DOES NOT LOOK LIKE SUFFERS FROM THE ABOVE. I WAS
			WRONG, AND SO WAS THE COMMENT IN THE CODE, OR PERHAPS I MISUNDERSTOOD IT. SEE THE FILE
			"pthread_barrier_wait.c" AND "pthread_barrier_destroy.c".
	pthread_detach.c
		IN V2.8.0 THE THREAD STATE IS CHECKED AGAINST THE ENUM VALUE, PThreadStateLast BY
		"!=". THIS ENUM IS EXPECTED TO HAVE A SPECIFIC ORDER. IN V3.0.0, THE CHECK USES
		"<". THEREFORE BE CAREFUL WITH FUTURE MODIFICATION TO THE UNDERLYING ENUM, WHICH IS
		FOUND IN implement.h.
		MARKING THE THREAD FOR DESTRUCTION IF ITS STATE IS PThreadStateExiting, IS NEW BEHAVIOR
		IN V3.0.0. NOTE THAT STATE PThreadStateExiting WAS PThreadStateException IN V2.8.0. THIS
		MEANS THAT V2.8.0 WOULD HAVE AVOIDED TRYING TO DESTROY A THREAD IN PThreadStateException.
		KEEPING THE V3.0.0 BEHAVIOR FOR NOW.
	pthread_kill.c
		pthread_kill() IMPLEMENTATION DOES NOT KILL A THREAD, AND CAN ONLY BE USED TO CHECK IF THE 
		THREAD ID IS VALID. IN V2.8.0, THE THREAD OBJECT IS EXPECTED TO HAVE A WINDOWS THREAD 
		HANDLE TO BE VALID. IN V3.0.0 THIS IS EXTENDED TO THE THREAD ALSO HAVING THE 
		PThreadStateRunning STATE, WHICH TAKES LONGER TO HAPPEN COMPARED TO HAVING A WINDOWS THREAD
		HANDLE. THE FUNCTION CAN ONLY ACCEPT 0 FOR THE SECOND PARAMETER IN THIS IMPLEMENTATION.
		IN V3.0.0, THE FUNCTION IS MORE STRICT ABOUT THIS, UNLIKE V2.8.0, WILL NOT DETECT AN INVALID
		THREAD IF THE SECOND PARAMETER IS NOT 0. 2.8.0 WILL CONTINUE TO NOT DETECT A VALID, NOT
		INVALID, THREAD IF THE SECOND PARAMETER IS 0. V2.11.0 BEHAVES LIKE V2.8.0
	pthread_getunique_np.c
		pthread_getunique_np() IS HIGHLY NON PORTABLE. IT DOES NOT EXIST ON LINUX NOR BSD NOR MAC,
		AND WHERE I FOUND IT EXISTING IT HAD A DIFFERENT SIGNATURE. REMOVED THIS FUNCTION, BUT 
		KEEPING THE seqNumber DATABA MEMEBER OF ptw32_thread_t_ FOR NOW.
	ptw32_callUserDestroyRoutines.c
		ptw32_callUserDestroyRoutines() USES Sleep(1) IN V2.8.0, AND Sleep(0) IN V3.0.0. QUOTE:
						"Windows XP: A value of zero causes the thread to relinquish the remainder 
						of its time slice to any other thread of equal priority that is ready to 
						run. If there are no other threads of equal priority ready to run, the 
						function returns immediately, and the thread continues execution. This 
						behavior changed starting with Windows Server 2003." {SOURCE: 
						https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep}
				CONFIRMED THE ABOVE FOR WINDOWS 95. 
						"A value of zero causes the thread to relinquish the remainder of its time 
						slice to any other thread of equal priority that is ready to run. If there 
						are no other threads of equal priority ready to run, the function returns 
						immediately, and the thread continues execution." {SOURCE:
						http://www.cs.rpi.edu/academics/courses/fall09/os/win32/sleep.html}
				UPDATE: FOR LATER WINDOWS, I THINK THE RELEVANT QUOTE:
						"After the sleep interval has passed, the thread is ready to run. If you 
						specify 0 milliseconds, the thread will relinquish the remainder of its time 
						slice but remain ready. Note that a ready thread is not guaranteed to run 
						immediately. Consequently, the thread may not run until some time after the 
						sleep interval elapses. For more information, see Scheduling Priorities."
						{SOURCE: 
						https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep}
				JUDGING FROM THE ABOVE QUOTE, AND LATER WORK I DID ON SCHEDULING, ON LATER WINDOWS
				Sleep(0) WOULD ALLOW A THREAD OF EQUAL OR HIGHER PRIORITY TO RUN. IF WINDOWS ALSO
				TREATS THE WAKING UP FROM Sleep(0) AS A WAKING UP FROM A WAIT CALL, THE THREAD
				MIGHT ALSO RECIEVE A PRIORITY BOOST, IN WHICH CASE, IT MIGHT RUN BEFORE A THREAD
				OF HIGHER BASE PRIORITY.
	ptw32_reuse.c
		pthread_t IS DEFINED THE WAY IT, MEANING BOTH THE HANDLE AND A COUNTER NEED TO BE EQUAL AS
				MENTIONED IN THE COMMENTS ptw32_reuse.c, BECAUSE CREATING A THREAD COULD END UP
				RETURNING A WINDOWS HANDLE WITH THE SAME VALUE IF I AM NOT WRONG. HENCE THE NEED OF 
				THE SECOND COUNTER. WITH THIS WE ARE MAKING THESE UNIQUE. HENCE, WHY IF WE DO NOT
				WANT THESE TO BE UNIQUE, WE COULD SET PTW32_THREAD_ID_REUSE_INCREMENT TO 0.
				SEE "config.h".
				BASE ON "config.h" IT APPEARS THAT POSIX EXPLICITLY MENTIONS THAT THESE ARE NOT 
				NECESSARILY UNIQUE. HENCE, THESE "THREAD IDS", CAN NOT BE ASSUMED UNIQUE AS PART OF 
				THE NORMAL FORM. NOTE, HOWEVER, THE "THREAD IDS" ARE GUARANTEED TO BE UNIQUE AS
				LONG AS THE NATIVE THREAD IS NOT RELEASED BACK TO THE OS, AND THE THREADS ARE FROM 
				THE SAME PROCESS. THIS APPLIES TO WINDOWS AND OTHER SYSTEMS FROM WHAT I COULD TELL. 
				IN WINDOWS, THESE MIGHT NOT NEED TO BE FROM THE SAME PROCESS, BUT I AM NOT SURE.
	ptw32_threadStart.c
		THE CODE USES A LOCK TO WAIT FOR WINDOWS TO CREATE A THREAD HANDLE. THE LOCKED REGION
				DOES NOTHING IN V2.8.0, WHILE IT DOES SOMETHING UNRELATED IN V3.0.0. THE LOCK IS
				SET IN create.c, THE FUNCTION, pthread_create().
				AS SOON AS ptw32_threadStart() AQUIRES THE LOCK, THE THREADS state IS SET TO
				PThreadStateRunning. NOTE THAT IN V2.8.0, AND V2.11.0, THE THREAD STATE IS SET TO 
				PThreadStateInitial IN pthread_create(), WHILE IN V3.0.0 IT IS SET TO
				PThreadStateSuspended. HOWEVER, IF THE CODE USES _beginthread() INSTEAD OF
				_beginthreadex(), THIS STATE IS INCORRECT, BUT FOR A BRIEF MOMENT, WHICH AMOUNTS
				TO THE REGION OF THE CODE IN ptw32_threadStart() BEFORE THE LOCK IS AQUIRED.
		THE CODE IN V2.8.0, THAT WHICH PERTAINS TO THREAD CANCELATION USING THE C++ MECHANISM,
				TRIES MUCH TO MAKE SURE THAT pthread_win32_thread_detach_np() IS CALLED IN THE EVENT
				OF AN UNEXPECTED ERROR HAPPENING. THE CODE IN V3.0.0 DOES NOT. IT SEEMS THAT CODE
				IN V3.0.0 ASSUMES, OR EXPECTS, A MORE SANE SECNARIO FROM USER CODE KNOWING THAT
				IF USER CODE EXITS THE PROCESS INSIDE THE MAIN USER FUNCTION OF THE THREAD,
				IT IS ON THE USER. V2.8.0 ALSO TRIES TO CONCERN ITSELF WITH USER CODE THAT MIGHT
				BE REGISTERED WITH ::std::terminate().
				KEEPING THE V3.0.0 APPROACH. I MIGHT ADD THE OLD V2.8.0 BEHAVIOR AS AN ALREADY
				BUILT FUNCTION FOR USER CONVENIENCE WHEN IMPLEMENTING THE SUPPORT OF ALLOWING
				USER TO PROVIDE THEIR OWN FUNCTION POINTERS TO HELP IN THREAD CANCELATION, TO AVOID
				HAVING TO COMPILE THE DLL AGAIN FOR EACH COMPILER. (TODO)
				UPDATE: CONFIRMED V2.9.1 TO BEHAVE LIKE V2.8.0.
		pthread_win32_set_terminate_np() IS NOT USED ANYWHERE IN THE CODE IN V3.0.0, EXCEPT FOR A
				TEST CASE, PART OF THE TESTS.
				UPDATE: REMOVED FROM CODE. STILL NEED TO FIGURE THE USAGE IN THE TEST CASES.
				
	create.c
		THIS IS FOR THE FUNCTION pthread_create()
		QUOTE:
				"If successful, each of these functions returns a handle to the newly created 
				thread; however, if the newly created thread exits too quickly, _beginthread might 
				not return a valid handle. (See the discussion in the Remarks section.) On an error, 
				_beginthread returns -1L, and errno is set to EAGAIN if there are too many threads,
				to EINVAL if the argument is invalid or the stack size is incorrect, or to EACCES if 
				there are insufficient resources (such as memory). On an error, _beginthreadex 
				returns 0, and errno and _doserrno are set." {SOURCE:
				https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-170}
		CONCERNING THE COMMENT IN THE CODE:
				"State must be >= PThreadStateRunning before we return to the caller.
				* ptw32_threadStart will set state to PThreadStateRunning."
		RIGHT BEFORE SETTING state TO PThreadStateSuspended, NOTE THAT THIS AFFIRMS THAT THE ORDER
		OF ENUM VALUES IN THE ENUM, PThreadState, DEFINED IN "implement.h" MUST NOT CHANGE.
	sched.h
		V3.0.0 CODE SEEMS TO ASSUME THAT PTW32_LEVEL IS SET TO PTW32_LEVEL_MAX OR HIGHER. V2.8.0
				DOES NOT, AND CONTINUES TO DEFINES THINGS BASED ON THE PTW32_LEVEL. KEEPING V3.0.0 
				APPRAOCH.
		V3.0.0 TRIES TO AVOID INCLUDING <sys/types.h> IF IT IS AVAILABLE BY DEFINING pid_t ITSELF,
				BUT IT THEN HAS TO TRY TO AVOID DEFINING pid_t ITSELF IF <sys/types.h> IS INCLUDED
				ELSEWHERE. V2.8.0 DOES NOT, AND SIMPY INCLUDES <sys/types.h>. 
				MIGHT FIX THIS IN THE FUTURE, AND RETURN V2.8.0 APPROACH. (TODO)
		sched_setscheduler() IS NOT POSIX COMPLIANT. MIGHT WANT TO ADDRESS THIS BY SIMPLY ADDING
				A "void const *" PARAMETER, BUT LIKELY REMAINS A POSIX VIOLATION. SEE
				https://man7.org/linux/man-pages/man2/sched_setscheduler.2.html
				(TODO)
		ADDED MISSING sched_getscheduler() DECLARATION, WHICH WAS PRESENT IN V2.8.0. CONFIRMED
				IT TO BE PRESENT AGAIN, IN V3.0.3
	sem_open.c
		2.8.0 DECLARES sem_open() WITH ALL ITS PARAMATERS MAKING IT DEPENDENT ON THE mode_t TYPE, 
		AND HENCE THE CONFIGURATION MACRO, HAVE_MODE_T. HOWEVER, THE PARAMETER IS NEVER USED,
		AND mode_t ITSELF IS NEVER USED ANYWHERE ELSE IN THE LIBRARY, BUT THE LIBRARY STILL TRIES
		TO DEFINE IT IF IT IS NOT DEFINED. IN V3.0.0, sem_open() IS DECLARED TO BE VARIADIC TO AVOID 
		THE mode_t PARAMETER, AND HENCE THE mode_t IS NEVER USED ANYWHERE IN THE LIBRARY. FURTHER 
		MORE, THIS VERSION ALSO DOES NOT TRY TO DEFINE mode_t IF NOT DEFINED. NOTE THAT V2.8.0
		DOES THAT IN semaphore.h.
		TODO(DONE): REMOVE THE REMAINING TRACE OF HAVE_MODE_T, WHICH IS IN config.h AND _ptw32.h.
		
NOTE THAT V2.8.0 TENDS TO REPEAT ITSELF IN A NUMBER OF FILES WHERE IT FIGURES OUT PTW32_LEVEL,
		PTW32_DLLPORT, NEED_ERRNO AND INCLUDES "need_errno.h". V3.0.0 REMOVES THESE REPITIONS
		AN EXAMPLE OF THIS IS IN semaphore.h
		
		
TODO: THE FILES sched.h AND semaphore.h ARE ESSENTIALY REPLACEMENT OF POSIX HEADER. MAKE SURE
		TO INCORPORATE THAT INTO THE NORMALIZED HEADERS OF CrxOs SUCH AS THE NORMALIZED HEADERS
		INCLUDE THE ONES IN THIS LIBRARY.
		
TODO: CONFIGURATION
	- REMOVE CONFIGURATION MACROS NOT USED ANYWHERE, AND AUTOMATE WHAT CAN BE AUTOMOTATED FROM THE
			REST.
	- ADD CONFIGURATION MACROS FOR "EXTERNAL" CONFIGURATION, WHICH ARE FORBIDDEN IN MY STANDARD.
			MEANING THOSE CONFIGURATION MEANT TO BE SET USING THE COMPILER OPTIONS. THESE
			INCLUDE: PTW32_STATIC_LIB, PTW32_CLEANUP_SEH, PTW32_CLEANUP_CXX, PTW32_CLEANUP_C
		
TODO (DONE):
	- THIS IS ABOUT THE Sleep(0) PROBLEM IN OLDER WINDOWS. SEE ABOVE.
	- YOU MIGHT WANT TO CHANGE Sleep(0) IN ptw32_callUserDestroyRoutines() TO USE Sleep(1)
			LIKE V2.8.0 DID. YOU MIGHT ALSO WANT TO SIMPLY USE sched_yield().
	- YOU MIGHT WANT TO USE Sleep(1) IN sched_yield() INSTEAD OF Sleep(0). BOTH V2.8.0
			AND V3.0.0 USED Sleep(0). REMEMBER THAT YOU NEED TO KEEP IN MIND THAT IF
			THERE ARE LIKELY THREADS OF EQUAL PRIORITY, Sleep(0) CONTINUES TO WORK
			ON OLDER WINDOWS. THE SEMAPHRORE IMPLEMENTATION USES sched_yield(), AND HENCE
			THERE IT IS MORE LIKELY THERE TO HAVE MORE THREADS OF EQUAL PRIORITY WAITING.
			IF YOU USE Sleep(0), PTHREAD sched_yield() WILL GIVE ONLY THREADS OF EQUAL
			PRIORITY A CHANCE TO RUN ON OLDER SYSTEMS. OTHERWISE, IT IS UNCLEAR WHICH THREADS
			ARE CONSIDERED "READY TO RUN" IN THE NEWER WINDOWS. {UPDATE: SEE NOTES ABOVE ABOUT
			ptw32_callUserDestroyRoutines.c).
			IF YOU USE Sleep(0), PTHREAD sched_yield() WILL GIVE ALL THREADS A CHANCE TO RUN
			SUBJECT TO WINDOWS SCHEDULING.
			UNDER LINUX, sched_yield() WILL GIVE ONLY THREADS OF HIGHER OR EQUAL PRIORITY A
			CHANCE TO RUN, OTHERWISE, IT RETURNS IMMEDIATELY. {SOURCE:
			https://stackoverflow.com/questions/3727420/significance-of-sleep0}
			HENCE, IF YOU WISH THE BEHAVIOR TO BE, "DO NOT ALLOW THREADS OF LOWER PRIORITY
			TO RUN INSTEAD OF ME IF I YIELD BUT HIGHER PRIORITY THREADS MAY RUN", ACROSS ALL 
			SYSTEM, STICK TO Sleep(0) ACROSS ALL SYSTEMS. OTHERWISE, IF YOU WISH THE BEHAVIOR TO BE, 
			"YOU MUST ABSOLUTELY YIELD IF YOU CAN", STICK TO Sleep(1) ACROSS ALL SYSTEMS.
	- YOU MIGHT ALSO WANT TO PROVIDE YOUR OWN FUNCTION FOR CALLING "YIELDING" AND
			BASED ON THE WINDOWS VERSION, CALL Sleep(1) OR Sleep(0).
			IT IS Windows Server 2003 AND UP THAT SIMPLY GIVE THE REMAINDER OF THEIR TIME TO 
			ANY OTHER THREAD, IF ZERO IS PASSED.
			YOU MIGHT ALSO WANT TO ALLOW THE FUNCTION TO ACCEPT A BOOLEAN INDICATING WHETHER
			OTHER THREADS OF EQUAL PRIORTY LIKELY EXIST.
	- NOTE THAT Sleep() IS IN POSIX, BUT UNSURE SINCE WHEN. Sleep(0) APPEARS TO SIMPLY
			RETURN IN LINUX, BUT I READ OTHER ANSWERS SUGGESTING REACHDEDULING HAPPENS, BUT 
			PERHAPS FOR OTHER SYSTEMS LIKE BSD. IN ANY CASE, THE FUNCTION IS AVAILABLE ON POSIX,
			BUT DOUBLE CHECK SINCE WHEN, AND KNOW THAT SLeep(0) IS UNRELIABLE IF YOU WANT 
			BEHAVIOR LIKE JAVASCRIPT'S, OR ATLEAST, CLOSER TO WINDOWS.
	- UPDATE:
		- ORIGINALY: MARKED AS DONE, AND USED Sleep(0) ON EVERYTHING.
		- IT HAS BECOME CLEAR, BASED ON THE WORK ON SCHEDULING UNDER PHASE 4 OF THIS PROJECT,
				THAT Sleep(1) IS NECESSARY IF THE WAIT IS FOR ANOTHER THREAD TO FINISH DOING A
				TASK THAT THE SLEEP IS FOR, OTHERWISE YOU WOULD MIGHT HAVE AN EFFECTIVE DEADLOCK
				BECAUSE OF THE WAY WINDOWS SCHEDULING WORKS. THIS CAN HAPPEN IF THE THREAD WAITING
				USING Sleep() NEEDS SOMETHING DONE FROM A LOWER PRIORITY THREAD, AND THE WINDOWS
				PRIORITY BOOSTING MECHANISM NEVER BOOSTS THAT THREAD, OR NEVER BOOSTS IT ENOUGH
				TO RUN BEFORE THE THREAD WAITING. ON OLDER SYSTEMS, THE BOOST WOULD HAVE TO PLACE
				IT ON EXACTLY THE SAME PRIORITY LEVEL.
				THEREFORE IF sched_yield() IS MEANT FOR INDIRECTLY WAITING FOR SOMETHING TO HAPPEN,
				IS MUST USE Sleep(1). IF, IT IS SIMPLY GIVING OTHER THREADS A CHANCE TO USE THE
				PROCESSOR, Sleep(0) IS VALID. 
				ANY Sleep() WITH THE AIM OF WAITING FOR SOMETHING TO BE DONE BY ANOTHER THREAD MUST
				BE Sleep(1).
		- EXTRA INFO
			- INSTEAD OF Sleep() FOR YIELDING, THERE IS ALSO SwitchToThread() WHICH WAS NOT 
					RECOMMENDED, AND I DID NOT READ WHY BECAUSE SwitchToThread() DOES NOT EXIST ON
					WIN9X.
			- Sleep() FOR VALUE 1 OR HIGHER, HAS A RESOLUTION 10-15 MS. IN OTHER WORDS, Sleep(1)
					COULD MAKE THE THREAD SLEEP FOR 10-15MS. THERE IS THE FUNCTION 
					timeBeginPeriod() WHICH CAN INCREASE THE RESOLUTION DOWN TO 1MS AND IT AFFECTS
					A NUMBER OF PREIODIC TIMER FUNCTIONS INCLUDING Sleep(), BUT IT ALSO AFFECTS THE
					ENTIRE SYSTEM, AND NOT ONLY THE PROCESS. SOMEWHERE IN WINDOWS 10, THIS CHANGED
					TO AFFECT ONLY THE PROCESS WHERE THIS WAS CALLED. STARTING WINDOWS 11, THIS
					COULD GET IGNORED IF THE PROCESS THAT CALLED IT IS A WINDOW OWNING PROCESS,
					AND IS CURRENTLY IN THE BACK GROUND, OR MINIMIZED, OR SIMILAR. IN OTHER WORDS, 
					WINDOWS THROTTLES WINDOW OWNING PROCESS IF THE WINDOW IS NOT "ACTIVE", SIMILAR 
					TO SOME OF MY WORK IN JAVASCRIPT. AVOID timeBeginPeriod() IN ANY CASE BECAUSE
					IT CAUSES THE OS, AND IN TURN, THE CPU TO WORK MORE.
					NOTE THAT ON WIN9X, Sleep(1) CAN SLEEP UP TO 55MS. ON LATER WINDOWS IT IS
					REDUCED TO 10-15 MS. THEREFORE IT IS VERY IMPORTANT TO CALL timeBeginPeriod(15)
					FOR CONSISTANCY ACROSS ALL SYSTEMS.
			- timeBeginPeriod() AFFECTS:
				- GetTickCount(): SOME SOURCES SUGGEST THIS IS NOT AFFECTED.
				- Sleep()
				- timeGetTime()
				- CreateTimerQueueTimer(): DOES NOT EXIST ON WIN9X. DO NOT USE.
			- Accurate time:	
				- timeGetTime:
					- MORE ACCURATE ON WIN9X BY DEFAULT (1MS). ON LATER WINDOWS(15MS), 
							timeBeginPeriod(1) WOULD BE REQUIRED.
				- QueryPerformanceCounter: FOR TIMESTAMPS, NOT CLOCK TIME. MIGHT BE PROBLOMATIC
						IF EXECUTED ON TWO DIFFERENT CORES, AND THEN THE DIFFERENCE IS TAKEN.
						THERE IS MUCH VARIATION ON THE ACCURACY OF THIS BASED ON FIRMWARE, HARDWARE,
						AND WINDOWS OS. HOWEVER, IT REMAINS THE MOST ACCURATE IT SEEMS, BUT BE AWARE
						OF THE MULTI CORE ISSUE MENTIONED EARLIER THAT HAPPENS ON SOME SYSTEMS.
						FOR MULTI CORE, EXPECT AN ERROR EQUAL TO 1/QueryPerformanceFrequency().
						HENCE IF YOU ARE WITHIN THAT RANGE WHEN YOU COMPARE TWO READINGS, ASSUME
						THE DIFFERENCE IS WRONG. MICROSOFT SAYS THIS DOES NOT APPLY IF READINGS
						ARE FROM SAME THREAD, BUT IGNORE THAT.
						DEPENDING ON THE SYSTEM HARDWARE, BIOS, AND OTHERS, AND THE FALLBACK WINDOWS
						USES, THIS FUNCTION CAN END UP SLOW, OR SLOWER, UNSURE. CERTAINLY, DO NOT
						USE IN A TIGHT LOOP.
				- GetSystemTimePreciseAsFileTime: FOR CLOCK TIME. WINDOWS 8 AND UP I THINK.
						 DO NOT USE.
			- ACCURATE SLEEP:
				- Sleep(): BUT YOU NEED TO CALL timeBeginPeriod() FIRST.
				- timeSetEvent(): VERY ACCURATE, AND CAN BE USED TO PULSE PERIODICALLY.
				- WRITE YOUR OWN THREAD AND USE PulseEvent() ONCE EVERY DESIRED TIME SLICE. I THINK
						THIS IS HOW timeSetEvent() WORKS. 
						YOU COULD ALSO INTERLEAVE PulseEvent() CALLS WITH OTHER CODE.
						EITHER WAY, YOU WOULD USE QueryPerformanceCounter() TO CHECK IF IT IS TIME
						TO CALL PulseEvent().
				- CreateTimerQueueTimer(): SAME PROBLEM AS SLEEP BUT CAN BE PERIODIC. DOES NOT EXIST
						ON WIN9X. DO NOT USE.
				- ON OTHER SYSTEMS THERE IS nanosleep() WHICH HAS BEEN AROUND FOR A LONG TIME,
						BUT IT COULD BE INACCURATE. ON LINUX, THERE IS THE FUNCTION select()
						THAT IS MORE ACCURATE.
		- DONE: 
			- CODE IN ptw32_callUserDestroyRoutines.c AND ptw32_MCS_lock.c CHANGED TO USE Sleep(1)
			- sched_yield() DEFINED TO MEAN A YIELD FOR THE PURPOSE OF GIVING OTHER THREADS A
					CHANCE TO RUN, AND NOT A WAIT FOR THE PURPOSE OF LETTING ANOTHER THREAD FINISH 
					WORK THAT THIS THREAD NEEDS TO PROCEED.
		

TODO: HAVE ptw32_processTerminate() CLEAN UP EVERYTHING IT IS MISSING. THIS FUNCTION MUST FOLLOW
		THE STANDARD, THE FORMAL WORK, ON HOW DLLS MAY WORK.
		THIS FUNCTION CURRENTLY DOES NOT REMOVE THE KEY PTHREAD ADDS TO WINDOWS TLS FROM WHAT I
		CAN TELL.
	

NOTE:
	pthread_exit FOR SOME REASON CHOOSES TO PASS THE POINTER PASSED TO IT AS A VALUE TO 
			_endthreadex
	YOU WAN TO DEFINE THE MACRO RETAIN_WSALASTERROR TO RETAIN SAME BEHAVIOR AS WITH V2.8.0
	THE POSIX ROBUSTNESS FEATURE THAT WAS ADDED AFTER V2.8.0 MIGHT BE PLAYING A ROLE IN THE
			COMPLEXITY OF THE CHANGE IN THE MUTEX POSIX IMPLEMENTATION, MEANING pthread_mutex_*.c
	TEMPORARIYL RESOLVED THE APPARANT ISSUE OF errno.h INCLUSION BEING REMOVED AFTER V2.8.0,
			WHICH MAY OR MAY NOT BE AN ISSUE. RESOLVED BY ADDING AN APPROPRIATE DEFINITION IN 
			config.h TO TRIGGER INCLUSION OF THE FILE IN _ptw32.h AND EVENTUALLY 
			pthread.h. HENCE, FOR NOW, IF pthread.h IS INCLUDED, YOU CAN ASSUME errno.h IS INCLUDED
	THERE IS A BUG WHEN CLEAN UP CODE HAS TO RUN, SUCH AS pthread_cleanup_push, THAT EXISTS IN
			ROUGHLY VISUAL STUDIO 7 AND BEFORE WHICH HAPPENS WHEN THE COMPILER DECIDES TO INLINE
			FUNCTIONS, AND WHEN THE COMPILED CODE IS NOT USING MICROSOFT'S C++ STRUCTED EXCEPTION 
			HANDLING. IN V2.8.0, IF THE COMPILER IS VISUAL STUDIO, THEN THE PRAGAMA inline_depth
			IS USED TO FIX THE ISSUE. HOWEVER, IN V2.9.1 ATLEAST, THE WAS CHANGED TO ONLY
			BE ENABLED IF THE COMPILER IS HIGHER THAN VISUAL STUDIO 6 AND LOWER THAN VISUAL STUDIO
			8.
			DECIDED TO BRING BACK THE OLD BEHAVIOR OF USING THE FIX FOR VISUAL STUDIO 6 ALSO.
			(NOTE THAT I WAS WRONG, AND PTW32_CONFIG_MSVC7 DID IMPLY VISUAL STUDIO 6 ALSO. SEE BELOW
			HOWEVER, IT DID NOT IMPLY EITHER OF VC7 AND VC6 IF WINCE IS TARGETTED)
			HENCE WHENVER THERE IS
					#if defined (PTW32_CONFIG_MSVC7)
						#pragma inline_depth(...)
					#endif
			I REPLACE WITH
					#if (defined (PTW32_CONFIG_MSVC7) || defined(PTW32_CONFIG_MSVC6))
						#pragma inline_depth(...)
					#endif
			UPDATE: REPLACING WITH (FROM V2.9.1)
					#if defined(_MSC_VER) && _MSC_VER < 1400
						#pragma inline_depth(...)
					#endif
			WITH THIS, THE ABOVE BEHAVIOR IS ALSO ENFORCED IF TARGETTING WINCE.
			NOTE THAT PTW32_CONFIG_MSVC7 DOES IMPLY MSVC6. SEE FILE "_ptw32.h"
	IT APPEARS THAT INDEED VERSIONS HIGHER THAN AT LEAST 2.11.0 DO NOT WORK ON WINDOWS 95. THIS IS
			BECAUSE THE WIN32 FUNCTION InterlockedCompareExchange DOES NOT EXIST ON WINDOWS 95
			BUT THE LIBRARY PROVIDED AN ALTERNATIVE, ptw32_InterlockedCompareExchange. THIS
			IMPLEMENTATION APPEARS TO HAVE BEEN REMOVED FROM THE LATER VERSIONS. SEEK TO BRING
			THIS BACK. THE CODE IN "pthread_win32_attach_detach_np.c" ATTEMPS TO LOAD THE
			FUNCTION DYNAMICALLY, AND IF NOT FOUND, USE ptw32_InterlockedCompareExchange() INSTEAD.
	USEFUL CODE
					#if(_MSC_VER < 1400)
						extern "C" long __cdecl _InterlockedCompareExchange (long volatile *, long, long);
						extern "C" long __cdecl _InterlockedDecrement (long volatile *);
						extern "C" long __cdecl _InterlockedExchange (long volatile *, long);
						extern "C" long __cdecl _InterlockedIncrement (long volatile *);
						extern "C" long __cdecl _InterlockedExchangeAdd(long volatile *, long);

						#pragma intrinsic (_InterlockedCompareExchange)
						#pragma intrinsic (_InterlockedDecrement)
						#pragma intrinsic (_InterlockedExchange)
						#pragma intrinsic (_InterlockedIncrement)
						#pragma intrinsic (_InterlockedExchangeAdd)
					#endif
			CHECK MACRO _M_IX86	PERHAPS USE 
				#if defined(_M_IX86) && !defined(RC_INVOKED) && !defined(MIDL_PASS)
			BEFORE DEFINING THE ABOVE.
			VS6 HAS THE FOLLOWING DEFINITION FOR THE FUNCTION, 
					void* InterlockedCompareExchange(void **, void *, void *);
			AND NOT FOR THE INTRINSIC _InterlockedCompareExchange(). ALSO NOTE THAT THE DEFINITION 
			OF THIS FUNCTION BECAME
					LONG InterlockedCompareExchange(LONG volatile *Destination, LONG ExChange,
							LONG Comperand);
			THE ASSUMPTION IS THAT long AND void* ARE BOTH 32BIT ON A 32BIT SYSTEM. HOWEVER, THE
			EXTRA PROBLEM IS THE volatile SPECIFIER WHICH THE OLD DEFINITION DID NOT HAVE.{SEE
			https://stackoverflow.com/questions/22172885/interlockedcompareexchange-in-windows-98-environment}
			REMEMBER THAT THESE ATOMIC INTRINSICS PROVED UNRELIABLE IN VC6 BASED ON MY TESTS WITH 
			WEIRD BUGS UNDER HIGH OPTIMIZATION AND CERTAIN ARRANGEMENT OF WHAT SHOULD BE UNRELATED 
			CODE.
	pthread_self() IN V3.0.0, UNLIKE V2.8.0, SETS THE RETURN VALUE, self, self.p->state TO
			PThreadStateRunning IF IT SUCCEEDS. NOT EVEN V2.11.0 DOES THAT.
			IN V3.0.0 THIS FUNCITON CAN FAIL IF IT FAILS TO GET THE THREAD AFFINITY, MEANING TO 
			FILL THE cpuset DATA MEMBER OF ptw32_thread_t.
	IN V3.0.0, IF A MUTEX IS OF TYPE "PTHREAD_MUTEX_NORMAL", AND IT IS UNLOCKED WHILE
			NOT BEING LOCKED, pthread_mutex_unlock() NOT LONGER RETURNS EPERM.
			HOWEVER, IT APPEARS THAT PER THE SPECIFICATION BOTH APPROACHES ARE VALID.
	pthread_mutex_destroy() HAS A BUG OF SORT IF CALLED WHILE ELSWHERE SOME ONE IS TRYING
			TO LOCK THE MUTEX. HOWEVER, THIS IS LIKELY A BUG NO MATTER WHAT FUNCTION IS BEING
			CALLED ON THE MUTEX ELSWHERE WHILE pthread_mutex_destroy() IS RUNNING.
			THE STANDARD SUGGESTS THAT AN "EBUSY" ERROR SHOULD BE RETURNED. THIS IS A TODO FOR THE
			FUTURE.
	IN V2.8.0 EPERM WOULD RETURNED ON ATTEMPTING TO UNLOCK A SPIN LOCK THAT WAS NOT LOCKED. THIS
			IS NOT THE CASE IN V3.0.0 WHERE THE FUNCTION SIMPLY SUCCEEDS.
	IF YOU EVER MODIFY THE LIBRARY AND ADD A GLOBAL STATIC MUTEX. PAY CAREFUL ATTENTION TO 
			ptw32_mutex_check_need_init.c (ptw32_mutex_check_need_init()).
			SIMILAR SITUATION WITH ptw32_rwlock_check_need_init.c(ptw32_rwlock_check_need_init()),
			ptw32_cond_check_need_init.c(ptw32_cond_check_need_init()),
			ptw32_spinlock_check_need_init.c(ptw32_spinlock_check_need_init())
			
			THESE ARE ESSENTIALY FOR THE PLACEHOLDER VALUES USED TO STATICALLY INITIALIZE
			THE PERTAINING TYPES, LIKE THE SPIN LOCK, OR THE CONDITION VARIABLE, OR THE MUTEX,
			AND THEN ACTUAL INITIALIZATION HAPPENS ARE RUN TIME LATER. THE CODE SEEMS TO THINK
			THAT THIS IS NOT NEEDED FOR THE MCS LOCK, AND IT LOOKS CORRECT, AND NEHTIER IS IT
			NEEDED FOR WINDOWS CRITICAL SECTION LOCKS. HENCE IN 2.8.0 CRITICAL SECTIONS WERE
			USED TO FINALLY INITIALIZE THOSE GLOBAL STATICS, WHILE MCS LOCKS ARE USED IN
			LATER VERSIONS. 
	A NOTE FROM ELSWEHERE:
			The atomic function, InterlockedIncrement(), while exists under windows 95, it does not
			return the correct value, but only a value with the correct sign. This is because of needed
			to support older cpus that do not have the XADD instruction. However, Visual Studio 6 also
			has undocumented instrinsic, such as _InterlockedIncrement(), and these seem to use XADD based
			on my own tests on Visual Studio 6 and looking at the generated assembly. However, I remain
			unsure as to why other projects have not used the intrinsic instead. Firefox, for example,
			used to use its own lock based function, and then later switched to using the intrinsic, and
			where that was reported it was said that _InterlockedIncrement would return the wrong value under
			windows 95. I am unsure if this is simply a confusion between the instrinsic and the function.
			{SOURCE: https://bugzilla.mozilla.org/attachment.cgi?id=219147&action=diff}. Note that I looked
			at v3.6.2 soource code.
			STL Port has useful assembly code if you wish to implement these intrinsics, at 
			"stlport\HEADER\stl\config\_watcom.h".
			There exists instrinsic, _disable and _enable, to turn of interrupts on the microsoft compilers, but 
			I doubt we can use them because they would likely require elevated access, driver level access,
			kernel mode access.  Windows 98, when it detected old hardware, did the same for implementing 
			InterlockedIncrement(), but otherwise used XADD.
			Remember the intrinsics are specific to the Microsoft compiler.
			When wanting to use the intrinsics on microsoft compilers, one has to use 
							#pragma instrinsic(INTRINSIC_NAME)
			to let the compiler know that this is meant to be an intrinsics, which efficetively means
			an inlined function. However, the compiler might decide to replace the call with an actual
			function call, which for _InterlockedIncrement() I am assuming would mean calling
			InterlockedIncrement() which has the wrong behavior under windows 95. If my understanding
			is correct, perhaps this is why people choose to make their own assembly implementations
			instead of using the intrinsic when on Visual Studio.
			why people choose 
			WARNING: Further work showed that these intrinsics break under high optimization level under VC6,
					giving wrong results. The function calls, however, remain working correctly as far as what
					their definition is.

THE LIBRARY PROVIDES 'POSIX' THREADS BY WRAPPING THE UNDERLYING WIN32 THREADS. HOWEVER THE LIBRARY
		ALSO TRIES TO WORK WIN32 THREADS THAT ARE NOT WRAPPED BY IMPLICITLY WRAPPING THEM. 
		pthread_self() IS WHAT CAN POTENTIALLY DO THE IMPLICIT WRAPPING. WHETHER, BY IMPLICIT
		WRAPPING, OR EXPLICIT WRAPPING, THE LIBRARY USES A TLS KEY, ptw32_selfThreadKey, TO MARK
		THE THREAD. HENCE, WHEN THE LIBRARY IS TRYING TO AVOID CREATING AN IMPLICIT WRAPPER, IT
		CHECKS ptw32_selfThreadKey INSTEAD OF CALLING pthread_self().
		WHETHER IMPLICIT, OR EXPLICIT, WRAPPING THE LIBRARY COULD HAVE TLS STORAGE SET FOR THE
		THREAD, AND HENCE CALLING USER DESTRUCT ROUTINES WOULD BE REQUIRED. IF THE LIBRARY IS
		RUNNING AS A DLL, THE DLL ENSURES THAT pthread_win32_thread_detach_np() IS CALLED FOR
		EACH THREAD, AND THAT FUNCTION EVENTUALLY TAKES CARE OF CALLING USER DESTROY ROUTINES.
		HOWEVER, IF INSTEAD USING THE EXE SECTION MECHANISM INTRODUCED AFTER V2.8.0,
		pthread_win32_thread_detach_np() IS ONLY GUARANTEED TO BE CALLED FOR THE MAIN THREAD, WHICH
		IS WHY THE LIBRARY IN ptw32_threadStart.c CONTINUES TO WARN THE USER TO CALL
		pthread_exit() IN THAT CASE, OR IN V2.8.0, TO CALL pthread_win32_thread_detach_np(), WHEN
		THE WIN32 THREAD IS AN IMPLICITLY WRAPPED ONE.
		
		THIS IS VERY IMPORTANT WHEN IT COMES TO THE MECHANISM THAT SHALL BE INTRODUCED TO REPLACE
		THE ABOVE TWO, WHERE USER CODE MUST MANUALLY CALL SOME INITIALIZE AND FINALIZE FUNCTIONS
		FOR THE POSIX LIBRARY. THIS MEANS THAT USER CODE WOULD BECOME RESPONSIBLE OF ALWAYS
		CALLING pthread_exit() FOR MANUALLY WRAPPED WIN32 THREADS. THE CORRECT APPROACH, HOWEVER,
		IS TO NOT ALLOW MANUAL WRAPPING WITH THIS APPROACH, AND EVEN BETTER, WITH ALL
		APPROACHES. (TODO(DONE))
		
TODO(DONE): GO OVER http://www.flounder.com/badprogram.htm
	IT SEEMS THAT IF USING longjmp AND setjmp, USING THE register QUALIFIER ON LOCAL VARIABLES
			IS NOT GOOD.
	ANY USE OF Sleep() IS SUSPECT. THERE IS ONE SUCH INSTANCE IN THE CODE, IN 
			"ptw32_callUserDestroyRoutines.c"

THREAD HANDLE CLEANUP:
		QUOTE:
				"Either pthread_join(3) or pthread_detach() should be called for
				each thread that an application creates, so that system resources
				for the thread can be released.  (But note that the resources of
				any threads for which one of these actions has not been done will
				be freed when the process terminates.)"{SOURCE: 
				https://man7.org/linux/man-pages/man3/pthread_detach.3.html}
		THE ABOVE IS IMPORTANT IN UNDERSTANDING WHEN THE LIBRARY CLOSES THE WINDOWS THREAD HANDLE
		WHHEN THREAD ENDS WITH _endthreadex() INSTEAD OF _endthread(). ALSO NOTE FROM THE ABOVE
		THAT EVEN IF THE THREAD IS CANCELLED OR EXITED, IT STILL NEEDS TO BE JOINED OR DETACHED.
		
		IF THE THREAD IS JOINED, PTHREAD TAKES CARE OF CLEAN UP NATUARLY BY EVENTUALLY CALLING
		pthread_detach() IN pthread_join(). pthread_detach() SEES THE THREAD IS NOT ACTUALLY
		DETACHABLE AND CALLS ptw32_threadDestroy() INSTEAD. 
		[NOTE: NOTE THAT IN THE CASE pthread_join(), THE FUNCTION ESSENTIALLY WAITS ON THE THREAD
		TO EXIT IT SEEMS, WHICH GUARANTEES THE ENTIRETY OF ptw32_threadStart() TO FINISH RUNNING.
		IT SEEMS THAT FUNCTIONS LIKE WaitForSingleObject(), IF PASSED A THREAD HANDLE, ESSENTIALY
		WAIT FOR THE THREAD TO EXIT. THIS IS IMPORTANT TO KEEP IN MIND IF YOU ARE WONDERING WHEN 
		THREAD LOCAL STORAGE STUFF IS CLEANED UP, MEANING, WHEN pthread_win32_thread_detach_np() IS 
		CALLED]
		
		IF THE LIBRARY IS RUNNING AS A DLL, THEN IF THE THREAD IS NOT JOINED, MEANING THE THREAD IS 
		CREATED DEATCHED, OR THE USER FORGOT TO JOIN IT, THE LIBRARY RELIES ON 
		pthread_win32_thread_detach_np() TO CALL ptw32_threadDestroy() IF THE THREAD IS MARKED AS 
		DETACHED, MEANING, "PTHREAD_CREATE_DETACHED". IF THE POSIX THREAD IS AN IMPLICITLY WRAPPED 
		WIN32 THREAD, IT IS GUARANTEED TO BE MARKED "PTHREAD_CREATE_DETACHED". 
		THIS IS DONE IN pthread_self(). REMEMBER, pthread_win32_thread_detach_np(), WOULD BE CALLED
		AUTOMATICALLY IN DLL MAIN. IF THE THREAD IS EXITED, MEANING USING, pthread_exit(),
		THE LIBRARY ALSO RELIES ON pthread_win32_thread_detach_np() TO CALL ptw32_threadDestroy().
		
		IF THE LIBRARY IS NOT RUNNING AS A DLL, THEN IF THE THREAD IS NOT JOINED, THEN WHEN IT ENDS,
		ptw32_threadStart() CALLS pthread_win32_thread_detach_np() WHICH CALLS
		ptw32_threadDestroy(). INCIDENTALLY, IN THIS CASE, CloseHandle() GETS CALLED BEFORE 
		_endthreadex() BUT THAT IS SAFE. IF THE POSIX THREAD IS A WIN32 IMPLICITLY WRAPPED WIN32 
		THREAD, THEN THE USER MUST CALL pthread_exit() INSIDE HIS WIN32 THREAD, WHICH CALLS 
		ptw32_throw() WHICH REALIZES THAT THIS IS AN IMPLICITLY WRAPPED WIN32 THREAD, MEANING THERE 
		IS NO ptw32_threadStart() WAITING AT THE TOP OF THE CALL STACK, AND PROCEEDS TO CALL 
		pthread_win32_thread_detach_np() ITSELF, WHICH AGAIN, CALLS ptw32_threadDestroy() IF THE 
		THREAD IS MARKED AS DETACHED, AND IT WILL BE BECAUSE IMPLICIT WRAPPED WIN32 THREADS ALWAYS 
		ARE, BY THE FUNCTION pthread_self().
		
		ptw32_threadDestroy() WILL CloseHandle() TO CLEAN UP THE WINDOWS THREAD HANDLES.
		
		THIS CLEAN UP MATTER IS NOT TO BE CONFUSED WITH THE CLEANUP REQUIRED RELATED TO THREAD
		LOCAL STORAGE. THIS IS SIMPLY ABOUT CLEANING THE WINDOWS THREAD HANDLES. HOWEVER,
		DO NOTE THAT A CALL TO pthread_win32_thread_detach_np() MEANS CLEANUP OF THREAD LOCAL
		STORAGE.
		
		CANCELABLES:
			pthread_join()
		
		DLL:
			{THREAD NOT DETACHED}
			pthread_join()<>->pthread_detach()-->ptw32_threadDestroy()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
			{THREAD DETACHED}
			pthread_detach()->ptw32_threadDestroy()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
															->ptw32_threadDestroy()
			{NATURAL FINISH, THREAD DETACHED, EXPLICIT THREAD}
			ptw32_threadStart()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
															->ptw32_threadDestroy()
			{NATURAL FINISH, THREAD NOT DETACHED}
			ptw32_threadStart()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
			{NATURAL FINISH, THREAD DETACHED, IMPLICIT THREAD}
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
			{CANCEL SELF, ASYNCHRONOUS, THREAD DETACHED, EXPLICIT THREAD}
			pthread_cancel()->ptw32_throw()->ptw32_threadStart()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
															->ptw32_threadDestroy()
			{CANCEL SELF, ASYNCHRONOUS, THREAD DETACHED, IMPLICIT THREAD}
			pthread_cancel()->ptw32_throw()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
															->ptw32_threadDestroy()
			{CANCEL SELF, ASYNCHRONOUS, THREAD NOT DETACHED}
			pthread_cancel()->ptw32_throw()->ptw32_threadStart()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
			{CANCEL NOT SELF, ASYNCHRONOUS, THREAD DETACHED, EXPLICIT THREAD}
			pthread_cancel()->ptw32_throw()->ptw32_threadStart()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
															->ptw32_threadDestroy()
			{CANCEL NOT SELF, ASYNCHRONOUS, THREAD DETACHED, IMPLICIT THREAD}
			pthread_cancel()->ptw32_throw()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
															->ptw32_threadDestroy()
			{CANCEL NOT SELF, ASYNCHRONOUS, THREAD NOT DETACHED}
			pthread_cancel()->ptw32_throw()->ptw32_threadStart()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
			{SYNCHRONOUS}
			pthread_cancel()->SET_EVENT_cancelEvent
			{DETACHED, EXPLICIT THREAD}
			pthread_exit()->ptw32_throw()->ptw32_threadStart()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
															->ptw32_threadDestroy()
			{DETACHED, IMPLICIT THREAD}
			pthread_exit()->ptw32_throw()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast
															->ptw32_threadDestroy()
			{NOT DETACHED}
			pthread_exit()->ptw32_throw()->ptw32_threadStart()
				{DLLMAIN}->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
														    ->SET_STATE_PThreadStateLast

		NOTICE AGAIN FROM THE ABOVE, HOW THE LIBRARY DOES NOT CLEAN THE WINDOWS HANDELS IF YOU
		CANCEL THE THREAD, OR EXIT IT, AND IT IS NOT DETACHED. IN OTHER WORDS, IT IS WAITING ON
		ANOTHER THREAD TO JOIN THE THREAD.															
		
		REMEMBER: IF THREAD IS IMPLICIT, IT CAN NOT BE DETACHED.
		REMEMBER: IF ptw32_threadStart() IS INVOLVED, THE THREAD CAN NOT BE IMPLICIT.
		REMEMBER: ULTIMATELY, BOTH ptw32_threadDestroy() AND ptw32_callUserDestroyRoutines()
						NEED TO BE CALLED FOR THE FULL CLEAN UP.

		NOT DLL:
			{THREAD NOT DETACHED}
			pthread_join()<>->pthread_detach()->ptw32_threadDestroy()
			{THREAD DETACHED}
			pthread_detach()->ptw32_threadDestroy()
			{NATURAL FINISH, THREAD DETACHED}
			ptw32_threadStart()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																  ->SET_STATE_PThreadStateLast
																  ->ptw32_threadDestroy()
			{NATURAL FINISH, THREAD NOT DETACHED}
			ptw32_threadStart()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																  ->SET_STATE_PThreadStateLast
			{NATURAL FINISH, THREAD DETACHED, IMPLICIT THREAD}
				<<PROBLEM: NOTHING HAPPENS HERE AT ALL.>>
			{CANCEL SELF, ASYNCHRONOUS, THREAD DETACHED, EXPLICIT THREAD}
			pthread_cancel()->ptw32_throw()->ptw32_threadStart()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																								   ->SET_STATE_PThreadStateLast
																								   ->ptw32_threadDestroy()
			{CANCEL SELF, ASYNCHRONOUS, THREAD DETACHED, IMPLICIT THREAD}
			pthread_cancel()->ptw32_throw()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																			  ->SET_STATE_PThreadStateLast
																			  ->ptw32_threadDestroy()
			{CANCEL SELF, ASYNCHRONOUS, THREAD NOT DETACHED}
			pthread_cancel()->ptw32_throw()->ptw32_threadStart()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																								   ->SET_STATE_PThreadStateLast
			{CANCEL NOT SELF, ASYNCHRONOUS, THREAD DETACHED, EXPLICIT THREAD}
			pthread_cancel()->ptw32_throw()->ptw32_threadStart()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																								   ->SET_STATE_PThreadStateLast
																								   ->ptw32_threadDestroy()
			{CANCEL NOT SELF, ASYNCHRONOUS, THREAD DETACHED, IMPLICIT THREAD}
			pthread_cancel()->ptw32_throw()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																			  ->SET_STATE_PThreadStateLast
																			  ->ptw32_threadDestroy()
			{CANCEL NOT SELF, ASYNCHRONOUS, THREAD NOT DETACHED}
			pthread_cancel()->ptw32_throw()->ptw32_threadStart()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																								   ->SET_STATE_PThreadStateLast
			{SYNCHRONOUS}
			pthread_cancel()->SET_EVENT_cancelEvent
			{DETACHED, EXPLICIT THREAD}
			pthread_exit()->ptw32_throw()->ptw32_threadStart()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																								 ->SET_STATE_PThreadStateLast
																								 ->ptw32_threadDestroy()
			{DETACHED, IMPLICIT THREAD}
			pthread_exit()->ptw32_throw()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																		    ->SET_STATE_PThreadStateLast
																			->ptw32_threadDestroy()
			{NOT DETACHED}
			pthread_exit()->ptw32_throw()->ptw32_threadStart()->pthread_win32_thread_detach_np()-->ptw32_callUserDestroyRoutines()
																								 ->SET_STATE_PThreadStateLast
		
			
		
		
		
		
		WITH DLL:
						CALLED JOIN				CALLED DEATCH			CALLED NEITHER

		EXPLICIT		KEYS CLEANUP: BY		KEYS CLEANUP: BY		KEYS CLEANUP: BY
						DLLMAIN	EFFECTVIELY.	DLLMAIN	EFFECTVIELY.	DLLMAIN	EFFECTVIELY.
						HANDLES CLEANUP: BY		HANDLES CLEANUP: BY		HANDLES CLEANUP: BY
						pthread_join() 	 		DLLMAIN EFFICTIVELY.	DLLMAIN	EFFECTVIELY.
						EFFICTIVELY.
		IMPLICIT			NA					KEYS CLEANUP: BY		KEYS CLEANUP: BY
												DLLMAIN	EFFECTVIELY.	DLLMAIN	EFFECTVIELY.
												HANDLES CLEANUP: BY		HANDLES CLEANUP: BY
												DLLMAIN EFFICTIVELY.	DLLMAIN EFFICTIVELY.
												
		WITHOUT DLL:
						CALLED JOIN				CALLED DEATCH			CALLED NEITHER

		EXPLICIT		KEYS CLEANUP: BY		KEYS CLEANUP: BY		KEYS CLEANUP: BY
						ptw32_threadStart()		ptw32_threadStart()		ptw32_threadStart()
						EFFECTVIELY.			EFFECTVIELY.			EFFECTVIELY.
						HANDLES CLEANUP: BY		HANDLES CLEANUP: BY		HANDLES CLEANUP: BY
						pthread_join() 	 		ptw32_threadStart()		ptw32_threadStart()
						EFFICTIVELY.			EFFECTVIELY.			EFFECTVIELY.
		IMPLICIT			NA					KEYS CLEANUP: BY		KEYS CLEANUP: BY
												USER CALLING			USER CALLING
												pthread_exit()			pthread_exit()
												EFFECTVIELY.			EFFECTVIELY.
												HANDLES CLEANUP: BY		HANDLES CLEANUP: BY
												USER CALLING			USER CALLING
												pthread_exit()			pthread_exit()
												EFFICTIVELY.			EFFICTIVELY.
		
		REMEMBER THAT pthread_detach() DETACHES THE THREAD, NOT ENDS IT. IT JUST THAT THE CODE
		ENDS IT WHEN pthread_detach() WAS CALLED BY pthread_join(). THIS IS LIKELY A FORMAL ERROR
		STRICTLY SPEAKING, AND pthread_detach() WOULD HAVE TO BE SPLIT INTO TWO FUNCTIONS, BUT
		KEEPINGS THIS AS THEY ARE FOR NOW. HOWEVER, NOTE THAT THE FUNCTION ALSO HAS TO CONSIDER,
		IT SEEMS, pthread_detach() BEING CALLED LATE, WHEN THE THREAD IS FINISHED, AND IN THIS
		CASE WOULD ALSO HAVE TO END THE THREAD. HOWEVER, I AM UNSURE IF pthread_detach() CAN
		BE CALLED THIS LATE BY ANY OTHER THAN pthread_join().

THE LIBRARY DOES NOT IMPLEMENT THE OFFICIAL PTHREAD_PROCESS_SHARED MODE FOR PTHREAD MUTEX
			
TODO(DONE): 
	RE EXAMINE pthread_win32_attach_detach_np.c WHEN IT COMES TO IT CALLING FREELIBRARY, AND
			MAKE SURE THE FUNCTIONS THERE ARE NOT CALLED FROM DLL MAIN. ENSURE THAT THE LIBRARY
			FOLLOWS THE STANDARD WHEN TO COMES TO HOW DLLS SHOULD BE DEALT WITH.	
	CHECK WHERE THE MACRO "PTW32_STATIC_LIB" IS BEING USED IN THE CODE. IDEALLY YOU WANT TO GET
			RID OF DLL MAIN, AND HAVE CODE EXPLICITLY LOADING INITIALIZATION FUNCTIONS AS DEFINED
			IN MY WORK.
			
			THE EVENT HANDLERS OF IMPORTANCE ARE 
					pthread_win32_process_attach_np()
					pthread_win32_process_detach_np()
					pthread_win32_thread_attach_np()
					pthread_win32_thread_detach_np()
			IF DLL, THE FUNCTIONS ARE CALLED IN DLL MAIN. 
			IF NOT DLL, MICROSOT BINARY SECTIONS ARE USED. HOWEVER, THE FUNCTION 
					pthread_win32_thread_detach_np() IS ALSO CALLED IN ptw32_throw()
					AND ptw32_threadStart()
					
			NOTE THAT THE LIBRARY USES setjmp/long, OR STRUCTURES EXCEPTION HANDLING, OR
			C++ EXCEPTIONS, TO CANCEL A RUNNING THREAD THAT IS CREATED BY THE LIBRARY.
			THERE ARE FEW PROBLEMS:
				- setjmp/longjmp CAN NOT BE USED WITH C++ CODE SAFELY.  ('VC' BUILDS)
					- IF PTHREADS "THROWS", BECAUSE C CODE CALLED A PTHREAD FUNCTION THAT DOES SO,
							THIS WORKS.
					- IF PTHREADS "THROWS", BECAUSE C++ CODE CALLED A PTHREAD FUNCTION THAT DOES SO,
							THIS WILL NOT WORK BECAUSE C++ OWN CLEAN UP CODE WILL NOT BE CALLED,
							SUCH AS DESTRUCTORS.
					- C USER CODE CAN NOT THROW.
					- IF C++ USER CODE THROWS AN EXCEPTION, THE THREAD FAILS, BUT IT IS UNCLEAR
							HOW. IN GENERAL,
						- THE C++ STACK UNWINDING, IF USING EXTERNAL TABLES KEEPING TRACK OF FRAMES,
								RUNS OUT OF TABLE ENTRY ONCE IT HITS THE TOP LEVEL C FUNCTION
								AND POSSIBLY CALLS std::terminate()
						- THE C++ STACK UNWINDING, IF USING INLINE JUMPING LIKE setjmp()/longjmp()
								SKIPS C CODE IN BETWEEN, OR POSSIBLY SKIPS THE VERY TOP C FUNCTION
								INTO A POINT SET BY THE OS ITSELF.
						- IF USING WINDOWS SEH, WELL WINDOWS SEH PROPOGATES OVER C CODE AS WELL,
								EVEN IF THE C CODE DOES NOT UNDERSTAND ITS CONTENT. 
								NOTE THAT C++ EXCEPTIONS ON WINDOWS ARE IMPLEMENTED USING
								WINDOWS STRUCTURED EXCEPTION HANDLING (SEH).
					- WHETHER PTHREAD IS USED AS A DLL OR NOT, THE ABOVE ANALYSIS IS NOT AFFECTED.
				- C++ EXCEPTIONS ARE NOT GENERIC. FURTHER MORE, THEY ARE CURRENTLY MINGLED IN .c 
						FILES WHICH IS A VIOLATION IN MY STANDRD. ('VCE' BUILDS)
					- IF PTHREADS "THROWS", BECAUSE C CODE CALLED A PTHREAD FUNCTION THAT DOES SO,
							THIS WORKS.
					- IF PTHREADS "THROWS", BECAUSE C++ CODE CALLED A PTHREAD FUNCTION THAT DOES SO,
							THIS WORKS. REMEMBER THAT THE TOP LEVEL FUNCTION IN THIS CASE ENDS
							UP BEING A C++ FUNCTION. REMEMBER THE TOP LEVEL FUNCTION IS PROVIDED BY
							PTHREAD.
					- IF C++ USER CODE THROWS AN EXCEPTION, THIS SHOULD WORK, BUT THERE ARE BUGS
							REPORTED IN PRACTICE ON SOME COMPILERS AT LEST. IT APPEARS THAT
							THESE REPORTED BUGS ARE WHEN PTHREAD IS A DLL.
					- NOTE THAT V3.0.0 APPEARS TO BE COMPILED WITH "STANDARD C++ EXCEPTION". THE 
							MAKE FILE USES THE /EHs FLAG.
							NOTE, HOWEVER, THAT V3.0.0 APPEARS TO FAVOR 
							"STRUCTURED AND STANDARD C++ EXCEPTION" FOR VS6. THE MAKE FILE HAS A 
							COMMENT TO THAT EFFECT, BUT THE USER IS EXPECTED TO CHANGE THE MAKE TO 
							USE /EHa INSTEAD OF /EHs. I SUSPECT THAT THIS RESULT DOES NOT APPLY
							IF PTHREAD WAS NOT COMPILED AS A DLL.
							THE ABOVE IS FOR BOTH DLL AND NON DLL BUILDS.
							NOTE THAT THE "BUGS" FILE REPORTS VCE BUILDS TO BE UNREIABLE, PERHAPS
							FOR OLDER VISUAL STUDIO VERSION.
					- NOTE THAT BOTH V2.8.0 APPEARS TO BE COMPILED WITH "DEFAULT EXCEPTION HANDLING".
							THE MAKE FILE DOES NOT INDICATE ANY OF THE (/EHsc, /EHs, /EHa) FLAGS.
							THE ABOVE IS FOR BOTH DLL AND NON DLL BUILDS.
					- IF PTHREAD IS COMPILED AS DLL, THE GENERAL RULE IS THAT C++ EXCEPTIONS
							ACROSS DLL BOUNDRIES ARE NOT SAFE.
							WHEN PTHREAD ITSELF IS "THROWING", THE EXCEPTION HAS TO PROPOGATE
							OUTSIDE THE PTHREAD DLL EVEN IF LATER TO BE CAUGHT BY PTHREAD.
							WHEN USER CODE THROWS, THAT GOES FROM USER CODE INTO THE PTHREAD DLL,
							AND THEREFORE SAME PROBLEM.
					- IT WOULD APPEAR THAT TO USE THIS OPTION, PTHREAD SHOULD NOT BE A DLL, AND
							PERHAPS COMPILATION SHOULD USE "STRUCTURED AND STANDARD C++ EXCEPTION"
							INSTEAD OF "STANDARD C++ EXCEPTION".
					- NOTE THAT WHEN DEVELOPING ON ANOTHER PLATFORM, LIKE LINUX, I HAVE SEEN 
							EVIDENCE WHERE PTHREAD CANCELATION IS ALSO IMPLEMENTED USING C++ 
							EXCEPTIONS. SEE
							{https://stackoverflow.com/questions/44781206/pthread-cancel-on-linux-leads-to-exception-coredump-why}
				- STRUCTURED EXCEPTIONS ('VSE' BUILDS)
					- IF PTHREADS "THROWS", BECAUSE C CODE CALLED A PTHREAD FUNCTION THAT DOES SO,
							THIS WORKS.
					- IF PTHREADS "THROWS", BECAUSE C++ CODE CALLED A PTHREAD FUNCTION THE BEHAVIOR
							DEPENDS ON HOW THE PTHREAD C++ CODE WAS COMPILED. USING MICROSOFT 
							COMPILER AS AN EXAMPLE:
						- DEFAULT EXCEPTION HANDLING(NO /EHsc, /EHs, or /EHa ARE SPECIFIED): IN 
								THIS CASE C++ EXCEPTION ARE ESSENTIALY NOT IMPLEMENTED AND SIMPLY 
								USING SEH.
								
								IN THIS CASE, THIS WILL CAUSE A MEMORY LEAK. 
								IN THIS CASE, THERE IS A DANGER OF C++ CODE CATCHING EXCEPTION 
								THROWN BY PTHREAD TO CANCEL THE THREAD, AND NOT RETHROWING.
								IN THIS CASE, THE SEH CODE AT THE TOP LEVEL FUNCTION COULD PERHAPS 
								BE MADE TO CALL ::std::terminate IF IT SEES AN EXCEPTION IT WAS
								NOT EXPECTING. BUT THIS MIGHT BE UNSAFE IN THIS CASE.
						- STANDARD C++ EXCEPTION(/EHsc OR /EHs): IN THIS CASE, C++ EXCEPTIONS
								ARE IMPLEMENTED. BUT REMEMBER C++ EXCEPTIONS DO USE SEH BEHIND THE
								SCENE, IT IS JUST THAT THE C++ catch IS BLIND TO THE SEH EXCEPTION.
								
								THIS IS EFFECTIVELY LIKE THE FIRST CASE, BECAUSE THE TOP LEVEL 
								FUNCTION IS USING SEH, AND THEREFORE IT DOES NOT UNDERSTAND WHAT TO 
								DO WITH THE C++ STUFF IN THE EXCEPTION, AND HENCE CAUSE A MEMORY 
								LEAK. FURTHEMER MORE, NEITHER DO THE LOWER LEVELS BECAUSE C++ IS
								BLIND TO SEH IN THIS CASE. HOWEVER, IF INSTEAD CLEANUP HAPPENS
								STEP BY STEP AS GO UP, RATHER THAN UNTIL WE REACH THE TOP LEVEL,
								THEN THIS DOES NOT CAUSE A MEMORY LEAK I THINK, EXCEPT AT THE LEVEL
								WHERE THE SEH EXCEPTION HAPPENED, WHICH IN OUT CASE IT JUST C CODE,
								NOT C++, THEREFORE NO PROBLEM.
								IN THIS CASE, THERE IS NO DANGER OF C++ CATCHING THE EXCEPTION MEANT
								FOR THE PTHREAD CODE, AND NOT RESENDING IT.
								IN THIS CASE, THE SEH CODE AT THE TOP LEVEL FUNCTION COULD PERHAPS 
								BE MADE TO CALL ::std::terminate IF IT SEES AN EXCEPTION IT WAS
								NOT EXPECTING. THIS MIGHT BE UNSAFE IN THIS CASE.
						- STRUCTURED AND STANDARD C++ EXCEPTION(/EHa): IN THIS CASE, C++ EXCEPTIONS
								ARE IMPLEMENTED, AND THE C++ catch IS AWARE OF BOTH C++ EXCEPTIONS
								AND SEH.
								
								IN THIS CASE, THIS IS LIKELY SAFE, EVEN THOUGH THE TOP LEVEL 
								FUNCTION IS USING SEH. THE ASSUMPTION IS THAT LOWER LEVEL FUNCTION 
								WOULD CLEAN UP THEIR C++ STUFF BECAUSE GETTING BACK TO THE TOP LEVEL 
								FUNCTION IF THIS ASSUMPTION IS NOT TRUE, THEN THIS WILL ALSO CAUSE 
								A MEMORY LEAK.
								IN THIS CASE, THERE IS A DANGER OF C++ CODE CATCHING EXCEPTION 
								THROWN BY PTHREAD TO CANCEL THE THREAD, AND NOT RETHROWING.
								IN THIS CASE, THE SEH CODE AT THE TOP LEVEL FUNCTION COULD PERHAPS 
								BE MADE TO CALL ::std::terminate IF IT SEES AN EXCEPTION IT WAS
								NOT EXPECTING. IF THE ASSUMPTION ABOVE IS TRUE ABOUT NO MEMORY
								LEAKS, THIS SHOULD BE SAFE IN THIS CASE, OTHERWISE, THIS MIGHT BE
								UNSAFE.
					- IF C++ USER CODE THROWS AN EXCEPTION, THE BEHAVIOR DEPENDS ON HOW THE PTHREAD 
							C++ CODE WAS COMPILED, AND HOW THE USER C++ USER CODE WAS COMPILED.
							THERE IS NO MEMORY LEAK IF BOTH PTHREAD AND USER CODE ARE COMPILED WITH
							"STRUCTURED AND STANDARD C++ EXCEPTION".
							THERE MIGHT BE NO MEMORY LEAK IF PTHREAD IS COMPILED WITH
							"STRUCTURED AND STANDARD C++ EXCEPTION" AND USER CODE IS COMPILED WITH
							"STANDARD C++ EXCEPTION".
							OTHERWISE, THEY WILL BE MEMORY LEAKS IF I AM NOT WRONG.
							
							HOWEVER, ASSUMING CLEANUP HAPPENS AS WE GO UP, THEN PERHAPS MEMORY LEAK
							ONLY HAPPENS IF USER COMPILED WITH "DEFAULT EXCEPTION HANDLING",
							REGARDLESS OF HOW PTHREAD WAS COMPILED.
					- NOTE THAT BOTH V2.8.0 AND V3.0.0 APPEARS TO BE COMPILED WITH
							"DEFAULT EXCEPTION HANDLING". THE MAKE FILE DOES NOT INDICATE ANY OF 
							THE (/EHsc, /EHs, /EHa) FLAGS.
					- IN TERMS OF NOTES IN THE CODE, STRUCTURED EXCEPTIONS ('VSE' BUILDS) APPEAR TO 
							BE THE RELIABLE OPTION.
					- I THINK THIS OPTION MIGHT BE A RELIABLE OPTION, AND PTHREAD SHOULD BE
							COMPILED WITH "DEFAULT EXCEPTION HANDLING", WHILE USER C++ CODE SHOULD
							NEVER BE COMPILED WITH "DEFAULT EXCEPTION HANDLING" UNLESS IT IS NOT
							USING C++ EXCEPTIONS.
							THIS SHOULD HOLD TRUE FOR BOTH DLL AND NON DLL COMPILATION OF PTHREAD.
							
			OVERALL, IF APPEARS THAT USING STRUCTURED EXCEPTION HANDLING IS THE BEST MODE FOR
					PTHREAD DLL, AND IT SHOULD BE COMPILED USING "DEFAULT EXCEPTION HANDLING".
					HOWEVER TESTS SHOULD BE DONE TO ENSURE THAT THIS DOES NOT CAUSE LEAKS OF
					C++ OBJECTS. 
					IF TESTS FAIL, THEN THE NEXT BEST THING SHOULD BE setjmp/longjmp, AND C++ CODE 
					MUST BE AWARE THAT IT MUST CLEAN UP ITSELF BEFORE CANCELING. FURTHERMORE,
					IMMEDIATE CANCELATION BEHAVIOR WOULD NO LONGER BE ALLOWED. SEE pthread_cancel() 
					AND THE "PTHREAD_CANCEL_ASYNCHRONOUS" OPTION.
					
					UPDATE: IT APPEARS THAT MICROSOFT C++ COMPILERS USE SEH FOR C++ EXCEPTIONS, BUT
					OTHER COMPILERS DO NOT NECESSARILY. GCC DOES NOT.
					
					IN THE END, HOWEVER, IS SEEMS SEH MIGHT STILL BE BETTER THAN setjmp/longjmp
					WITH setjmp/longjmp, IF THE USER CODE HAPPENS TO BE COMPILED IN VISUAL STUDIO
					OR NOT, THE MAIN THREAD FUNCTION THAT IS INJECTED BY PTHREAD CAN NOT SEE THE
					C++ EXCEPTIONS. HOWEVER, WITH SEH, IF THE USER CODE IS COMPILED IS VISUAL 
					STUDIO, BASED ON MY UNDERSTANDING, THE SAID TOP LEVEL FUNCTION SHOULD SEE THE 
					C++ EXCEPTIONS, AND SIMPLY RECOGNIZE IT BY BEING AN UNRECOGNIZABLE EXCEPTION, 
					AND IT CAN THEN PROCEED TO CALL ::std::terminate. NOTE THAT THIS IS SOMETHING
					I STILL NEED ADD SUPPORT FOR. SUPPORT NEEDS TO BE ADDED IN A WAY WHERE
					THE USER CODE IS EXPECTED TO PASS A POINTER TO ::std::terminate IF IT HAPPENS
					TO BE C++, OTHERWISE, NULL.(TODO(DONE))
					
					NOTE THAT THE POINT IS HAVING A SINGLE DLL TO WORK FOR ALL COMPILERS, RATHER
					THAN HAVING A DIFFERENT DLL FOR EACH COMPILER.
					
					WITH THE ABOVE, IT CAN BE CONCLUDED THAT IF PTHREAD IS TO BE USED WITH C++:
						- C++ CODE MUST NEVER THROW AN EXCEPTION
						- C++ MUST CLEAN UP BEFORE REQUESTING, OR CAUSING, A THREAD TO BE CANCELLED.
						- IF THREADS ARE(SEE pthread_setcanceltype() AND pthread_setcancelstate()):
							- CANCELABLE: CODE MUST AVOID ALL CONSTRUCTS, SUCH AS sem_timedwait, 
									THAT SET A CANCELATION POINT IF THE THREAD CREATED ALLOWING 
									THAT, IF IT NEVER ALLOWS IMMEDIATE CANCELATION. USING 
									(PTHREAD_CANCEL_DEFERRED) INSTEAD OF 
									(PTHREAD_CANCEL_ASYNCHRONOUS).
							- IMMEDIATELY CANCELABLE: CODE MUST pthread_cleanup_push() AND
									pthread_cleanup_pop() IN EVERY FUNCTION TO CLEAN UP VALUE ON THE
									C++ STACK. I AM UNSURE IF THIS WOULD ACTUALLY WORK OR CAUSE
									CORRUPTION. THIS IS LIKELY TO WORK IF USING THE setjmp/long
									SCHEME, BUT MAY OR NOT WORK IF USING SEH DEPENDING ON THE
									COMPILER I THINK.
									FOR THIS TO WORK, WE NEED THE COMPILER NOT TO BE INVOLVED, BUT
									THE VISUAL STUDIO COMPILER, IS LIKELY TO BE INVOLVED AND
									CLEAN AFTER ITSELF.
							- FORBID A THREAD FROM BEING CANCELABLE. (PTHREAD_CANCEL_DISABLE)
					REMEMBER ALSO THAT C CODE MUST BE ALLOWED TO BE CALLED BY C++.
					
					ANOTHER APPROACH: IF YOU MANAGE TO HAVE USER CODE CALL THE FOUR EVENT HANDLERS 
					ABOVE, PROVIDE A FACILITY TO PASS POINTER TO TWO FUNCTIONS, ONE THAT DOES THE 
					WORK OF THROWING A C++ EXCEPTION, OR SEH EXCEPTION, OR CALLING longjmp IN 
					ptw32_throw(), AND THE OTHER CALLING THE USER FUNCTION INSIDE 
					ptw32_threadStart(), AND CAPTURING WHATEVR THE FIRST FUNCTION DID, SUCH AS A 
					THROWN EXCEPTION, OR A THROWN SEH EXCEPTION, OR THE setjmp POINT, AND RETURNING 
					A CODE TO ptw32_threadStart() TO TELL IT WHAT HAPPENED. A THIRD FUNCTION MIGHT 
					BE REQUIRED TO TERMINATE BASED ON THE RETURN CODE. IN C++ APPLICATIONS, FOR 
					EXAMPLE, THE FIRST FUNCTION MIGHT THROW ONE OF TWO EXCEPTIONS, THE SECOND 
					FUNCTION WOULD CATCH A C++ EXCEPTION, AND THE THIRD FUNCTION WOULD CALL
					::std::terminate AS REQUIRED BY THE C++ STANDARD WHEN THE THREAD DID NOT
					TERMINATE NORMALLY, WHICH BE INDICATED BY THE RETURN CODE OF THE SECOND
					FUNCTION.
					NOTE HOWEVER, YOU SHALL ALSO NEED SUCH A FUNCTIONALITY FOR CALLING USER
					"DESTROY ROUTINES" FUNCTIONS IN "ptw32_callUserDestroyRoutines.c". 
					NOTE THAT IN ptw32_threadStart(), IF THE IMPLEMENTATION USES SEH FOR THREAD
					CANCELATION AND THE SEH EXCEPTION CAUGHT IS NOT RECOGNIZED, MEANING IT IS
					NOT FROM PTHREADS, ptw32_threadStart() CALLS ptw32_callUserDestroyRoutines(),
					WHICH HAPPENS IN AN EXCEPTION FILTER FOR __except AND THEN ALLOWS THE SEH 
					EXCEPTION TO PROPOGATE FURTHER UP. THIS MEANS THAT UNLIKE THE OTHER TWO CASES, 
					pthread_win32_process_attach_np() IS NEVER CALLED. IF USING THE C++ EXCEPTION
					IMPLEMENTATION AND C++ EXCEPTION IS NOT RECOGNIZED, MEANING IT IS NOT FROM
					PTHREADS, pthread_win32_process_attach_np() IS CALLED, AND ITSELF
					CALLS ptw32_callUserDestroyRoutines(), THEN ptw32_threadStart() TERMINATES
					THE PROGRAM. IF USING setjmp/longjmp, pthread_win32_process_attach_np()
					IS CALLED, AND JUMP CODE IS NOT RECOGNIZED, MEANING THAT IT DID NOT ORIGINATE
					FROM PTHREADS, THE PROGRAM IS NOT TERMINATED. THE SEH IMPLEMENTATION GREATLY
					COMPLICATES HOW THE THREE USER FUNCTIONS TO BE DEFINED ABOVE WOULD WORK.
					WHAT THIS MEANS IS THAT IF AN SEH EXCEPTION IS THROWN:
						- IF USING SEH FOR CANCELATION:
							- IF SEH THROWN FROM USER CODE, THE EXCEPTION IS ALLOWED TO PROPOGATE
									UP BUT AFTER ATTEMPTING TO CALL USER DESTROY ROUTINES BY
									DIRECTLY CALLING ptw32_callUserDestroyRoutines(), RATHER THAN
									CALLING pthread_win32_process_attach_np(). 
									pthread_win32_process_attach_np() WILL NOT RUN.
							- IF SEH EXCEPTION IS THROWN FROM USER DESTROY ROUTINES, THE EXCEPTION
									IS ALLOWED TO PROPOGATE UP.
									pthread_win32_process_attach_np() WILL NOT RUN.
						- IF USING C++ EXCEPTIONS FOR CANCELATION:
							- IF SEH THROWN FROM USER CODE, THE EXCEPTION MIGHT BE ALLOWED TO 
									PROPOGATE UP DEPENDING ON HOW PTHREAD WAS COMPILED GIVING THE 
									COMPILER OPTIONS MENTIONED ABOVE.
									IF THE OPTION CHOSEN IS SUCH AS C++ catch() DOES NOT CATCH
									THE SEH EXCEPTION, THE EXCEPTION WILL PROPOGATE UP, AND
									pthread_win32_process_attach_np() WILL NOT RUN.
									OTHERWISE, pthread_win32_process_attach_np() WILL RUN.
							- IF SEH EXCEPTION IS THROWN FROM USER DESTROY ROUTINES, THE EXCEPTION
									MIGHT BE ALLOWED TO PROPOGATE UP DEPENDING ON HOW PTHREAD
									WAS COMPILED GIVING THE COMPILER OPTIONS MENTIONED ABOVE.
									IF THE OPTION CHOSEN IS SUCH AS C++ catch() DOES NOT CATCH
									THE SEH EXCEPTION, THE EXCEPTION WILL PROPOGATE UP, AND THE
									REST OF pthread_win32_process_attach_np() WILL NOT RUN. THIS
									AMOUNTS TO CALLING ptw32_callUserDestroyRoutines().
									OTHERWISE, THE REST OF pthread_win32_process_attach_np() WILL 
									RUN AND THEN ::std::terminate() WILL BE CALLED.
									HENCE USING PTHREAD LIBRARY WITH C++ catch ALLOWED TO CATCH
									SEH EXCEPTION IS BAD BECAUSE OF HOW IT CHANGING PTHREAD'S
									BEHAVIOR.
						- IF USING setjmp/longjmp FOR CANCELATION:
							- IF SEH THROWN FROM USER CODE, THE EXCEPTION IS ALLOWED TO PROPOGATE
									UP.
									pthread_win32_process_attach_np() WILL NOT RUN.
							- IF SEH EXCEPTION IS THROWN FROM USER DESTROY ROUTINES, THE EXCEPTION
									IS ALLOWED TO PROPOGATE UP.
									THE REST OF pthread_win32_process_attach_np() WILL NOT RUN.
					CURRENT DESIGN: 
						- FOR THE FOUR, NOT THREE USER FUNCTIONS:
							- void doThrow(const pUserData, pCode): THE USER FUNCTION IS GIVEN A CODE, AND 
									HE IS TO TRANSLATED TO WHATEVER HE WANTS, THEN SOME HOW THROW IT, 
									SUCH AS USING throw, OR __throw, OR longjmp.
									THIS FUNCTION IS NOT ALLOWED TO FAIL.
									THIS FUNCTION IS OPTIONAL TO PROVIDE BY THE USER. HOWEVER, IF 
									doRun() BELOW IS PROVIDED, IT MUST BE PROVIDED, OTHERWISE, IT 
									MUST NOT BE PROVIDED.
									IF NOT PROVIDED, PTHREAD WILL USE longjmp APPROACH, OR POSSIBLY
									THE SEH APPROACH, SO __throw, BUT REMEMBER THAT THIS IS NOT
									AVAILABLE ON ALL COMPILERS.
							- Code doRun(pUserData, pFunc_run, pFunc_callUserRoutines): THE USER 
									FUNCTION IS ALLOWED TO FILL THE USER DATA, pUserData, WITH WHATEVER 
									IT WANTS AND IS THEN TO CALL pFunc_run INSIDE try OR __try, OR 
									CALLING setjmp() FIRST. THE FUNCTION MAY, OR MAY NOT DECIDE TO CALL
									pFunc_callUserRoutines. PTHREAD WILL ESSENTIALLY PASS 
									ptw32_callUserDestroyRoutines() AS pFunc_callUserRoutines(). IF
									THE FUNCTION CALLS pFunc_callUserRoutines, THE FUNCTION MUST
									SOMEHOW TERMINATE SUCH AS BY THROWING A SEH EXCEPTION OR EXITING
									THE PROGRAM. IF THE FUNCTION RETURNS IT MUST HAVE NOT CALLED
									pFunc_callUserRoutines.
									THIS FUNCTION IS OPTIONAL TO PROVIDE BY THE USER. HOWEVER, IF 
									doThrow() ABOVE IS PROVIDED, IT MUST BE PROVIDED, OTHERWISE, IT
									MUST NOT BE PROVIDED.
									IF NOT PROVIDED, PTHREAD WILL USE setjmp APPROACH, OR POSSIBLE
									THE SEH APPROACH, SO __try, BUT REMEMBER THAT THIS IS NOT
									AVAILABLE ON ALL COMPILERS.
							- void terminateIfNecessary(): THE USER FUNCTION IS ALLOWED TO TERMINATE
									THE PROGRAM IF IT WISHES. THIS IS MEANT FOR CALLING
									::std::terminate(). THE USER CODE COULD ALSO JUST RETURN AND DO
									NOTHING. IF THIS HAPPENS, PTHREAD WILL CONTINUE RUNNING.
									THIS FUNCTION IS OPTIONAL TO PROVIDE BY THE USER.
									IF NOT PROVIDED, PTHREAD WILL TRY TO MIMICK IT'S USUAL BEHAVIOR
									IF doRun() IS NOT PROVIDED (WHICH DEPENDS ON WHETHER IT USES
									setjmp/longjmp OR SEH), OTHERWISE IT WILL SIMPLY CONTINUE
									EXECUTION.
							- Code callUserDestroyRoutine(pFunc_destroy): THE USER FUNCTION IS TO 
									CALL pFunc_destroy().
									THIS FUNCTION SHOULD BE PROVIDED, BUT IT IS STILL OPTIONAL.
									IF NOT PROVIDED, PTHREAD WILL PROVIDE ITS OWN IMPLEMENTATION
									THAT DOES NO TRAPPING OF C++ EXCEPTIONS. NOTE THAT PER
									THE STANDARD, MEANING MY FORMAL WORK, SUCH FUNCTIONS, ASSUMING
									THAT THEY ARE FORMALLY DESTRUCT FUNCTIONS, MAY NOT FAIL.
						- NON OF THE USER FUNCTIONS MAY THROW A C++ EXCEPTION. THEY NEED TO 
								CATCH ALL C++ EXCEPTIONS INTERNALLY. HOWEVER, THEY MAY THROW SEH 
								EXCEPTIONS. HENCE, UNDER MICROSOFT COMPILERS, IT IS LIKELY SAFE THAT 
								THEY THROW A C++ EXCEPTION.
						- THE "CODE", MEANING TYPE Code, ABOVE IS:
							- CANCEL: THIS MAY BE PASSED TO USER CODE AND RETURNED FROM USER CODE.
									AMOUNTS TO PTHREAD CANCEL CODES.
							- EXIT: THIS MAY BE PASSED TO USER CODE AND RETURNED FROM USER CODE.
									AMOUNTS TO PTHREAD EXIT CODES.
							- CALL_TERMINATE: THIS MAY BE RETURNED FROM USER CODE. IF RETURNED,
									PTHREAD IS BEING TOLD THAT THE CODE IS NOT RECOGNIZED, AND THAT
									IT IS TO CALL THE USER'S terminateIfNecessary().
							- UKNOWN: THIS MAY BE RETURNED FROM USER CODE. IF RETURNED, PTHREAD
									IS BEING TOLD THAT THE CODE IS NOT RECOGNIZED, AND THAT IT IS
									TO CONTINUE RUNNING AS NORMAL.
						- A CONFIGURATION OPTION WILL BE ADDED TO CHOOSE WHETHER THE FOUR EVENT
								PTHREAD FUNCTIONS, SUCH AS pthread_win32_process_attach_np(), ARE
								TO BE CALLED AUTOMATICALLY, OR THE USER IS TO CALL TWO NEW PROVIDED
								FUNCTIONS, ONE AT START OF MAIN, AND ONE AT END OF MAIN. IN OTHER
								WORDS, MANUAL SETUP.
								IF THE OPTION IS FOR THE MANUAL SETUP, THEN THE ABOVE FOUR FUNCTIONS,
								SUCH AS THE HYPOTHETICAL doRun(), WILL BE PROVIDED BY THE USER WHEN
								CALLING THE FUNCTION TO CALL AT THE BEGGINING OF MAIN.
								IF THE OPTION IS FOR THE MANUAL SETUP, IMPLICIT WRAPPING OF WIN32
								THREADS INTO PTHREAD THREADS WILL NOT BE ALLOWED, EXCEPT FOR THE
								MAIN THREAD. THIS CONCERNS THE FUNCTION pthread_self(). IF YOU 
								IMPLEMENT A NORMALIZING LAYER, YOU CAN KEEP IMPLICIT WRAPPING SUCH 
								AS USER CODE MUST EPLICITLY ASK FOR IMPLICIT WRAPPER. FOR EXAMPLE, 
								IF THE NORMALIZING FUNCTION IS crx_pthread_self(), YOU WOULD PROVIDE 
								ANOTHER, crx_pthread_self2() TO ALLOW IMPLICIT WRAPPING. UNDER NON 
								WINDOW SYSTEMS, BOTH FUNCTIONS WOULD SIMPLY CALL crx_pthread_self(). 
								REMEMBER THAT IF IMPLICITLY WRAPPED, USER CODE MUST CALL 
								pthread_exit() INSIDE THEIR IMPLICITLY WRAPPED THREAD. WHEN IT 
								COMES TO MAIN, THE FUNCTION THAT THE USER HAS TO CALL AT THE END
								OF MAIN WILL CALL pthread_exit() ASSUMING THAT IT IS INSIDE
								MAIN, WHICH AS MENTIONED ABOVE, WOULD BE THE ONLY ONE ALLOWED AN
								IMPLICIT THREAD.
									
			NOTE THAT IN setjmp/longjmp IMPLEMENTATION, THE FUNCTION ptw32_throw() IS RESPONSIBLE
					TO CALL THE CLEAN UP ROUTINES, MEANING THOSE FUNCTION THAT SHOULD BE CALLED
					IF THERE IS AN ERROR. RELEVANT ARE THE pthread_cleanup_push AND 
					pthread_cleanup_pop IN pthread.h. INVESTIGATION HAS SHOWN THAT INDEED
					THE MECHANISM IS THERE TO CANCEL THREADS AT LEAST.
	THINGS TO SEARCH FOR IN CODE, CASE SENSITIVELY AND INCOMPLETE WORDS, TO IMPLEMENT DESIGN:
		__PTW32_CLEANUP_
		__cplusplus
		pthread_cleanup_push
		pthread_cleanup_pop
	DONE:
		- THE ABOVE DESIGN WORK IS NO LONGER FULLY CORRECT. SEE CODE FOR ACTUAL DESIGN.
		- UNABLE TO FULLY GET RID OF DLLMAIN AND SIMILAR MECHANISMS YET. THESE ARE CURRENTLY
				REQUIRED FOR THE FINALIZATION PART.
	
					
TODO: WHEN TO COMES TO FINALLY USING THIS LIBRARY TO SOLVE THE GLOBAL VARIABLE ISSUE, YOU NEED TO
		CONSIDER THE SCENARIO WHERE A CRXED LIBRARY IS USED IN DIFFERENT DLLS OR LIBS. IN NORMAL
		CODE, MEANING INFORMAL CODE THAT USES GLOBAL VARIABLES, SUCH SITUATIONS LEAD TO MULTIPLE
		COPIES OF THE GLOBAL VARIABLES. HOWEVER, WITH A SIMPLE DESIGN OF A CENTRAL GLOBAL
		REPOSITORY WHERE EACH LIBRARY HAS ITS OWN UNIQUE KEY TO ACCESS ITS GLOBAL STORAGE, THIS
		CAN NO LONGER HAPPENS. WHERE MULTIPLE COPIES OF THE SAME LIBRARY MIGHT EACH HAVE THEIR
		OWN COPY OF THEIR GLOBAL VARIABLE, WITH THE APPROACH MENTIONED APPROACH, THEY WOULD ALL
		HAVE ONE COPY. THAT CAN BE SURPRISING. FOR EXAMPLE, IF THE LIBRARY EXISTS IN TWO DIFFERENT
		DLLS, A VALID BINARY PER MY STANDARD, WE DO NOT EXPECT THEM TO SHARE ANY GLOBALS. HOWEVER,
		IF THE LIBRARY EXISTS IN TWO DIFFERENT LIBS(.lib), WHICH ARE NOT VALID BINARIES, DO WE
		EXPECT THE LIBRARIES TO EACH HAVE THEIR OWN GLOBALS? I DO NOT KNOW BECAUSE OF THE ILL
		DEFINED NATURE OF LIBS. UNDER NORMAL CIRCUMSTANCE, EACH LIB WILL NOT HAVE ITS OWN COPY
		OF THE GLOBAL VARIABLE. IT IS ONLY EACH DLL OR EXE. HOWEVER THIS DOES NOT APPLY FOR DLLS
		UNDER LINUX(.so), NOR UNDER MACOS(.dylib), WHICH BEHAVE IN THIS CASE LIKE LIB. IN ANY CASE, 
		A NEW FORMAL CONFIGURATOIN MACRO SHALL NEED TO BE PROVIDED TO CRXED LIBRARIES THAT IS A 
		RANDOM STRING. THE CRXED LIBRARY THAT WISHES TO USE GLOBAL VARIABLES WILL FORM ITS FINAL KEY 
		FROM ITS NAME PLUS THE RANDOM STRING, PLUS ANY EXTRA THE LIBRARY WISHES TO HAVE AND IN 
		PARTICULAR A VERSION NUMBER. NOTE THAT A LIBRARY MAY CHOOSE TO IGNORE THE RANDOM STRING 
		DEPENDING ON HOW IT IS DESIGNED.
	
		
THE FOLLOWING DID NOT EXISTS IN V2.8.0
	- pthread_attr_getaffinity_np.c
	- pthread_attr_setaffinity_np.c
	- pthread_setaffinity.c
	- sched_setaffinity.c
	
V2.8.0 HAD A CHECK FOR _MAC IN need_errno.h. LATER VERSIONS REMOVED IT. I THINK THIS WAS FOR WHEN
WINDOWS WORKED ON POWER PC. I BROUGHT THE CHECK BACK.

TODO: ERROR
	- V2.8.0 HAS A FALLBACK FOR WHEN "errno.h" IS NOT AVAILABLE, AND SEEMS TO THINK THAT WHEN
		THAT IS THE CASE _errno() IS NOT AVAILABLE. V3.0.0 MAKES AN EXTRA ACOMODATION FOR
		WHEN THE TOOL autoconfig IS USED. HOWEVER, IT SEEMS THAT THERE ARE SCENARIOS
		WHEN "errno.h" IS NOT AVAILABLE, BUT _errno() IS. THIS HAPPENS ON WINDOWS CE. PERHAPS
		OLDER VERSIONS.
	- (DONE) V2.8.0 FALL BACK FOR _errno() MAKES USE OF ptErrno ON THE THREAD STRUCTURE, WHILE V3.0.0
			USES exitStatus. exitStatus IS USED BY THE LIBRARY TO COMMUNICATE ITS OWN THINGS,
			WHILE _errno() CAN BE USED BY USERS TO READ AND WRITE THE ERROR WHICH COULD AFFECT
			exitStatus IF THAT IS WHAT THEY ARE WRITING TO.
			
			DONE: BROUGHT BACK THE OLD BEHAVIOR OF USING ptErrno. SEE errno.c. 
			I WANTED HOWEVER THAT EVERYWHERE THE SYSTEM WRITES TO exitStatus, I ADD CODE TO WRITE TO
			ptErrno, USING THE FOLLOWING DEFINE
					#if defined(NEED_ERRNO)
					#	define PTW32__PRIVATE__MINE__REPLICATE_EXIST_STATUS_TO_USER_ERROR_NO(pPtw32_thread_t_) \
								pPtw32_thread_t_->ptErrno = &((int *)(&(pPtw32_thread_t_->exitStatus)));
					#else
					#	define PTW32__PRIVATE__MINE__REPLICATE_EXIST_STATUS_TO_USER_ERROR_NO(pPtw32_thread_t_)
					#endif
			KEEPING WHAT V3.0.0 WAS APPARANTLY WAS TRYING TO DO. HOWEVER I LATER PROVED THAT NEITHER
			IN V2.8.0 NOR IN V3.0.0 WAS exitStatus EVER COMMUNICATED TO errno. THIS MEANS THAT
			V3.0.0 NEVER USES PTW32_SET_ERRNO(), WHICH USES _set_errno(), TO DUPLICATE THE VALUE
			OF exitStatus TO errno, FOR EXAMPLE. HENCE, I STOPPED WITH MAKING THE FALLBACK OF 
			_errno() USE  ptErrno AS IT USED TO.
			
			NOTE THAT I MADE SURE WHAT WHEN PTW32_GET_ERRNO() AND PTW32_SET_ERRNO() ARE DFINED TO
			USE	_get_errno() AND _set_errno(), THE FALLBACK OF _errno() IS NOT USED. OTHERWISE,
			THIS WOULD BE A BUG. SEE implement.h.
	- MOVE THE FALLBACK OF _errno() AND WHAT IS IN need_errno.h TO A PROPER NORMALIZED HEADER
			UNDER CrxOs PERHAPS. YOU MIGHT WANT THIS TO ALSO INCLUDE A FALLBACK FOR _set_errno()
			AND _get_errno(). AND DO NOT FORGOT THE FALLACK OF THE MACRO errno WHICH IS CURRENTLY
			IN need_errno.h.
			
	
IMPORTANT: USING LIBRARY WITH C++ catch ALLOWED TO CATCH SEH EXCEPTION IS BAD. IT CHANGES
	SOME SUBTLE BEHAVIORS, INCLUDING BREAKING THE CANCELATION MECHANISM IF THE USER CODE HAPPENS
	TO CATCH A SEH EXCEPTION ORIGINATION FROM PTHREAD FROM CANCELATION, AND NOT RETHROWING IT
	ITSELF. ANOTHER REASON HAS TO DO WITH WHAT HAPPENS IF USER DESTROY ROUTINES THROW A SEH
	EXCEPTION.

THIS LIBRARY IS IMPLEMENTED ON THE ASSUMPTION THAT A THREAD CAN NOT PREEMPT ITSELF. IF THIS
		ASSUMPTION DOES NOT HOLD TRUE, THE FOLLOWING ARE PROBLEMS THAT NEED FIXING
	- THE WAY recursive_count IS INCREMENTED IN THE MUTEX TYPE WHEN REENTRY IS ALLOWED.
	- THE WAY recursive_count IS CHECKED IN THE MUTEX TYPE WHEN REENTRY IS ALLOWED. THIS
			ESSENTIALLY DOES NOT CONSIDER THAT THE THREAD ITSELF COULD UNLOCK ITSELF BEFORE
			recursive_count IS IMCREMENTED BEFCAUSE OF RE ENTRY.
	- THE ONLY PLACE I KNOW THIS HAPPENING UNDER WINDOWS IS IF THE THREAD IS WAITING ON A SO
			CALLED EVENT, THE ONE CREATE BY CreateEvent(), MEANING WAITING FOR ANOTHER THREAD
			TO WAKE IT UP. DURING THAT TIME THE THREAD CAN BE REUSED FOR SOMETHING ELSE
			BY THE KERNEL, BY SOMETHING LIKE "KERNEL-MODE APC", MAKING IT EFFECTIVELY THAT THE 
			THREAD PREEMPTED ITSELF. HOWEVER, OTHER THAN THAT, IT DOES NOT APPEARS THAT A THREAD
			IS ALLOWED TO PREEMPTY ITSELF IN WINDOWS.

THERE IS EXPLICIT SUPPORT ON V2.8.0 FOR UWIN, AN AT&T PROJECT FOR UNIX API ON WINDOWS. NOTE THE 
		COMMON:
			#ifndef _UWIN
			#   include <process.h>
			#endif
		
			
TODO: THE LIBRARY IS NOT SAFE TO USE FOR THREADS THAT CREATE WINDOWS.
	- QUOTE:
			"Use caution when calling the wait functions and code that directly or indirectly 
			creates windows. If a thread creates any windows, it must process messages. Message
			broadcasts are sent to all windows in the system. A thread that uses a wait function
			with no time-out interval may cause the system to become deadlocked. Two examples of
			code that indirectly creates windows are DDE and the CoInitialize function. 
			Therefore, if you have a thread that creates windows, use MsgWaitForMultipleObjects
			or MsgWaitForMultipleObjectsEx, rather than WaitForSingleObject."
	- QUOTE:
			"Note MsgWaitForMultipleObjects does not return if there is unread input of
			the specified type in the message queue after the thread has called a
			function to check the queue. This is because functions such as PeekMessage,
			GetMessage, GetQueueStatus, and WaitMessage check the queue and then change
			the state information for the queue so that the input is no longer
			considered new. A subsequent call to MsgWaitForMultipleObjects will not
			return until new input of the specified type arrives. The existing unread
			input (received prior to the last time the thread checked the queue) is
			ignored.
			In a nutshell, unless you're certain of everything that preceded the MWFMO
			call, you need to process any queued messages in a PeekMessage loop before
			dropping into MWFMO"
			{SOURCE https://groups.google.com/g/microsoft.public.vc.mfc/c/fR3k4VQyZBw}
	- PROBLEMATIC FUNCTIONS:
		- Sleep() WITH INIFINITE DELAY. USE MsgWaitForMultipleObjects/MsgWaitForMultipleObjectsEx.
		- WaitForSingleObject() WITH INFINITE TIMEOUT. USE 
				MsgWaitForMultipleObjects/MsgWaitForMultipleObjectsEx.
	- YOU COULD SIMPLY NOT TREAT THE MAIN THREAD AS A THREAD, AND FORBID CREATING WINDOWS IN ANY
			OTHER THREAD BESIDE THE MAIN THREAD. IN OTHER WORDS, THE MAIN THREAD MAY NEVER WAIT
			ON ANY THING, AND IS THE ONLY ONE ALLOWED TO BE SUCH AS IT NEEDS LISTEN TO WINDOW
			MESSAGES.

TODO(DONE): EXAMINE THE MEMBER recursive_count OF THE MUTEX TYPE. YOU MIGHT WANT TO MAKE SURE THAT THIS
		ATOMICALLY INCREMENTED AND DECREMENTED.
	- IT SHOULD BE SAFE ASSUMING THREAD CAN NOT PREMPT ITSELF, BECAUSE THREAD DOES NOT MAKE
			ITSELF WAIT ON ANY EVENT, MEANING THOSE CREATED BY CreateEvent, WHILE DOING THE
			PERTAINING WORK, AND THEREFORE CAN NOT PREMPT ITSELF DURING THE CRITICAL CHECKS
			AND INCREMENTING.
				
TODO(DONE): SERACH FOR PTW32_CONFIG_MSVC7 AND PTW32_CONFIG_MSVC6 MAKING SURE THAT THESE TWO MACROS ARE
		FOR PORTABILITY, NOT FOR BEHAVIOR, THEN GET RID OF THEM WHERE THEY ARE FOR PORTABILITY
		REPLACING WITH PROPER CHECKS, AND DECIDE WHAT TO DO WHEN THEY ARE FOR BEHAVIOR.
			
TODO(DONE): MAKE SURE WINDOWS FUNCTIONS THAT ARE USED ARE FROM THE ASCII FORM. FUNCTIONS THAT NEED
		FIXING:
	- CreateEvent()			=>			CreateEventA()
	- CreateSemaphore()		=>			CreateSemaphoreA()
	- LoadLibrary()			=>			LoadLibraryA()
	- GetSystemDirectory()  =>			GetSystemDirectoryA()
		NOTE THAT THIS FUNCTION DOES NOT EXIST AT ALL IN WINDOWS CE
	- GetProcAddress(): THIS IS A PECULIAR ONE WHERE UNDER WINDOWS NT AND WINDOWS 9X, THIS IS
			ALWAYS ANSII BASED, BUT UNDER WINDOWS CE, THIS IS UNICODE BASED. THERE ALSO NO
			TWO FUNCTIONS TO DIFFERENTIATE BETWEEN THE TWO, GetProcAddressA() AND
			GetProcAddressW(). THIS IS SOMETHING THAT YOU CAN NOT FIX. JUST KEEP IT IN MIND.
			AND IF TRUE, THIS MAKES WINDOWS CE NOT PART OF THE WINDOWS FAMILY AS I DEFINE "FAMILY"
			IN THE STANDARD.
			NOTE THAT IT TURNS OUT BOTH FUNCTIONS, THE 'A' AND THE 'W', HAVE EXCTLY THE SAME NAME
			GetProcAddress(). THERE IS NO GetProcAddressA() NOR GetProcAddressW(). HOWEVER,
			I FOUND CONTRADICTORY INFORMATION ABOUT THIS. {SEE
			https://microsoft.public.win32.programmer.kernel.narkive.com/DEnRK09I/a-bug-in-getprocaddress
			https://stackoverflow.com/questions/18400510/getprocaddressw-errors-when-use-visual-studio2005-and-windows-mobile-sdk-to-debu}
			HOWEVER IT SEEMS THE TWO FUNCTION WITH THS POSTFIX EXIST, BUT ON WINDOWS CE(>= V3.0) ONLY !
			{SOOURCE https://www.boost.org/doc/libs/1_82_0/boost/winapi/get_proc_address.hpp}
	- NOTE THAT FOR WINDOWS CE, ONLY THE 'W' VARIANT OF THE FUNCTIONS EXIST. INSTEAD OF
			CreateSemaphoreA(), FOR EXAMPLE, YOU WOULD HAVE TO USE CreateSemaphoreW()
			BUT IT DOES NOT SEEM TO BE CALLED WITH 'W' AND INSTEAD USE CreateSemaphore()
	- SEARCH FOR NEED_UNICODE_CONSTS TO FIND WHERE TO FIX CODE
			DONE: REMOVED NEED_UNICODE_CONSTS
			
TODO(DONE): TLS SLOTS
	- EXTEND TLS TO ALLOW 1024 SLOTS.
		- DO NOT TRY TO ALLOW MORE SLOTS. REMEMBER, POSIX IS GOING TO BE THE NORMALIZED API, OR AT LEAST
				PORTABLE API, THAT YOU SHALL USE. THEREFORE, SPECIFYING EXTRA STUFF IN THIS LIBRARY IS
				NOT BENEFICIAL. WHEN IT COMES TO THE SLOTS, MOST PLATFORMS SUPPORT AROUND THAT NUMBER OF
				SLOTS.
		- MAKE USE OF THE THREAD PTHREAD OBJECT TO STORE YOUR TLS. A FALLBACK IMPLEMENTATION FOR
				_errno() DOES THAT WITH THE ptErrno DATA MEMEBER, ASSUMING THAT IT SHALL BE
				EFFECTIVELY THREAD LOCAL. SIMPLY ADD A MEMBER TO THE THREAD OBJECT, AND ARRAY, TO 
				HOLD THE EXTRA TLS. THE pthread_key_t TYPE WILL HOLD A VALUE TO INDICATE WHETHER 
				THE KEY THAT IT IS HOLDING IS FOR WINDOWS NATIVE TLS, OR FOR THE TLS EXTENDED
				STORAGE ARRAY ON THE THREAD OBJECT. WITH THIS APPROACH THE EXTENDED TLS STORAGE
				WOULD BE READY BEFORE CREATING THE WINDOWS THREAD. THIS HAPPENS IN 
				pthread_create() WHERE IT EVENTUALLY HAPPENS IN ptw32_new() WHERE YOU HAVE TO ADD
				CODE TO INITIALIZE THE NEW ARRAY DATA MEMEBER.
				YOU SHALL ALSO NEED A GLOBAL TO HELD THE LIST OF REGISTERED KEYS FOR THE EXTENDED
				TLS STORAGE.
	- THE LIBRARY HAS THE IMPLEMENTATION IT HAS FOR TWO REASONS:
		- WINDOWS TLS DOES NOT SUPPORT SETTING A DESTRUCTOR
		- pthread_key_delete() WHICH IS TO DELETE THE KEY FROM ALL RUNNING THREADS! ALSO NOTE THIS
				FUNCTION, PER THE POSIX SPECIFICATION, DOES NOT CALL THE DESTRUTOR.
	- NOTE ABOUT THE KEY:
		- THE KEY IS RECIEVED FROM THE API. THIS IS TRUE EVEN IN THE WINDOWS FUNCTIONS. THIS MEANS
				THAT YOU CAN NOT SIMPLY SET YOUR OWN KEY.
		- THE KEY OBJECT ITSELF, NOT THE KEY VALUE, IS WHAT IDENTIFIES THE KEY. CONTRAST WITH
				STRINGS IN HASHTABLES FOR EXAMPLE. HENCE, WHEN IT COMES TO THE STATIC LOCAL
				FUNCTION VARIABLE, ONE CAN NOT RELY ON THIS MECHANISM TO AVOID GLOBAL VARIABLE,
				BECAUSE YOU WOULD STILL NEED A GLOBAL VARIABLE FOR THE KEY.
		- THERE IS NOT WAY TO SET A VALUE TO THE KEY UNLESS NO VALUE WAS SET. HOWEVER. THIS MIGHT
				NOT BE A BIG PROBLEM BECAUSE THREAD LOCAL STORAGE BY ITS VERY NATURE DOES NOT
				REQUIRE SYNCRHONIZATION. HENCE, WHEN IT COMES TO USING THREAD LOCAL STORAGE FOR
				THE STATIC LOCAL FUNCTION VARIABLE IN C, ONE CAN SAFELY CHECK THE THREAD LOCAL VALUE
				THEN SET IT IF NOT SET.
	- NATIVE NUMBER OF TLS SLOTS
		- NetBSD 256
		- FreeBSD 256
		- Linux: 1024
		- MacOS X: 512
		- Windows NT: 1088
		- Windows 9x: 64
		- Android: 64
		- POSIX: 128
	- V2.8.0 OF THE LIBRARY HAVE PTHREAD_KEYS_MAX EFFECTIVELY SET TO 128, BUT THIS WOULD BE UNTRUE
			FOR WINDOWS 9X, MAKING THIS A BUG.
	- MICROSOFT SAYS:
					"TlsGetValue was implemented with speed as the primary goal. The function 
					performs minimal parameter validation and error checking. In particular, it 
					succeeds if dwTlsIndex is in the range 0 through (TLS_MINIMUM_AVAILABLE 1). It 
					is up to the programmer to ensure that the index is valid and that the thread 
					calls TlsSetValue before calling TlsGetValue." {SOURCE:
					https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlsgetvalue?redirectedfrom=MSDN}
			ALSO
					TLS_MINIMUM_AVAILABLE
			REMAINS 64 AFTER WINDOWS 9X IT SEEMS. ALSO TlsSetValue CAN FAIL.			
			THIS IMPLIES THAT THERE ARE NO STRONG GUARANTEES ABOUT ALLOCATION OF TLS STORAGE. THIS
			MEANS THAT IF YOU USE LESS THAN TLS_MINIMUM_AVAILABLE SLOTS, YOU ARE LIKELY FINE CALLING
			TlsGetValue AND TlsSetValue BEFORE CALLING TlsAlloc, BECAUSE THAT MEMORY IS PRE
			ALLOCATED. HOWEVER, YOU STILL HAVE TO WORRY ABOUT ACCESSING SOMETHING BEFORE
			INITIALIZING IT, MEANING YOU LIKELY STILL NEED TO CALL TlsSetValue BEFORE CALLING
			TlsGetValue. BUT IT IS ONLY AFTER TLS_MINIMUM_AVAILABLE NUMBER OF SLOTS, THAT WINDOWS 
			STARTS TO ALLOCATE MEMORY FOR THE EXTRA SLOTS. USEFUL REFERENCES TO CORRABORATE THIS 
			THEORY:
					https://comp.os.ms-windows.programmer.win32.narkive.com/OR6WYcIa/thread-local-storage-a-contradiction-in-the-available-ms-docs
					https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlssetvalue
					https://devblogs.microsoft.com/oldnewthing/20160613-00/?p=93655
					https://devblogs.microsoft.com/oldnewthing/20170712-00/?p=96585
			IF THE THEORY IS CORRECT, THE DESIGN DOES NOT NEED TO PREALLOCATE TLS SLOTS ON 
			ptw32_thread_t, AND NOT EVEN ON CREATION OF ptw32_thread_t USING DYNAMIC ALLOCATION, 
			AND INSTEAD WE SIMPLY NEED A POINTER ON ptw32_thread_t, AND WOULD ALLOCATE ONLY
			ON THE CALL OF pthread_setspecific WHICH IS ALLOWED TO FAIL FOR LACK OF MEMORY, USING
			"ENOMEM" FOR THE ERROR.
	- DONE: 
		- A FUTURE IMPROVEMENT MIGHT BE USING FLAG BITS FOR gPtw32_extendedTlsSlotsOccupancy. 
		- DECIDED TO EXTEND BY 196 SLOTS ONLY. IN THE WORST CASE SCENARIO, MEANING WINDOWS 9X,
				THIS GIVES A TOTAL OF (192 + 64) = 256, SAME AS THAT OF FREEBSD, AND LARGER THAN
				THAT OF ANDROID. APPLICATIONS SHOULD NOT BE USING MANY TLS SLOTS.
					
		

ABOUT ptw32_MCS_lock.c
	- SEE https://lwn.net/Articles/590243/ FOR AN EXPLANATION OF MCS LOCKS.
	- MCS LOCKS ALLOWS A THREAD SO SPIN ON ITS OWN THREAD LOCAL DATA THAT IS ACTING AS A LOCK.
			ANOTHER THREAD HAS A POINTER TO THIS DATA, THIS LOCK, AND SETS IT FOR THE FIRST
			MENTIONED THREAD TO KNOW THAT IT CAN PROCEED.
	- THE FUNCTIONS ptw32_mcs_flag_wait() AND ptw32_mcs_flag_set() ARE SIMPLY SYNCHRONIZATION
			MECHANISM FOR SETTING THE next DATA MEMBER ON THE ptw32_mcs_local_node_t
			TYPE WHEN USED WITH THE nextFlag DATA MEMBER. WHILE SETTING THE next OF THE ROOT NODE 
			TO POINT TO THE NEWLY ADDED NODE IS ATOMIC, UPDATING A PREVIOUS NODE'S next NEEDS 
			SYNCHRONIZATION. THINK OF ptw32_mcs_flag_wait() EXECUTING BEFORE ptw32_mcs_flag_set().
			ALTHOUGH ptw32_mcs_lock_acquire() APPEARS TO SET THE PREVIOUS NODE'S next
			BEFORE SYNCHRONIZING BY CALLING ptw32_mcs_flag_set(), IT IS ACTUALLY ANTICIPATING
			THE PREVIOUS NODE TO HAVE FINISHED ITS WORK, REALIZING THERE IS A NEW THREAD WAITING
			IN LINE, BUT IT'S next MEMBER IS NOT SET YET, AND THINKING IT NEEDS TO WAIT FOR IT
			TO BE SET AND HENCE CALLING ptw32_mcs_flag_wait() IN ptw32_mcs_lock_release().
			
			REMEMBER THAT THE ROOT NODE'S next DOES NOT POINT TO THE FIRST NODE, BUT POINTS TO THE
			LAST NODE THAT WAS ADDED. IN OTHER WORDS, THE LAST NODE THAT WAS ADDED HAS TWO NODE'S 
			next POINTING TO IT, THE ROOT'S AND THE PREVIOUS NODE.
	- ptw32_mcs_lock_t IS SIMPLY A POINTER TO ptw32_mcs_local_node_t, AND ABSTRACTLY
			IT IS AN ENTIRE ptw32_mcs_local_node_t. BUT BECAUSE FOR THE ROOT NODE, THE
			DATA MEMEBERS OF ptw32_mcs_local_node_t ARE NOT NEEDED EXCEPT FOR next,
			ptw32_mcs_lock_t SIMPLY ACTS AS THE next DATA MEMEBER OF THE ROOT NODE.

			IN OTHER WORDS, OUR ROOT, WHICH HAS TYPE ptw32_mcs_lock_t, IS NOT REALY A FULL NODE, AND
			IS JUST A POINTER TO THE LAST NODE, WHICH HAS TYPE ptw32_mcs_local_node_t, THAT WAS 
			ADDED TO THE QUEUE.
	- ptw32_mcs_lock_release() INDEED HAS A BUG IN V2.8.0 WHEN THE NODE FINDS THAT ITS next
			DATA MEMBER HAS BEEN SET AND THINKS THAT IT IS SAFE TO PROCEED. V3.0.0 INDEED
			FIXES THAT, IF MY CODE ANALYSIS ARE CORRECT. THE PROBLEM HAPPENS IF AFTER
			THE NEXT THREAD, NEXT NODE, SETS THE PREVIOUS NODE'S next IN ptw32_mcs_lock_acquire()
			THEN PROCEED TO SEND OFF AN EVENT TO PREVIOUS NODE USING ptw32_mcs_flag_wait() ON
			THE THE PREVIOUS NODE'S nextFlag. IT IS POSSIBLE THAT ENDS UP SENDING AN EVENT
			SIGNAL BEFORE THE PREVIOUS NODE ACTUALLY START WAITING FOR IT.
	- TO UNDERSTAND ptw32_mcs_node_transfer(), REMEMBER THAT THERE IS AN INHERENT GUARANTEE
			THAT THE next DATA MEMBER CAN ONLY EVER BE CHANGED ONCE BY A "SUCCESSOR" THREAD; IT
			IS NOT POSSIBLE FOR next DATA MEMBER TO BE CHANGED TWICE BY SUCCESSOR THREADS.
	- NOTE THAT THE MCS LOCK, BASED ON MY ANALYSIS, IS SAFE IF A THREAD PRE EMPTS ITSELF, AND
			IT IS ALSO SAFE AS A RE ENTRANT LOCK.
	- REMEMBER, THE CREATED NODE EVERYTIME THE LOCK IS USED, IS NOT A NEW LOCK, BUT A TICKET
			OF SORT TO BE THE NEXT IN LINE. THIS NEW NODE NEEDS TO BE THREAD LOCAL, AND HENCE
			USING A FUNCTION LOCAL VARIABLE IS SAFE.

		
THE FOLLOWING WILL PROBABLY NOT BE ADOPTED
	pthread_attr_setname_np: NOT POSIX. BSD COMPATIBLE*. LIKELY AFFECTS ABI. COULD HAVE BEEN DONE
			WITH CRXM. THE ISSUE IS SOME OS SUPPORTS A VERSION THAT TAKES A THIRD PARAMETER,
			AND SOME DO NOT. VERY RELATED TO THIS IS pthread_setname_np
			pthread_attr_setname_np IS NOT SUPPORTED ON LINUX AT ALL IT SEEMS.
			*: THIS DOES NOT SEEM TO EXIST ON FREEBSD, BUT SEEMS TO EXIST ON NETBSD
			
			UPDATE: DECIDED TO BRING THIS BACK INTO THE PTHREAD CODE, BUT NOT ADOPT IT IN THE FINAL
			CRX RT LIBRARY. REMEMBER THAT ORIGINALLY, A NORMALIZATION LAYER FOR POSIX WAS NOT IN THE
			PLANNING, AND THEREFORE DURING THAT TIME ANY FUNCTIONS PROVIDED BY PTHREAD WIN32 THAT
			ARE NOT FOUND ON ALL OTHER SYSTEMS TO BE SUPPORTED WERE NOT ADOPTED. HOWEVER, WHEN THE
			MY DESIGN FLOW REGARDING USING THREAD LOCAL VARIABLES TO SOLVE THE GLOBAL VARIABLE
			PROBLEM IN C WAS FOUND, WHICH IMPLIED THAT POSIX COULD NOT BE USED TO SOLVE THE SAID
			PROBLEM, A NORMALIZATION LAYER BECAME AN OPTION AGAIN BECAUSE NEW CODE NOW HAD TO BE 
			WRITTEN TO SOLVE THE GLOBAL VARIABLE PROBLEM. REMEMBER THE FLOW WAS THE FACT THAT THREAD
			LOCAL STORAGE WOULD GIVE YOU A KEY FROM THE SYSTEM, WHILE THE SOLUTION TO THE GLOBAL 
			VARIABLE PROBLEM WOULD HAVE REQUIRE THAT WE TELL THE SYSTEM WHAT KEY TO USE.
			
			NOTE THAT WITH BRINGING BACK pthread_attr_setname_np(), THE CODE THAT IMPLEMENTS A BSD
			VERSION WAS COMMENTED OUT.
	pthread_setname_np: THIS FUNCTION ALLOWS CHANGING THE NAME OF A THREAD FROM OUTISDE. IT TAKES 
			TWO PARAMETERS, HOWEVER ON MACOS IT TAKES A SINGLE PARAMTER AND ONLY ALLOWS CHANGING
			THE NAME FROM INSIDE. THERE IS SIMPLY NO WAY TO JUST 'IGNORE' THE EXTRA PARAMETER
			UNLIKE THE CASE WITH pthread_attr_setname_np. BECAUSE THESE TWO ARE RELATED,
			NEITHER WILL THESE TWO WILL LIKELY BE IMPLEMENTED.
			
			UPDATE: DECIDED TO BRING THIS BACK INTO THE PTHREAD CODE, BUT NOT ADOPT IT IN THE FINAL
			CRX RT LIBRARY. SEE NOTES ABOVE ABOUT pthread_attr_setname_np.
	pthread_getspecific, AND pthread_setspecific AND pthread_key_create ARE WHERE YOU WANT TO DO
			THE EXTENDED TLS WORK THAT YOU WANT TO DO.
	KEEPING THE NON STANDARD 
			pthread_getw32threadhandle_np.c	(WIN32 SPECIFIC)

WINDOWS API
	- CRITICAL SECTIONS:
		- MAKE USE OF THE CRITICAL_SECTION STRUCTURE AND PREPARE IT USING 
				InitializeCriticalSection(). THIS FUNCTION RETURNS NOTHING, BUT CAN THROW A 
				WINDOWS STRUCTURED EXCEPTION.
		- INTERNALLY USED A CRITICAL SECTION EVENT OBJECT. LATER SOMETHING CALLED A KEYED EVENT
				WAS INTRODUCED WHICH ALLOWED MULTIPLE CRITICAL SECTION TO BE TIED TO IT INSTEAD
				OF EACH CRITICAL SECTION HAVING ITS OWN CRITICAL SECTION EVENT OBJECT. THE SYSTEM
				DECIDES WHEN TO USE ONE OR ANOTHER. THIS ALSO LOWERED THE CHANCE OF 
				InitializeCriticalSection() FAILING. KEYED EVENTS WERE INMPROVED DURING WINDOWS
				VISTA.
		- DOES NOT ALLOW INTRAPROCESS LCOKING
		- ALLOWS RECURSIVE LOCKING.
		- EXAMPLE:
			class lock
			{
				CRITICAL_SECTION h;
				lock(lock const &);
				lock const & operator=(lock const &);
				
				public: lock()
					{InitializeCriticalSection(&h);}
				public: ~lock()
					{DeleteCriticalSection(&h);}
				public: void enter()
					{EnterCriticalSection(&h);}
				public: bool try_enter()
					{return 0 != TryEnterCriticalSection(&h);}
				public: void exit()
					{LeaveCriticalSection(&h);}
				public: CRITICAL_SECTION * handle()
					{return &h;}
			};
	- MUTEX
		- SLOWER THAN CRITICAL SECTION, BUT MIGHT BE MORE POWERFUL. IT ALSO APPEARS TO BE CLOSER
				TO THE KERNEL.
		- WORKS FOR FOR INTER-PROCESS LOCKING
		- ALLOWS RECURSIVE LOCKING.
		- EXAMPLE:
			#ifdef _DEBUG
				#include <crtdbg.h>
				#define ASSERT(expression) _ASSERTE(expression)
				#define VERIFY(expression) ASSERT(expression)
				#define VERIFY_(expected, expression) ASSERT(expected == expression)
			#else
				#define ASSERT(expression) ((void)0)
				#define VERIFY(expression) (expression)
				#define VERIFY_(expected, expression) (expression)
			#endif
			class lock
			{
				HANDLE h;
				lock(lock const &);
				lock const & operator=(lock const &);
				
				public: lock() : h(CreateMutex(nullptr, false, nullptr))
					{ASSERT(h);}
				public: ~lock()
					{VERIFY(CloseHandle(h));}
				public: void enter()
					{VERIFY_(WAIT_OBJECT_0, WaitForSingleObject(h, INFINITE));}
				public: bool try_enter()
					{return WAIT_OBJECT_0 == WaitForSingleObject(h, 0);}
				public: void exit()
					{VERIFY(ReleaseMutex(h));}
				public: HANDLE handle()
					{return h;}
			};
	- EVENT:
		- NOT EXACTLY A LOCK, BUT IT IS WHAT THE CRITICAL SECTION MECHANISM USES.
		- THREE TYPES EFFECTIVELY:
			- MANUAL-RESET EVENT:
				- CALL SetEvent() AND ResetEvent() TO MANUAL SET AND RESET SIGNALED STATE
				- CALLING SetEvent() WILL RELEASE ALL THREADS.
			- AUTO-RESET EVENTS:
				- AUTOMATICALLY RESET WHEN A WAITING THREAD IS RELEASED. NOTE THAT RESET MEANS
						CHANGING FROM SIGNALLED TO NON SIGNALLED.
						IN OTHER WORDS A THREAD IS WAITING ON A SIGNAL/EVENT TO BE SET, SOME ONE 
						CALLS SetEvent() AND THE EVENT BECOMES IN THE SIGNALED STATE, AND THIS THREAD 
						HAPPENS TO BE THE ONE RELEASED, BUT BECAUSE THE EVENT IS AN AUTO-RESET 
						EVENT, IT IS THEN IMMEDIATELY SWITCHED TO THE RESET STATE.
				- CALLING SetEvent() WILL RELEASE AT MOST ONE THREAD.
			- PULSE EVENTS:
				- CALL PulseEvent() TO RELEASE ONE THREAD THAT HAS WAITED ON THE AUTO-RESET EVENT.
						
								"For an auto-reset event object, the function resets the state to 
								nonsignaled and returns after releasing a single waiting thread, 
								even if multiple threads are waiting."{SRC:
								https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-pulseevent}
				- CALL PulseEvent() TO RELEASE ALL THREADS THAT HAVE WAITED ON THE MANUAL-RESET 
						EVENT.
								"For a manual-reset event object, all waiting threads that can be 
								released immediately are released. The function then resets the 
								event object's state to nonsignaled and returns."{SRC:
								https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-pulseevent}
				- ONLINE, PulseEvent() IS SEEN AS BUGGY, AND CERTAINLY NOT ITS OWN TYPE OF EVENT.
						HOWEVER, THIS IS SOMEWHAT WRONG. PulseEvent() IS ESSENTIALLY THE BUILDING 
						BLOCK OF OTHER EVENTS.
						
						THINK OF THE THREAD MANAGER, THE SCHEDULER IN PARTICULAR, THAT HAS QUEUE
						OF THREAD TO RUN, AND SOME HAVE A FLAG SET SAYING THAT THEY CAN NOT RUN.
						PulseEvent() IS THE MECHANISM TELLING THE SCHEDULER TO UNSET THE FLAG OF
						ONE THREAD THREAD WITH THE SAME FLAG, MEANING TO WAKEUP ONE THREAD IF
						THEY ARE SLEEPING, OR TO UNSET THE FLAG OF ALL THREADS WITH THE SAME FLAG,
						MEANING TO WAKEUP ALL THREADS IF THEY ARE SLEEPING. THAT IS IT. IF NO 
						THREADS ARE SLEEPING WITH THAT FLAG, NOTHING HAPPENS. CONTRAST WITH 

						AUTO-RESET EVENTS THAT WOULD REQUIRE PulseEvent() TO SEND THE MESSAGE TO THE 
						SCHEDULER, AND ALSO TO A FLAG, A VARIABLE THAT SAYS THE EVENT WAS SENT. IF 
						NO THREAD WAS SLEEPING AT THE TIME, AND A NEW THREAD COMES IN TO SLEEP, IT 
						WOULD CHECK THIS FLAG BEFORE SLEEPING. NOTICE HOW FLAG WOULD HAVE TO BE 
						PROTECTED BY A LOCK. IN OTHER WORDS, AUTO-RESET EVENTS ARE REALY CONDITION 
						VARIABLES, BUT WITHOUT EXPOSING THEIR PREDICATE, MEANING THE INTERNAL FLAG, 
						WHICH IS USED TO INDICATE THAT AN EVENT WAS FIRED. THIS INTERNAL FLAG IS 
						WHAT IS REFERED TO AS THE "SIGNALED STATE" ABOVE, AND IS NOT TO BE CONFUSED 
						WITH THE FLAG TALKED ABOUT EARLEIR THAT THE SCHEDULER SEES TO MARK A THREAD 
						SLEEPING AND WHAT "FLAG COLOR" IT IS WAITING FOR TO BE AWAKENED. THIS FLAG 
						COLOR IS THE EVENT OBJECT ESSENTIALLY.
						
						THE REAL PROBLEM WITH THE PULSE EVENT IS THE IMPLEMENTATION. ON WINDOWS A
						PulseEvent() CALL MIGHT BE MISSED BY A SLEEPING THREAD IF IN THE MEANTIME 
						THE OPERATING SYSTEM HAS "BORROWED" THE SLEEPING THREAD FOR SOMETHING SUCH 
						AS A KERNEL ASYNCHRONOUS PROCEDURE CALL (APC), OR DRIVER EVENT.
		- WaitForSingleObject() CAN BE USED TO WAIT FOR THE EVENT TO BE SIGNALED.
		- NOTE THAT THE 'SIGNAL' IS JUST A FLAG. IF THE EVENT IS MANUAL-RESET, AND SOME ONE CALLS
				SetEvent(), THEN ANY CALLS TO WaitForSingleObject() WILL NOT CAUSE ANY WAITING.
				HOWEVER, IF THE EVENT IS AUTO-RESET, THE EVENT REMAINS SIGNALLED UNTIL A THREAD
				IS RELASED, OR IF NO THREADS CURRENTLY WAITING, UNTIL A THREAD CALLS
				WaitForSingleObject() AND IT WOULD BE RELEASED IMMEDIATELY, AND IT IS 
				GUARANTEED THAT ONLY ONE THREAD IS RELEASED.
		- EXAMPLE:
			class event
			{
				HANDLE h;
				
				event(event const &);
				event const & operator=(event const &);
				
				public: explicit event(bool manual = false) :
						h(CreateEvent(nullptr, manual, false, nullptr))
					{ASSERT(h);}
				~event()
					{VERIFY(CloseHandle(h));}
				void set()
					{VERIFY(SetEvent(h));}
				void clear()
					{VERIFY(ResetEvent(h));}
				void wait()
					{VERIFY_(WAIT_OBJECT_0, WaitForSingleObject(h, INFINITE));}
			};
		- PulseEvent() FROM WHAT I CAN TELL IS A HIGHLY MISUNDERSTOOD FUNCTION, EVEN BY MICROSOFT
				THEMSELVES, BUT I THINK THESE ARE NOT THE ORIGINAL DEVELOPERS. PulseEvent() IS 
				ROUGHLY EQUIVILANT OF AUTO-RESET EVENT EXCEPT THAT IT CAN BE MISSED IF THERE IS NO
				THREAD WAITING. THIS IS SEEN AS THE PROBLEM OF PulseEvent() IN SOURCES ONLINE.
				
				HOWEVER, PulseEvent(), ASSUMING REDUCTION, AND BASED ON MY OBSERVATION THAT APPEARS
				TRUE, IS DESIGNED FOR PROBLEMS WHERE MISSING THE EVENT IS NOT AN ISSUE. PulseEvent()
				IS MEANT TO PULSE, MEANING CONTINUOSLY. IT IS NOT MEANT AS A ONE TIME THING. 
				OTHERWISE, WE ALREADY HAVE SetEvent(). BECAUSE OF THIS, PulseEvent() MORE STRONGLY
				ALLOWS FOR THE EXISTANCE OF PROBLEMS THAT CAN MISS THE EVENT.				
	- SLIM READER/WRITER (SRW)
		- THE FASTEST OF THE LOCKS, EVEN IF YOU SIMPLY NEED A BASIC CRITICAL SECTION.
		- FAST BECAUSE RELIES ON THE EFFICIENT KEYED EVENT AND MOSTLY IMPLEMENTED IN USER MODE
				AND ONLY FALLS BACK TO KERNEL MODE IF THREAD WOULD BE BETTER OFF SLEEPING.
		- DOES NOT ALLOW INTRAPROCESS LCOKING
		- DOES NOT ALLOW RECUSRIVE LOCKING
		- InitializeSRWLock() CAN NOT FAIL.
		- EXAMPLE
			class lock
			{
				SRWLOCK h;
				lock(lock const &);
				lock const & operator=(lock const &);
				
				public: lock()
					{InitializeSRWLock(&h);}
				void enterExclusive()
					{AcquireSRWLockExclusive(&h);}
				void enterShared()
					{AcquireSRWLockShared (&h);}
				bool try_enterExclusive()
					{return 0 != TryAcquireSRWLockExclusive(&h);}
				bool try_enterShared()
					{return 0 != TryAcquireSRWLockShared(&h);}
				void exitExclusive()
					{ReleaseSRWLockExclusive(&h);}
				void exitShared()
					{ReleaseSRWLockShared(&h);}
				SRWLOCK * handle()
					{return &h;}
			};
	- Condition Variable
		- Windows Vista and up
		- GENERAL IDEA:
						[LOCK-ENTER]					(1)
						while(![CONDITION-EVAL])		(2)
						{
							[LOCK-EXIT]					(3)
							[CONDITION-WAIT]			(4)
							[LOCK-ENTER]				(5)
						}
						[CRIICAL-WORK]					(6)
						[LOCK-EXIT]						(7)
				THE ASSUMPTION HERE IS THAT THE SAME LOCK IS USED TO CHANGE THE
				CONDITION VARIABLE AND SET THE EVENT. (4) IS ESSENTIALLY IS WAITING ON THE EVENT TO
				BE SET. SEE EVENTS ABOVE.
				IF THE LOCK ABOVE WAS, FOR EXAMPLE, A SRW LOCK, USING THE FUNCTION
				SleepConditionVariableSRW(), THE ABOVE CODE BECOMES
						[LOCK-ENTER]				
						while(![CONDITION-EVAL])	
						{
							SleepConditionVariableSRW(&vConditionVariable, LOCK.handle(), INFINITE, 0)
						}
						[CRIICAL-WORK]					(6)
						[LOCK-EXIT]						(7)
				NOTICE HOW SleepConditionVariableSRW RELEASES THE LOCK, WAITS ON AN EVENT, AND THEN
				REAQUIRES THE LOCK BEFORE RETURNING. NOTE THAT IT IS NOT A COINCIDENCE THAT THE
				CONDITION IS RECHECKED AGAIN AFTER SleepConditionVariableSRW() RETURNS.
				
				NOTE THAT [LOCK-ENTER] WOULD BE SOMETHING LIKE EnterCriticalSection.
				
				CONDITION VARIABLES ESSENTIALLY AVOID A SECONDARY [LOCK-ENTER] MAKING SURE THAT
				WHEN THE THREAD IS AWOKEN TO RECHECK THE CONDITION, IT ALREADY HAS THE LOCK.
				
				NOTE THAT RECHECKING THE CONDITION IS REQUIRED. THIS IS BECAUSE CONDITION VARIABLES
				CAN SUFFER FROM "SPORADIC WAKEUP", AT LEAST ON LINUX, BUT SEEM ALSO ON WINDOWS BASED
				ON THE INFORMATION ABOVE. THE THREAD WAKES UP BECAUSE THE CONDITION CHANGED, BUT
				BY THE TIME THE THREAD READS IT IT CHANGED BACK. 
				
				[LOCK-EXIT] FOLLOWED BY [CONDITION-WAIT] MUST APPEAR ATOMIC. THIS MEANS THAT IF
				IT SO HAPPENS THAT AFTER A CALL TO THE 'WAIT' FUNCTION OF THE CONDITION VARIABLE,
				WHERE [LOCK-EXIT] FOLLOWED BY [CONDITION-WAIT] HAPPENS, AND AFTER [LOCK-EXIT]
				HAPPENS, ANOTHER THREAD AQUIRES THE LOCK AND USES THE CONDITION	VARIABLE TO WAKE UP 
				ANOTHER THREAD, THE "SIGNAL" SHOULD NOT BE LOST, AND SHOULD APPEAR TO HAPPEN AS
				IF THE [CONDITION-WAIT] FINISHED FIRST. THIS IS EXACTLY WHAT THIS LIBRARY ACHIEVES.
				IN OTHER WORDS, [LOCK-EXIT] FOLLOWED BY [CONDITION-WAIT] ARE NOT ACTUALLY ATOMIC,
				BUT APPEAR ATOMIC. ON WINDOWS, IF JUST USING EVENTS, THIS ATOMICITY COULD BE
				ACHIEVED USING SignalObjectAndWait(), WHICH, NOT SUPRISIGNLY, CALLS THE PULSE EVENT
				BEHIND THE SCENES.
				
				"SPORADIC WAKEUP" ESSENTIALY HAPPENS BECAUSE WHEN THE THREAD THAT IS WAITING GETS
				A MESSAGE FROM ANOTHER THREAD, WHICH ALSO RELEASES THE LOCK, THAT IT CAN WAKE UP, 
				IT GETS WOKEN AND RESCHEDULED FOR WAKING UP, AND THEN IT NEEDS TO AQUIRE THE SAID 
				LOCK AGAIN. IN THE EXAMPLE ABOVE, THIS IS WHAT IS HAPPENING IN THE 
				SleepConditionVariableSRW() FUNCTION. BETWEEN THE TIME THE THREAD IS WOKEN, MEANING 
				RE SCHEDULED, AND THE TIME IT RUNS TO AQUIRE THE LOCK, SOME OTHER THREAD MIGHT HAVE 
				ALREADY BEGAN TO RUN, OR IS ALREADY RUNNING, AND AQUIRED THE LOCK.
				
				NOTE THAT THE CONDITION VARIABLE IS REALY JUST AN 'EVENT' WITH EXTRAS. IT IS NOT A
				VARIABLE HOLDING THE CONDITION. IT IS JUST A POINT FOR THE THREAD TO SLEEP, LIKE
				WITH EVENTS, AND AT SOME POINT, LIKE WITH EVENTS, A THREAD WILL WAKE UP OTHER
				THREADS SLEEPING ON THE CONDITION VARIABLE. HOWEVER, THE WAKING UP PROCESS IS LIKE 
				THAT OF PulseEvent(), MEANING THAT IF NO CONDITION VARIABLE IS WAITING UPON,
				THE WAKEUP CALL IS MISSED. HOWEVER, IMPLEMENTING A CONDITION VARIABLE WITH
				PulseEvent() MIGHT NOT WORK WELL, BECAUSE PulseEvent() IS VERY STRICT ABOUT NOT
				WAITING FOR ANY THREAD, WHILE A CONDITION VARIABLE MIGHT END UP WAITING IN THE
				SITUATION WHERE THE OPERATING SYSTEM "ASYNCHNOUSLY" WOKE UP THE THREAD TO HANDLE
				DRIVER WORK OR SIMILAR. REMEMBER THAT IN THIS SITUATION THE THREAD IS NOT WAKING
				UP AT THE POINT OF SLEEP, BUT INSTEAD ON SOME ARBITRARY POINT EFFECTIVELY SPEAKING
				TO HANDLE WHAT THE OS NEEDS, BEFORE IT IS PUT BACK TO SLEEP AGAIN TO BE RESUMED ON 
				ITS ORIGINAL POINT OF SLEEP. IN SITUATION, EVEN THOUGH THE THREAD WAS WAITING, FOR
				EXAMPLE, FOR THE PULSED EVENT, IT WOULD END UP MISSING IT BECAUSE OF THE 
				"ASYNCHRONOUS" WAKEUP. IN THE CONDITION VARIALE SITUATION, THIS SHOULD BE NOT THE
				CASE IF I AM NOT WRONG.
		- REASONS WHY IT IS BETTER, BUT NOT NECESSARY, TO HOLD ON TO THE LOCK BEFORE SIGNALLING. BE 
				CAREFUL WITH THE TERMINOLOGY IN THIS SECTION. THE TERMINOLOGY OF "ROOM", "EVENT", 
				"PULSE EVENT", "FLAG", "THREAD MANAGER" IS PER THE STANDARD, AND IS GENERALLY 
				DIFFERENT THAN ELSEWHERE IN THIS DOCUMENT.
			- REMEMBER, THAT PER THE STANDRAD, MY FORMAL WORK, A CONDITION VARIABLE IS A LEVEL 
					3 EVENT, MEANING AN ARTIFICIAL EVENT WITH A ROOM THAT IS LEVEL 3 OR HIGHER AND
					A LEVEL 1 EVENT, THE PULSE EVENT. AN ARITIFICAL EVENT IS ARTIFICIAL BECAUSE 
					WHEN ASKED TO SET THE CONCEPTUAL FLAG AND THE EVENT ID, OR TO UNSET A FALG WITH
					A PARTICULAR EVENT ID, IT MIGHT OR MIGHT NOT ACTUALLY PULSE EVENT, MEANING, 
					ACTUALLY CALL THE THREAD MANAGER AND HAVE THE ACTUAL FLAG AND EVENT ID SET, OR 
					HAVE THE AN ACTUAL FLAG UNSET. THE CONDITION VARIABLE IS AN IMPLEMENTATION 
					THAT ALLOWS THE USER TO HAVE HIS OWN SAY ALSO ON WHETHER TO PULSE THE ACTUAL
					UNDERLYING EVENT. IN OTHER WORDS, THE USER HAS HIS OWN PART OF THE CONDITION 
					VARIABLE'S ROOM AS DEFINED IN THE STANDARD. THIS IS CONTRARY TO HOW THE 
					CONDITION VARIABLE IS VIEWED OUTSIDE THE STANDARD. PER THE STANDARD, THE 
					CONDITION VARIABLE IS AN EVENT, NOT A ROOM. MEANING, IT IS NOT FOR 
					SYNCHRONIZATION IN ITS ESSENCE.
					
					GIVEN THIS, WHEN THE CONDITION VARIABLE IS ASKED TO UNSET THE ARTIFICAL FLAG,
					ROUGHLY SPEAKING, TO SIGNAL, THE CONDITION VARIABLE IS EXPECTED TO REUSE THE 
					ROOM FROM THE USER, IF IT HAS IT, WHICH WOULD HAVE BEEN PASSED BY THE USER 
					DURING A CALL FOR 'WAIT', TO ENTER THE ROOM AND MAKE THE FINAL DECISION ON 
					WHETHER TO ACTUALLY UNSET THE FLAG, TO PULSE THE EVENT, TO RELAY THE MESSAGE TO
					THE THREAD MANAGER. AT THE SAME TIME, CHANCES ARE, THE USER HAD A NEED TO 
					ENTER THE ROOM AND CHANGE SOMETHING BECAUSE, AFTER ALL, THAT CHANGE IS LIKELY 
					THE REASON WHY THE CONDITION VARIABLE WAS ASKED TO SIGNAL IN THE FIRST PLACE. IF
					THE USER SIGNALS WITHOUT EXITING THE ROOM FIRST, THE CONDITION VARIABLE WOULD 
					FIND ITSELF ALREADY IN THE ROOM, AND HENCE NOT REQUIRING A WAIT AS IT TRIES 
					ITSELF TO ENTER THE ROOM, WHICH WOULD BE LEVEL 4 OR HIGHER. IF ON THE OTHER 
					HAND, THE CONDITION VARIABLE ENDS UP BEING ASKED TO SIGNAL, BEFORE BEING ASKED 
					TO 'WAIT', IT WOULD NOT HAVE THE ROOM FROM THE USER YET, BUT THEN IT WOULD 
					DECIDE NOT TO RELAY THE MESSAGE TO THE THREAD MANAGER, MEANING THE SIGNAL WOULD 
					BE LOST. HOWEVER, THIS IS PER THE SPECIFICATION OF THE CONDITION VARIABLE, 
					MEANING THAT IF A SIGNAL HAPPENS BEFORE A WAIT, THE SIGNAL IS TO BE MISSED. 
					HENCE, THE VALIDITY OF THE STANDARD, OF DESIGNATING THE CONDITION VARIABLE AS 
					A LEVEL 3 EVENT. 

					IT SHOULD BE NOTED, THAT THE ABOVE IS ABSTRACT. THIS LIBRARY FOR EXAMPLE, DOES
					NOT ACTUALLY REUSE THE USER'S LOCK WHEN SIGNALLING, AND THEREFORE DOES NOT
					SUFFER THIS PARTICULAR PERFORMANCE LOSS IF THE USER LEAVES THE ROOM BEFORE 
					SIGNALLING.
			- BY REMAINING IN THE ROOM WHILE SIGNALLING, ANOTHER THREAD TRYING TO ENTER THE ROOM
					WOULD CURRENTLY CONTINUE TO BE SLEEPING. HOWEVER, IF SIGNALLING AFTER THE 
					EXITING THE ROOM, THAT COULD CAUSE ONE THREAD TRYING TO ENTER THE ROOM TO WAKE 
					UP, AND ANOTHER THREAD SLEEPING BECAUSE THE CONDITION VARIABLE PUT IT TO SLEEP
					TO WAKE UP BECAUSE OF THE SIGNAL.
			- IN THEORY, THERE CAN BE THE OPPOSITE EFFECT IF THE CONDITION VARIABLE VIOLATES BEING
					A REDUCED IMPLEMENTATION, AND IN PARTICULAR IF IT IS IMPLEMENTED AS PART OF 
					THE THREAD MANAGER ITSELF, OR IF THERE CURRENTLY CORES THAT ARE FREE. IN THESE
					CASES, UNSETTING AN ACTUAL FLAG, MEANING USING THE UNDERLYING PULSE EVENT,
					MIGHT BOTH CAUSE  AN ACTUAL FLAG TO BE UNSET AND THE ASSOCIATED THREAD TO BE
					WOKEN UP IMMEDIATELY. AND SUCH A THREAD, TRYING TO ENTER THE ROOM WILL SLEEP
					IMMEDIATELY AGAIN BECAUSE THE SIGNALLING THREAD IS CURRENTLY IN THE ROOM. 
					IRONICALLY, NON REDUCED IMPLEMENTATIONS IN THIS CASE, CAN CAUSE AN OPPOSITE 
					EFFECT WHERE NOT EXITING THE ROOM BEFORE SIGNALLING IS FASTER BECAUSE THE 
					THREAD MANAGER KNOWS IN THIS CASE TO UNSET AN ACTUAL FLAG WITHOUT IMMEDIATELY
					WAKING A THREAD UP.
		- RELATED TO "pthread_cond_wait.c.h" AND "pthread_cond_signal.c.h":
				REMEMBER THAT [LOCK-EXIT] FOLLOWED BY [CONDITION-WAIT] ARE NOT ACTUALLY ATOMIC IN 
				THIS LIBRARY, BUT APPEAR ATOMIC, AND THIS IS VALID PER THE POSIX STANDARD.
				THE SECRET IS IN THE IMPLEMENTATION OF THE UNDERLYING SEMAPHORE, THE CALL TO 
				sem_timedwait() WHICH IS RELYING ON A WINDOWS "AUTO-RESET EVENT", AND
				HENCE EVEN IF THE SLEEP HAPPENS AFTER THE SIGNALING, THE THREAD DOES NOT MISS THE
				SIGNAL. BUT REMEMBER, THIS IS AN EXCEPTION TO GET THE AFOREMENTIONED ATOMICITY. 
				OTHERWISE, THE CONDITION VARIABLE MUST NOT REMEMBER A MISSED SIGNAL. ALSO NOTE THAT
				THE FUNCTION ptw32_cond_wait_cleanup(), WHICH MUST ALWAYS BE CALLED, CONTAINS THE 
				BALANCING "sem_post(&(cv->semBlockLock))" CALL FOR THE "ptw32_semwait 
				(&(cv->semBlockLock))" CALL THAT HAPPENS IN "pthread_cond_signal.c.h". WHICH HAPPENS 
				AFTER CHECKING THE LOCAL VARIABLE "nSignalsWasLeft". 
				
				[NOTE THAT THIS SECTION, THIS BULLET POINT, IS NEW, AND I FORGET WHETHER I ANALYZED
				THE CONDITION VARIABLE BEFORE OR NOT, BUT I ALMOST CERTAIN THAT I DID, BUT I DO NOT
				SEEM TO HAVE LEFT ANY NOTES. IN THE FUTURE, IF YOU RE ANALYZE THE CONDITION VARIABLE
				CODE, MOVE THIS PARAGRAPH TO THE APPROPIATE SECTION]
				
THE MACRO PTW32_PROGCTR() IS SIMPLY PICKING OUT THE PARAMETER FOR THE INSTRUCTION POITNER REGISTER.
		ptw32_RegisterCancelation() IS THERE TO SET TO THE CANCELATION FUNCTION NEEDED.
		
NOTE: THE LOGIC OF HOW pthread_cancel() TREATS CANCELATIONS, WHERE IN THE MEANTIME CANCELATION
		IS DISABLED, IS FOUND IN w32_CancelableWait.c. THE FUNCTION THERE DOES RECHECK THE
		CANCELATION TYPE TO SEE IF CANCELATION IS ENABLED, AND IF NOT, IT DOES NOT WAIT ON THE
		CANCELATION EVENT SET USING WINDOWS SetEvent() IN pthread_cancel(). AND BECAUSE SetEvent()
		WORKS EVEN IF WAITING FOR THE EVENT HAPPENS AFTER IT IS CALLED, THE REQUIRED QUEUING IN THIS
		CASE IS ACHIEVED.

TYPES:
	- ptw32_handle_t IS pthread_t, AND HAS MEMBER p WHICH IS A VOID POINTER BUT TO TYPE 
			ptw32_thread_t_, AND ptw32_thread_t_ IS ptw32_thread_t. AND ptw32_thread_t_ HAS A 
			MEMBER ptHandle WHICH IS OF TYPE ptw32_handle_t.
	- THE USER IS GIVEN pthread_t, AND THE HIDDEN THREAD LOCAL STORAGE VALUE IS A ptw32_thread_t_.
	- ptw32_thread_t_(ptw32_thread_t_) AND ITS ASSOCIATED ptw32_handle_t(pthread_t) ARE NEVER 
			DEALLOCATED.
			
		
MICROSOFT'S "_ReadWriteBarrier" INTRINSIC APPEARS SUPPORTED WITH 1400 VERSION NUMBER. NOTE THAT FOLLOWING
		USEFUL CODE:
				#if !defined(SQLITE_DISABLE_INTRINSIC)
				#  if defined(_MSC_VER) && _MSC_VER>=1400
				#    if !defined(_WIN32_WCE)
				#      include <intrin.h>
				#      pragma intrinsic(_byteswap_ushort)
				#      pragma intrinsic(_byteswap_ulong)
				#      pragma intrinsic(_byteswap_uint64)
				#      pragma intrinsic(_ReadWriteBarrier)
				#    else
				#      include <cmnintrin.h>
				#    endif
				#  endif
				#endif
				#if MSC_VERSION
				#include <intrin.h>
				#pragma intrinsic(_ReadWriteBarrier)
				#define COMPILER_FENCE _ReadWriteBarrier()
				#elif GCC_VERSION
				#define COMPILER_FENCE asm volatile("" : : : "memory")
				#else
				#define COMPILER_FENCE
				#endif
		NOTE THAT THESE MACROS APPEARS TO HAVE BECOME DEPRECATED LATER. THEY SEEM TO HAVE STILL
		EXISTED IN VS2019.
		CHECK __sync_synchronize() FOR GCC. asm volatile ("" : : : "memory") IN GCC ALSO PREVENTS 
		COMPILER REORDERING.
		MemoryBarrier (MSVC) AND _mm_mfence (OTHER COMPILERS) AND __sync_synchronize(GCC) ARE 
		HARDWARE MEMORY FENCES.
		IT SEEMS FOR GCC, BY SIMPLY USING asm volatile ("" : : : "memory") BOTH HARDWARE AND
		COMPILER ARE COVERED. FOR MSVC, FOR VERSIONS AFTER VS6, IF ONE IS WRITING ASSEMBLY FOR THE
		ATOMICS AND USES THE INSTRUCTIONS THAT TAKE CARE OF THE HARDWARE ORDERING, ONE NEEDS 
		TO ALSO USE "_ReadWriteBarrier". HOWEVER, AT TIME POINT, I THINK VC2019, YOU GET A WARNING
		THAT MACROS LIKE "_ReadWriteBarrier" ARE DEPRECATED.
		
pthread_timechange_handler_np()
	- THIS FUNCTION APPEARS TO BE A SPECIFIC ADDITION TO THIS LIBRARY, AND THE REASON WHY THE 
			CONDITION VARIABLE STRUCTURE INSTANCES ARE STORED ON A LINKED LIST. THIS FUNCTION
			SEEMS MEANT TO BE USED BY THE USER TO WAKE UP ALL WAITING CONDITION VARIABLES.
			THIS IS ESSENTIALY RELATED TO THE POSIX "CLOCK_REALTIME" "CLOCK_MONOTONIC" PROBLEM,
			AND PTHREAD WIN32 OFFERS THIS FUNCTION AS A SOLUTION TO THAT. REMEMBER
			THAT POSIX WAIT FUNCTIONS WITH TIMEOUT USE "CLOCK_REALTIME", WHICH THE SYSTEM CLOCK
			THAT CAN BE ADJUSTED BY THE USER. SOME TIME LATER POSIX ADDED THE OPTION FOR
			"CLOCK_MONOTONIC" FOR THE CONDITION VARIABLE, BUT NOT THE OTHER STUFF.
			THIS LIBRARY SHOULD NOT SUFFER FROM THIS ISSUE BECAUSE IT USES INTERVALS, INSTEAD
			OF ABSOLUTE TIMES. IF THE CURRENT TIME IS 01:00PM, AND THE WAIT IS TO TIMEOUT AT
			01:05PM, THIS LIBRARY WILL INSTEAD BE SET TO WAIT FOR A MAXIMUM OF 5 MINUTES, RATHER
			THAN THE ABSOLUTE TIME, 01:05PM. THE ORIGINAL AUTHORS, HOWEVER, WERE WORRIED THAT
			IF THE USER ADJUSTS THE SYSTEM CLOCK BACKWARD, THE WAIT RETURNS EARLY FROM THE USER'S
			PERSPECTIVE. IN OTHER WORDS, THE USER CODE REALY WANTS TO TIMEOUT AT 01:05PM AND NOT FIVE
			MINUTES LATER. AND I IMAGINE THE APPROACH IS IMAGINING A PROBLEM WHERE IF THE USER
			MOVES THE SYSTEM CLOCK FARWARD PAST 01:05PM, THE USER CODE EXPECTS TO TIMEOUT
			IMMEDIATELY AND IT WOULD NOT BE A PROBLEM NOT HOW "LATE" IT WAS.
			
TODO(DONE, SEE LAST POINT BELOW): WaitForSingleObject(), WaitForSingleObjectEx(), 
		WaitForMultipleObjects(), WaitForMultipleObjectsEx()
	- THESE FOUR FUNCTIONS, AND MAYBE SignalObjectAndWait(), STOP THEIR TIMER WHEN DURING SLEEP.
			MEANING, THE PARAMETER "dwMilliseconds" DOES NOT INCLUDE TIME SPENT ON LOW POWER STATE.
			THIS HAPPENS ON WINDOWS 8 AND UP, AND WINDOWS SERVER 2012 AND UP.
	- TO SOLVE THIS, YOU NEED TO RELY ON THE FUNCTION "powerRegisterSuspendResumeNotification" FROM
			"powrprof.dll" TO SET AN EVENT LISTENER TO WHEN THE SYSTEM IS WOKEN AND THEN CALL
			SOMETHING LIKE SetEvent TO TELL WAITERS WAITING THAT TO WAKE AND RECORRECT FOR
			REMAINING TIME. GENERALLY, YOU WILL NOT BE ABLE TO USE WaitForSingleObject() FOR
			EXAMPLE, AND WILL HAVE TO USE WaitForMultipleObjects() INSTEAD TO WAIT FOR THE EXTRA
			EVENT THAT YOU WILL USE TO INDICATE AND EVENT FROM A WAKE FROM A LOW POWER STATE.
	- IF "powrprof.dll" DOES NOT EXIST, YOU ARE ON A SYSTEM THAT DOES NOT HAVE THE ISSUE FROM WHAT
			I CAN TELL. IF IT DOES, THE CALL TO powerRegisterSuspendResumeNotification() SHOULD
			RETURN 0, MEANING AND INDICATOR TO SUCCESS, BUT MIGHT ALSO FAIL AND RETURN
			" _ERROR_FILE_NOT_FOUND". IF THIS HAPPENS, THIS SOLUTION CAN NOT BE USED, AND AN
			ALTERNATIVE NEEDS TO BE FOUND.
	- YOU MIGHT WANT TO EMPLOY THE SAME EVENT THAT THE LIBRARY CURRENTLY USES TO SOLVE FOR THE 
			"CLOCK_REALTIME" "CLOCK_MONOTONIC" PROBLEM. MEANING YOU COULD USE THE FUNCTION
			"pthread_timechange_handler_np()" FOR THIS PURPOSE AS WELL
	- IT APPEARS THAT UNDER LINUX, "CLOCK_MONOTONIC" ALSO DOES COUNT "TIME SPENT ON SUSPEND". WITH
			THIS, THIS ISSUE BECOMES A NON ISSUE, AND "CLOCK_MONOTONIC" MUST SIMPLY BE SEEN AS AN
			UNRELIABLE TIME THAT IS GUARANTEED TO BE NEVER DECREASING.


CHANGES:
	- UNDER THIS FORK THE ptw32 NAME NAMESPACE AS DEFINED IN MY STANDARD IS CONSIDERED 
			PACKAGE PRIVATE.
	- BROUGHT BACK ptw32_InterlockedCompareExchange()
		- DEFINED PTW32_INTERLOCKED_LONG_FOR_FALLBACK. 
				UPDATE: CHANGED THIS TO BE USED FOR MICROSOT'S InterlockedCompareExchange() ONLY.
						SEE NOTES IN CODE.
		- DEFINED PTW32_INTERLOCKED_LPLONG_FOR_FALLBACK
				UPDATE: CHANGED THIS TO BE USED FOR MICROSOT'S InterlockedCompareExchange() ONLY.
						SEE NOTES IN CODE.
		- INTRODUCED OWN ptw32_InterlockedCompareExchange() MACRO, AND RENAMED
				ptw32_InterlockedCompareExchange() FUNCTION.
				
				UPDATE: RENAMED THE RENAME OF ptw32_InterlockedCompareExchange() BACK TO
				ptw32_InterlockedCompareExchange(), AND REMOVED THE ptw32_InterlockedCompareExchange
				MACRO.
		- THE WAY ptw32_InterlockedCompareExchange WAS ORIGINALLY IMPLEMENTED IN V2.8.0 WAS TO 
				RETURN ZERO IF NO ASSEMBLY WAS GENERATED FOR IT. THE CHANGES THAT I INTRODUCED
				WOULD CALL InterlockedCompareExchange() INSTEAD. 
				ORIGINALY, THIS WOULD HAPPEN IF THE OS DID NOT PROVIDE InterlockedCompareExchange, 
				MEANING THE CODE IN "pthread_win32_attach_detach_np.c" FAILED TO FIND
				InterlockedCompareExchange() IN THE OS DLL, AND THEREFORE THE LIBRARY FELL BACK TO
				USING ptw32_InterlockedCompareExchange(), AND ptw32_InterlockedCompareExchange() 
				WAS NOT GENERATED WITH ASSEMBLY INSTRUCTIONS. AN EXAMPLE OF THIS WOULD BE RUNNING
				ON WINDOWS 95, BUT HAVING COMPILED ON AN UN SUPPORTED SETUP 
				(COMPILER/INSTRUCTION SET).
				THE CODE CHANGES ARE BASED ON MAKING THE EXISTANCE OF THIS ATMOIC OPERATION TO 
				MANDATORY, WHICH MAKES THE OLD BEHAVIOR ILL DEFINED. HENCE, WITH THESE CHANGES
				WOULD NOT COMPILE IN THE FIRST PLACE. IF MY ASSUMPTION THAT THIS ATOMIC OPERATION
				WAS MEANT TO BE OPTIONAL ORIGINALLY IS WRONG, THEN THE ORIGINAL BEHAVIOR WAS ILL 
				DEFINED TO BEGIN WITH.
	- BROUGHT BACK ptw32_InterlockedExchange()
	- INTRODUCED ptw32_InterlockedDecrement()
	- INTRODUCED ptw32_InterlockedIncrement()
	- INTRODUCED ptw32_InterlockedExchangeAdd()
	- BROUGHT BACK FILE, "ptw32_InterlockedCompareExchange.c"
	- UPDATED implement.h ATOMIC MACROS TO USE THE FALL BACK FUNCTIONS THAT WERE BROUGHT BACK OR
			IMPLEMENTED, INSTEAD.
	- BROUGHT BACK ptw32_smp_system
	- INTRODUCED PTW32_WIN_*** MACROS FOR COMPATIBILITY SUCH AS THE ANSII FUNCTIONS, MEANING 'A'
			FUNCTIONS, ARE USED WHENEVER AVAILABLE, BUT OTHERWISE THE UNICODE CHARACTER FUNCTIONS
			ARE USED, MEANING THE 'W'. NOTE: THAT THE ANSII AND UNICODE VARIANT OF THE FUNCTIONS
			SOMETIMES DO NOT USE THE 'A' AND 'W' POSTFIX. THIS IS RARE IN DESKTOP WINDOWS, BUT VERY
			COMMON IN WINDOWS CE. IT IS ONLY START IN WINDOWS CE V3.0, I THINK, WHERE 'A' AND 'W'
			POSTFIXES STARTED TO MAKE AN APPEARANCE.
	- long IS ASSUMED 4 BYTES. ADDED CODE TO CHECK FOR THAT IN implement.h
	- CHANGED THE STRUCTURE OF THE DIRECTORY.
		- MOVED FILES FROM THEIR ORIGINAL LOCATION TO LOCATIONS THAT ROUGHLY MEET THE STANDARD.
		- ALL .c FILES, EXCEPT pthread.c, WERE RENAMED TO BE .c.h .
	- INTRODUCED __PTW32_CLEANUP_MANUAL MACRO
		- UNDER THIS MODE, THE SETUP FUNCTIONS, 
						pthread_win32_process_attach_np()
						pthread_win32_process_detach_np()
						pthread_win32_thread_attach_np()
						pthread_win32_thread_detach_np()
				ARE NO LONGER CALLED AUTOMATICALLY, AND USER CODE MUST CALL THE TWO SUPPLIED
				FUNCTIONS AT THE BEGGINING AND END OF main(). THE FIRST FUNCTION MUST PROVIDE
				THE IMPLEMENTATION FUNCTONS
						executeWithConditionalFinal()
						escapeThread()
						callUserDestroyRoutine()
						terminateIfNecessary()
						runThreadMain()
				THAT IS FORK DEFINES. THE ".src.c.h" AND ".src.cpp.h" PROVIDE DEFAULTS FOR THE 
				SEH MODE, THE setjmp/longjmp MODE, AND THE C++ EXCEPTIONS MODE. THE USER MUST
				INCLUDE ONE OF THE PROVIDED FILES IN ONE TRANSLATION UNIT, AND SUPPLY FUNCTION
				POINTERS OF THESE FILES TO THE INITILIZATON FUNCTION INTRODUCED BY THIS FORK.
		- UNDER THIS MODE, IMPLICIT WRAPPING OF WIN32 THREADS IS NO LONGER ALLOWED, EXCEPT
				FOR THE MAIN THREAD. THE MAIN THREAD IS SIMPLY DETECTED ON THE ASSUMPTION THAT
				THE INITIALIZATION FUNCTION THAT THE USER MUST CALL WILL BE CALLED IN main().
				IF THIS CONDITION IS NOT MET, THE LIBRARY COULD DETECT THE WRONG THREAD AS THE MAIN
				THREAD. WHATEVER THE LIBRARY THINKS IS THE MAIN THREAD, WILL BE THE ONLY THREAD
				ALLOWED TO BE IMPLICITLY WRAPPED.
		- UNDER THIS MODE, THREADS THAT FAILED TO IMPLICITLY WRAP, MEANING THREAD THAT ARE NOT THE
				MAIN THREAD, OR ARE THE MAIN THREAD BUT FAILED TO BE WRAPPED:
			- CAN ONLY USE THE FOLLOWING FACILITIES:
				- KILL: pthread_kill()
				- SEMAPHORE: THIS WORKS, BUT WAITS ARE NO LONGER CANCELABLE.
				- BARRIER: THIS MAKES USE OF SEMAPHORE
				- SCHEDULDER(SCHED)
				- pthread_exit()
				- pthread_getconcurrency(), pthread_setconcurrency()
					- THESE DO NOT ACTUALLY DO ANYTHING IN THE LIBRARY
				- pthread_num_processors_np()
				- pthread_once()
			- CAN USE THE FOLLOWING, BUT THEY WILL SIMPLY RETURN AN ERROR:
				- pthread_delay_np()
				- TLS
					- WARNING: KEY CREATION AND DELETION WILL WORK WITHOUT RETURNING AN ERROR. 
							MEANING CALLING pthread_key_create(), AND pthread_key_delete().
					- UPDAYE: (24-MAY-2025)
						- SETTING THE VALUE AND READING IT, MEANING CALLING pthread_setspecific()
								AND pthread_getspecific() SHOULD NOW NOT RETURN AN ERROR IF THE
								KEY IS NOT 'EXTENDED', MEANING NOT PART OF THE EXTENDED TLS SLOTS
								THAT WERE ADDED BY THIS FORK, AND ITS VALUES DO NOT REQUIRE CLEANUP.
								
								BEFORE, pthread_setspecific() ALWAYS MADE A CALL TO pthread_self()
								WHICH HAVE RETURN A NULL REPRESENTATION IF THE UNDERLYING THREAD IS
								NOT A PTHREAD OR IMPLICITLY WRAPPED. NOW, CALLS ARE AVOIDED TO
								THIS FUNCTION NOT NECESSARY, MEANING WHEN THE KEY IS NOT EXTENDED
								AND THE KEY HAS NO ASSOCIATED 'DESTRUCTOR' SET WITH IT.
				- THREAD JOINING
					- THIS APPLIES TO THE THREAD CALLING THE JOINING FUNCTIONS.
					- WARNING: THIS MEANS THAT UNLESS YOU ARE ON THE MAIN THREAD, AND IMPLICIT 
							WRAPPING FOR THAT THREAD WORKED, YOU CAN NOT CREATE JOINABLE POSIX 
							THREADS AT ALL.
							THANKFULY, THE LIBRARY'S pthread_create() ALREADY DECLINES CREATING
							THE THREAD IN THAT SITUATION, BUT THERE WAS STILL A MINOR BUG OF
							UNINTIALIZED pthread_t THAT I HAD TO FIX.
							TRYING TO SET VALUE, OR READ IT, UNDER THE KEY WILL SIMPLY RETURN AN
							ERROR.
					- I REVISITED THIS PROBLEM, AND JOIN THE FUNCTIONS NEED TO CALL pthread_self()
							BECAUSE THEY EVENTUALLY NEED IT TO MAKE THE WAIT CANCELABLE. THIS MIGHT
							BE FIXED SUCH AS THE JOIN FUNCTION CAN WORK WITH THREADS THAT FAILED TO
							IMPLICITLY WRAP, BUT THEY LOSE THE CAPACITY TO BE GRACEFULY CANCELLED IF
							THEY ARE WAITING ON A JOIN. HOWEVER, pthread_create() WOULD STILL HAVE
							TO BE EXAMINED TO SEE WHY IT NEEDS pthread_self() TO RETURN A VALID
							THREAD, AND IT SEEMS TO BE SO FAR TO ONLY INHERIT CERTAIN VALUES FROM
							CONTAINING THREAD, SUCH AS THREAD PRIORITY. OVERALL, HOWEVER,
							THIS IS NOT WORTH THE EFFORT.
				- pthread_setcancelstate()
				- pthread_setcanceltype()
				- pthread_testcancel(): RETURNS IMMEDIATELY.
				- pthread_timechange_handler_np()
			- CAN NOT USE THE FOLLOWING. USING THE FOLLOWING WILL LEAD TO UNDEFINED BEHAVIOR. IN
					DEBUG MODE, THE ERROR WOULD BE CAUGHT BY ASSERT STATEMENTS.
				- MUTEX
					- UPDATE(24-MAY-2025)
						- THIS SHOULD NOW BE USABLE WHEN THE MUTEX IS NOT SET AS ROBUST.
						- A NEW FUNCTION pthread_mutex_init2_np() WAS INTRODUCED TO CREATE THE MUTEX
								FREE FROM IMPLICIT WRAPPING DEPENDENCY
					- NOTES(13-APR-2025)
						- THIS USES pthread_self() IN THE NON ROBUST RECURSIVE CASE TO CHECK IF
								THE THREAD AQUIRING THE LOCK IS THE SAME THREAD THAT CURRENTLY HAS 
								THE LOCK.
						- THIS USES pthread_self() IN ALL ROBUST CASES. IN OTHER WORDS, IN THE 
								ROBUST CASE WHETHER THE LOCK IS RECURSIVE OR NOT, pthread_self() IS 
								USED. IT SEEMS THAT THIS HAPPENS BECAUSE THE MUTEX WANTS TO GIVE AN 
								ERROR IF THE THREAD TRYING TO UNLOCK IS NOT THE THREAD THAT LOCKED. 
								THIS CHECK IS NOT DONE IN THE NON ROBUST CASE.
						- IN THEORY, IT MIGHT BE POSSIBLE TO GIVE PARTIAL SUPPORT FOR USING THE 
								MUTEX FOR THREAD THAT FAILED TO IMPLICITLY WRAP.
				- CONDITION VARIABLE: 
					- UPDATE(24-MAY-2025)
						- THIS SHOULD NOW BE USABLE BECAUSE THE UNDERLYING MUTEX IS NOT SET TO BE
								ROBUST, AND THE MUTEX CAN NOW WORK UNDER THIS MODE IF NOT REOBUST.
								SWITCHED TO USING pthread_mutex_init2_np() INSTEAD OF
								pthread_mutex_init() IN THE CODE TO EMPHASIZE THIS.
								
								HOWEVER, BECAUSE THIS RELIES ON THE SEMAPHORE, LIKE THE SEMAPHORE,
								WAITS ARE NO LONGER CANCELABLE.
					- THIS MAKES USE OF MUTEX.
				- RW LOCK: THIS MAKES USE OF MUTEX AND CONDITION VARIABLE.
					- UPDATE(24-MAY-2025)
						- THIS SHOULD NOW BE USABLE BECAUSE THE UNDERLYING MUTICES ARE NOT SET TO BE
								ROBUST, AND THE MUTEX CAN NOW WORK UNDER THIS MODE IF NOT REOBUST.
								SWITCHED TO USING pthread_mutex_init2_np() INSTEAD OF
								pthread_mutex_init() IN THE CODE TO EMPHASIZE THIS.
								
								HOWEVER, BECAUSE THIS RELIES ON THE CONDITION VARIABLE, LIKE THE 
								CONDITION VARIABLE, WAITS ARE NO LONGER CANCELABLE.
				- SPIN LOCK:
					- UPDATE(24-MAY-2025)
						- THIS SHOULD NOW BE USABLE BECAUSE THE UNDERLYING MUTEX IS NOT SET TO BE
								ROBUST, AND THE MUTEX CAN NOW WORK UNDER THIS MODE IF NOT REOBUST.
								SWITCHED TO USING pthread_mutex_init2_np() INSTEAD OF
								pthread_mutex_init() IN THE CODE TO EMPHASIZE THIS.
					- THIS MAKES USE OF MUTEX IF THERE IS ONLY ONE CPU DETECTED.
			- CAN, CAN NOT USE THE FOLLOWING. I DO NOT YET:
				- FUNCTIONS INSIDE signal.h
			- CAN NOT EVEN BEGIN TO USE THE REST. IN OTHER WORDS, THEY ARE NOT APPLICABLE. THEY
					ESSENTIALLY EXPLICITLY ASK FOR THE PTHREAD TYPE AS A PARAMETER.
		- INTRODUCED pthread_ptw32_isSelfAPthread()
		- CURRENTLY, THE TWO PROVIDED INITILIZATION FUNCTIONS ARE CALLED
						pthread_ptw32_initializeLibrary()
						pthread_ptw32_finalizeLibrary()
				BUT THIS MIGHT CHANGE IN THE FUTURE.
				NOTE THAT THESE FUNCTION ARE CURRENTLY ALWAYS PROVIDED, BUT DO NOTHING IF 
				THE CLEANUP MODE IS NOT __PTW32_CLEANUP_MANUAL,
		- CURRENTLY pthread_ptw32_finalizeLibrary() DOES NOTHING, AND INSTEAD THE LIBRARY RELIES
				ON OTHER MECHANISMS SUCH AS DLLMAIN FOR THE TASK. THIS IS BECAUSE THERE IS THE
				ISSUE OF WAITING ON ALL THREADS TO FINISH BEFORE FULLY FINALIZING THE LIBRARY.
				HOWEVER, CODE IS KEPT FOR FUTURE WORK AIMING TO FULLY GET RID OF DLL MAIN.
		- UNDER THIS MODE, THE DEFAULT SEH BASED IMPLEMENTATION NO LONGER ALLOWS UNCAUGHT STRUCTURED
				EXCEPTION TO PASS THROUGH THE MAIN THREAD FUNCTION AND CAUSE THE PROGRAM TO
				TERMINATE. INSTEAD, THE IMPLEMENTATOIN RETURNS A CODE TO PTHREAD TO ASK IT TO
				TERMINATE BY CALLING THE USER PROVIDED terminateIfNecessary().
	- INTRODUCED ptw32_doProcessDetach(), ptw32_doInitializeLibrary():
		- THESE ARE ESSENTIALLY RENAMES OF pthread_win32_process_attach_np() AND
				pthread_win32_process_detach_np(), AND THIS WAS TO KEEP THESE TWO FUNCTIONS
				PACKAGE PRIVATE. THE ORIGINAL TWO FUNCTIONS STILL REMAIN AND SIMPLY FARWARD TO THE 
				RENAMED FUNCTIONS.
		- THIS WAS DONE TO KEEP pthread_ptw32_initializeLibrary(), AND
				pthread_ptw32_finalizeLibrary() ALWAYS AVAILABLE REGARDLESS OF THE CLEANUP MODE.
		- THIS WAS DONE PART OF ANTICIPATING FUTURE WORK WHERE pthread_ptw32_finalizeLibrary()
				DOES SOMETHING, AND DLLMAIN AND SIMILAR MECHANISMS ARE MADE FULLY NOT REQUIRED UNDER
				THE __PTW32_CLEANUP_MANUAL MODE.
	- INTRODUCED pthread_cond_timedwait_relative_np(), AND sem_timedwait_relative_np(). 
			sem_timedwait_relative_np() DOES NOT EXIST ANYWHERE ELSE, I SIMPLY INTRODUCED IT AND
			FOLLOWING THE NAMING CONVENTION FOR pthread_cond_timedwait_relative_np(), AND IT
			WAS INTRODUCED TO ALLOW IMPLEMENTING pthread_cond_timedwait_relative_np().
			pthread_cond_timedwait_relative_np() WAS INTRODUCED TO SOLVE THE UNRELIABILITY ISSUE 
			OF CLOCK_REALTIME WHICH IS EFFECTIVELY WHAT THIS LIBRARY USES FOR THE TIMING FUNCTIONS.
			THIS IS PER POSIX, HOWEVER. POSIX LATER INTRODUCED THE CAPACITY TO USE CLOCK_MONOTONIC
			FOR A NUMBER OF ITS FEATURES, WHICH THIS LIBRARY DOES NOT SUPPORT. TO SUPPORT, THE
			LIBRARY WOULD HAVE TO USE GetTickCount(), OR GetTickCount64() FOR CLOCK_MONOTONIC
			INSTEAD OF THE CURRENT GetSystemTime(), SystemTimeToFileTime(), 
			GetSystemTimeAsFileTime(), FUNCTIONS WHICH AMOUNT TO CLOCK_REALTIME.
			THE NAME pthread_cond_timedwait_relative_np() IS PER MACOS.
	
		
THE FOLLOWING REQUIRED MORE WORK AND ARE LEFT TO THE END:
	pthread_attr_getschedpolicy.c
	pthread_barrier_destroy.c
	pthread_barrier_init.c
	pthread_barrier_wait.c
	pthread_cancel.c
	pthread_cond_destroy.c
	pthread_cond_init.c
	pthread_delay_np.c
	pthread_detach.c
	pthread_getschedparam.c
	pthread_join.c
	pthread_key_create.c
	pthread_key_delete.c
	pthread_kill.c
	pthread_mutex_destroy.c
	pthread_mutex_init.c
	pthread_mutex_lock.c
	pthread_mutex_timedlock.c
	pthread_mutex_trylock.c
	pthread_mutex_unlock.c
	pthread_once.c
	pthread_rwlock_destroy.c
	pthread_self.c
	pthread_setcancelstate.c
	pthread_setcanceltype.c
	pthread_setschedparam.c
	pthread_setspecific.c
	pthread_spin_destroy.c
	pthread_spin_lock.c
	pthread_spin_trylock.c
	pthread_spin_unlock.c
	pthread_testcancel.c
	pthread_timechange_handler_np.c
	pthread_win32_attach_detach_np.c
	ptw32_callUserDestroyRoutines.c
	ptw32_cond_check_need_init.c
	ptw32_new.c
	ptw32_processInitialize.c
	ptw32_processTerminate.c
	ptw32_relmillisecs.c
	ptw32_reuse.c
	ptw32_rwlock_check_need_init.c
	ptw32_semwait.c
	ptw32_spinlock_check_need_init.c
	ptw32_threadDestroy.c
	ptw32_threadStart.c
	ptw32_throw.c


NON POSIX(NON PORTABLE)
	pthread_timedjoin_np
		THIS FUNCTION DOES NOT EXIST ON MACOS. FINISHED CODE SKETCH FOR AN ALTERNATIVE. REQUIRES
		CAREFUL CHECKING FOR CORRECTNESS
	pthread_tryjoin_np
		THIS FUNCTION DOES NOT EXIST ON FREEBSD.
		THIS FUNCTION DOES NOT EXIST ON MACOS.
	pthread_attr_getaffinity_np, 
			pthread_attr_setaffinity_np
		THIS FUNCTION DOES NOT EXIST ON MACOS. THERE IS NO WAY TO IMPLEMENT A FALLBACK FOR THIS
				UNLESS THE VERY ATTRIBUTE CLASS IS TO BE REPLACED WITH SOMETHING CUSTOM.
		PERHAPS A NEW THREAD CREATION FUNCTION COULD BE ADDED TO SUPPORT THE "EXTENDED
				ATTRIBUTES", EITHER BY SUPPORTING A NEW ATTRIBUTE CLASS, OR SIMPLY HAVING NEW 
				PARAMETERS SUCH AS THE CPU AFFINITY.
		ON FREEBSD, THESE SEEM TO HAVE EXISTED FROM V9.0 (IT APPEARS TO BE FROM V7.3)
		WILL NOT BE SUPPORTED
	sched_setaffinity, sched_getaffinity
		ON MACOS, DOES NOT EXIST. FINISHED CODE SKETCH FOR sched_getaffinity WHICH SIMPLY RETURNS 
				ALL CPUS. MIGHT WANT TO SIMPLY RETURN AFFINITY OF MAIN THREAD, BUT UNSURE.
		ON FREEBSD, DOES NOT EXIST. HOWEVER ON FREEBSD ONE COULD USE, 
						long number_of_processors = sysconf(_SC_NPROCESSORS_ONLN);
				FOR sched_getaffinity WHICH SHOULD WORK ON AT LEAST 8.0.0 AND UP. THIS WOULD SIMPLY 
				GET THE THE NUMEBR OF CPUS, AND NOT ACTUAL AFFINITY OF THE PROCESS. LIKE THE 
				FALLBACK FOR MACOS.
				FINISHED CODE SKETCH FOR FALLBACK ON FREEBSD. MIGHT WANT TO SIMPLY RETURN AFFINITY 
				OF MAIN THREAD, BUT UNSURE.
		ON LINUX, EXISTED FROM 2.5.8. 
			EXISTED IN glibc 2.3. NOTE THAT IN 2.3.3, the cpusetsize 
					argument was removed, THEN BROUGHT BACK IN 2.3.4
		WILL NOT SUPPORT sched_setaffinity. OR MIGHT SUPPORT BY SIMPLY IGNORING ON NON SUPPORTED
				PLATFORMS, OR BY CHECKING THE AFFINITY OF THE MAIN THREAD.
		WILL SUPPORT sched_getaffinity
	pthread_getaffinity_np, pthread_setaffinity_np
		ON MACOS, DOES NOT EXIST.
				FINISHED CODE SKETCH FOR FALLBACK FOR crx_pthread_getaffinity_np AND
				pthread_setaffinity_np
		ON FREEBSD, EXISTED SINCE 7.2
		ON LINUX. ON GLIBC 2.3.4. EXISTED ON GLIBC 2.3.3 BUT WITH DIFFERENT SIGNATURE. DID NOT
				EXIST ON GLIBC BEFORE THAT IT SEEMS.
		WILL SUPPORT pthread_setaffinity_np, pthread_getaffinity_np
	pthread_delay_np
		DOES NOT SEEM TO EXIST ON LINUX NOR FREEBSD NOR FREEBSD. FINISHED CODE SKETCH FOR
				FALLBACK.
		WILL SUPPORT
	pthread_mutexattr_getkind_np, pthread_mutexattr_setkind_np
		DO NOT USE THESE. THEY ARE SIMPLY  pthread_mutexattr_gettype AND  pthread_mutexattr_settype
				IT SEEMS.
		WILL NOT BE SUPPORTED
	pthread_num_processors_np
		NOT PORTABLE. FINISHED WRITING SKETCH CODE FOR FALLBACK. THIS IS ASSUMED TO MEAN NUMBER OF
				CORES, NOT NUMBER OF CPUS.
		WILL SUPPORT
	
PERTAINING TO GITHUB VERSION (PHASE 2 WORK):
	I FIRST GREATING A LOCAL GIT PROJECT (NOT USING GITHUB) WITH THE ORIGINAL V3.0.0 FILES, AND
			TRYING TO MODIFY THEM WITH SEARCH AND REPLACE TO GET THEM LOOKING AS MUCH AS POSSIBLE AS
			THE GITHUB FORK FIRST. THESE ARE THE "ToV3.x - Copy" AND "ToV3.x - Copy(2)" FOLDER.
			I THEN COMMITTED THE CODE, THEN COPIED THE GITHUB FORK FILES OVERWRITING, AND COMMITTED
			THE CODE AGAIN TO SEE WHAT CHANGED.
			AFTER INITIAL INSPECTION, I MAKRED THE FOLLOWING FOR DEEPER INSPECTION
					dll.c
					pthread_kill.c
					pthread_win32_attach_detach_np.c
					ptw32_threadStart.c
					ptw32_throw.c
					sem_timedwait.c
					w32_CancelableWait.c
	SOME DIFFERENCE:
		TRIES TO CALL ptw32_processInitialize() DURING CODE EXECUTION. I THINK I TRIES THAT IF 
				ptw32_processInitialize() FAILS. AND IF ptw32_processInitialize() DOES FAIL, THIS
				VERSION PROCEEDS TO PRETEND THAT IT DID NOT FAIL AND RETURN A RESULT ACCORDINGLY. WHILE
				V3.0.0 AND BEFORE WILL CORRECTLY INDICATE FAILURE.
		TRIES TO AVOID UNUSED PARAMETERS ERRORS, BY USING SOMETHING LIKE "(void)pParameter"
		PROVIDES ptw32_strdup() INSTEAD OF _strdup()
		SEEMS TO REMOVE THE register VARIABLE QUALIFIER. IT SEEMS RELATED TO THE DEPRECATION
				OF THIS KEYWORD IN C++11 AND REMOVAL IN C++17. 
				UPDATED CODE TO USE CRX_REGISTER INSTEAD OF register.
		THE FOLLOWING CODE ON MAJOR c FILES
						#if defined(_MSC_VER)
						#ifndef _CRTDBG_MAP_ALLOC
						#define _CRTDBG_MAP_ALLOC
						#endif
						#include <crtdbg.h>
						#endif
		WARNING: AVOID THE _WINDLL MACRO. IT IS SOMEHOW TIED TO 64BIT. ON VC6, IF ENABLED, THE DLL
				CAN NOT BE REGISTERED ON 64BIT WINDOWS. THIS MIGHT ALSO BE A MICROSOFT COMPILER
				ONLY THING (NEED TO CHECK).
		WARNING: THIS FORK ENDS UP SETTING threadH DATA MEMBER OF THE PTHREAD THREAD STRUCTURE TO 0
				WHEN DONE WITH IT. THIS IS A PARASITIC CODE, AND ENDS UP CAUSING CHANGES ELSEWHERE.
		IMPORTANT: THE FORK TRIES TO ALLOW pthread_kill() TO ALLOW SUDDEN TERMINATION OF THE THREAD USING
				TerminateThread(). THIS VERY LIKELY BREAKS THE TERMINATION LOGIC OF THE LIBRARY. AVOID
				UNLESS YOU PROVE ITS CORRECTNESS.
		THE FORK GOES BACK INTO CHECKING FOR NULLNESS OF PARAMETERS IN sem_timedwait().
		IMPORTANT: THIS FORK CHANGES THE BEHAVIOR OF WHAT HAPPENS IF ptw32_threadStart() ENCOUTNERS
				AN UNKNOWN SEH EXCEPTION. THIS FORK CHANGES THE BEHAVIOR TO SIMPLY TREAT
				THIS AS A CANCELATION. THIS IS VERY UNLIKELY TO BE CORRECT. THE ORIGINAL BEHAVIOR
				IS TO LET THE EXCEPTION ESCAPE WHICH SHOULD BE THE SAFE THING TO DO. REMEMBER THAT 
				SUCH A SITUATION, A SEH EXCEPTION NOT ORIGINATING FROM PTHREADS, CAN BE A NON 
				RECOVERABLE ERROR; SEH EXCEPTIONS ARE A SYSTEM THING. IT COULD ALSO BE THAT THE
				USER CODE THREW THE SEH EXCEPTION AND FORGOT TO CATCH. HOWEVER, WE HAVE TO ASSUME
				THE WORST, AND THAT IT CAME FROM THE SYSTEM. THE USER CODE MUST MAKE SURE TO CATCH
				ITS OWN EXCEPTIONS.
				
PHASE3 WORK:
	- SCHEDULING:
		- CODE SUCH AS pthread_setschedparam.c.h
		- windows: only SCHED_OTHER and value can be between the range of THREAD_PRIORITY_IDLE, 
				and THREAD_PRIORITY_TIME_CRITICAL. Note that depending on the windows version,
				THREAD_PRIORITY_IDLE could be larger than THREAD_PRIORITY_TIME_CRITICAL, or smaller.
				WINDOWS SCHEDULING SEEMS TO RUN IN TWO PHASES. 
				IN THE FIRST, WINDOWS UPDATES THREAD PRIORITIES WITH A BOOST OVER THEIR BASE 
				PRIORITIES.
				IN THE SECOND PHASE, THE THREADS ARE SCHEULED. IN TERMS OF LINUX'S IMPLEMENTATION
				THIS SCHEDULING SEEMS TO AMOUNT TO "SCHED_RR". IN OTHER WORDS, A THREAD OF HIGHER 
				PRIORITY CAN STARVE THREADS OF LOWER PRIORITY BECAUSE THEY CAN NEVER PRE EMPT IT, 
				WHILE THE HIGHER PRIORITY THREAD CAN PRE EMPT THEM AND BEFORE THEY FINISH THEIR 
				TIME SLICE.
				WINDOWS DOES MOMENTARILY BOOST THE PRIORITY OF THREADS WHEN THEY ARE TO RECIEVE AN 
				INPUT OF SORT, SUCH AS THE THREAD THAT IS RUNNING A WINDOW IS BROUGHT TO THE 
				FORGROUND, OR THE THREAD RUNNING A WINDOW IS RECIVING WINDOWS MESSAGES, OR WHEN 
				WAIT CONDITIONS OF A THREAD ARE SATISFIED SUCH AS WAITING FOR IO FOR EXAMPLE.
				THREADS' PRIORITY AFTER BOOSTING, MEANING THEIR DYNAMIC PRIORITY, IS NEVER LOWER 
				THAN THEIR BASE PRIORITY, MEANING THEIR ACTUAL PRIORITY.
				IT IS UNCLEAR IF WINDOWS THREADS CAN BE CONCIDERED "REAL TIME" THREADS OR NOT.
				BECAUSE OF PHASE 1 ABOVE, ONE CAN CONCLUDE THAT THE STARVING CAUSED BY HIGHER 
				PRIORITY THREAD WOULD BE TEMPORARY HAPPENING UNTIL WINDOWS RE ADJUSTS THE DYNAMIC
				PRIORITIES. ON THE OTHER HAND, IT IS UNCLEAR TO ME WHETHER CONDITIONS ARE GUARANTEED
				TO DO THE ADJUSTMENT IN A WAY THAT STARVATION IS KEPT TEMPORARY. WILL WINDOWS, FOR
				EXAMPLE, BOOST THE PRIORITY OF A THREAD THAT HAS NOT RUN FOR A LONG TIME?
				IT APPEARS FROM ANOTHER ARTICLE THAT STARVATION IS INDEED POSSIBLE ON WINDOWS. THE
				SCENARIO INVOLVES A THREAD SLEEPING WAITING FOR A LOWER PRIORITY THREAD TO DO ITS 
				WORK.
				WINDOWS PRIORITIES ARE BETWEEN 0 AND 31 ON NEWER VERSIONS, AND BETWEEN -15 AND 15 ON 
				WINDOWS 95 UP TO AND INCLUDING WINDOWS XP ATLEAST. ON A GIVEN WINDOWS VERSION, THE 
				PRIORITY CLASS OF A THREAD DETERMINES THE PRIORITY VALUES OF THE PRIORITY MACROS, 
				THREAD_PRIORITY_XXX. I AM ASSUMING THIS IS THE SAME ON OLDER AND NEWER WINDOWS.
				ON NEWER WINDOWS, NOTE THAT PRIORITY BOOSTING ONLY HAPPENS IF THE PRIORITY IS 15 OR 
				LOWER. THE PRIORITY CLASS REALTIME_PRIORITY_CLASS ASSIGNS A VALUE 16 AND UP TO THE 
				PRIORITY MACROS, WHILE OTHER CLASSES ASSIGN VALUES 15 AND LOWER. BECAUSE OF THIS, A 
				THREAD WITH REALTIME_PRIORITY_CLASS IS MORE LIKELY TO STARVE OTHER THREADS.
		- linux: has SCHED_OTHER but value can only be 0. However the function pthread_setschedprio()
				can be used to set priorities but after the creation of the thread, and in the
				range sched_get_priority_max() and sched_get_priority_min()
				You can not use something other than SCHED_OTHER as a fallback because SCHED_OTHER
				specifically indicates that the thread is no longer running under a realtime policy.
				BEWARE of SCHED_FIFO and SCHED_RR which are Real Time policies. A real time task is
				defined to run until the task decides not to, or encounters a blocking SYSCALL. They 
				can starve the regular SCHED_OTHER tasks.
				Instead on linux, one could use the Posix function nice() and rely on a bug there. 
				nice() affects the priority of SCHED_OTHER individual threads, but Posix requires 
				that it affects processes, not individual threads. Although it can work now, it can 
				fail in the future as a fallback. Furthermore more, nice() must be called from 
				within the thread.
				Instead of nice(), one can use setpriority() which set the same value that nice(),
				which sets the whole value, where nice() appears to set a differential value
				to affect the final 'nice' value. Either way, setpriority() but it is still a 
				violation under posix like nice(). {Source:
				https://man7.org/linux/man-pages/man2/getpriority.2.html}
				Over all, in linux there is no equivilant to setting thread priority like that of
				SetThreadPriority() in win32.
				NOTE THAT STARTING FROM LINUX KERNEL V2.6.23, THE SCHEDULER, NOW CALLED "COMPLETELY 
				FAIR SCHEDULER" WORKS LIKE MY SCHEDULER FOR MY CRXEU LIBRARY ON JAVASCRIPT UNDER 
				CRXEU'S RUN MODE "TIME_PER_THREAD". IN OTHER WORDS, IT SCHEDULES BASED ON TIME 
				SLICES, AND UNDER LINUX, THREADS WITH HIGHER PRIORITY RECEIVE LONGER TIME SLICES. 
				THE FORMULA FOR EACH THREAD WEIGHT APPEARS TO BE
						1024 / (1.25 ^ nice_value)
				IN OTHER WORDS, IF THE VALUE PASSED TO setpriority() IS TWICE AS MUCH, DO NOT 
				EXPECT TWICE AS MUCH PRIORITY.
		- macos: has SCHED_OTHER and values can be between PTHREAD_MIN_PRIORITY and
				PTHREAD_MAX_PRIORITY. IF THESE TWO ARE NOT DEFINED, THEY CAN BE ASSUMED TO BE 0 AND
				31 WHILE USING SCHED_RR INSTEAD OF SCHED_OTHER.
				USING THE NATIVE FUNCTIONS, thread_policy_set() AND thread_policy_get(), ONE CAN SET
				SCHEDULING VALUES BASED ON A TIME SLICE LIKE IN THE LINUX CASE. HOWEVER, THIS ONLY
				WORKS FOR REAL TIME THREADS, AND NOT NORMAL ONE. FOR NORMAL ONES, YOU CAN NOT
				SET A TIME SLICE, ONLY A SINGLE PRIORITY NUMBER, AND SIMPLY WORKS THE SAME AS
				USING THE POSIX API.
		- freebsd: THIS IS POSIX BASED. THE SCHEDULER FOR "SCHED_OTHER" SEEMS TO WORK MORE SIMILAR 
				TO WINDOWS THAN LINUX. IN OTHER WORDS, IT IS MORE BASED ON PRIORITY RATHER THAN TIME
				SLICE. THE MECHANISM IS CALLED ULE.
		- BECAUSE OF THE ABOVE ISSUES, POSIX FUNCTIONS FOR SCHEDULING POLICIES AND PRIORITY SHALL 
				BE NOT NORMALIZED, INCLUDED. FURTHER MORE, AN ATTEMPT TO A SIMPLISTIC PRIORITY LEVEL 
				SETTING WILL NOT BE IMPLEMENTED AT THIS TIME.
	- THREAD SCOPE:
		- NEITHER THIS LIBRARY, NOR LINUX SUPPORT PTHREAD_SCOPE_PROCESS. I DID NOT CHECK OTHER
				SYSTEMS. HENCE, THE ASSOCIATED FUNCTIONS WILL NOT BE NORMALIZED.
	- SHARING ACROSS PROCESSES:
		- PTHREAD_PROCESS_SHARED IS NOT SUPPORTED BY THIS LIBRARY, POSIX WIN32, EVEN THOUGH THE CODE
				MIGHT SUGGEST IT IS IN CERTAIN PLACES. HOWEVER ONCE YOU FOLLOW THE CODE FLOW, YOU
				SEE THAT IT IS FORBIDDEN, SUCH AS THE SEMAPHORE IMPLEMENTATION WHICH IS USED TO
				IMPLEMENT OTHER THINGS IN THE LIBRARY.
				FURTHER MORE, MACOS ALSO DOES NOT SEEM TO SUPPORT PROCESS SHARING FOR PTHREADS
				STUFF.
				HENCE "setpshared" FUNCTIONS WILL NOT BE NORMALIZED.
		- UNDER WINDOWS IT MIGHT BE POSSIBLE TO IMPLEMENT SHARING ACROSS PROCESSES BY USING SHARED 
				MEMORY, AND THEN DUPLICATING HANDLES, OR USING NAMED THINGS, SUCH AS NAMED EVENTS.
	- POSIX BARRIER:
		- MACOS DOES NOT IMPLEMENT THE POSIX BARRIER. HAD TO IMPLEMENT MY OWN USING CONDITIONS
				VARIABLES FROM REFERENCES ONLINE. MY IMPLEMENTATION COMPARED TO THE REFERENCES
				ACCOUNTS FOR "BUSY" WHEN THE BARRIER IS TO BE REMOVED TO BE COMPATIBLE WITH
				WITH POSIX WIN32 FEATURE WISE. HOWEVER, THE IMPLEMENTATION NEEDS TESTING.
				I ALSO HAD TO INTRODUCE MEMORY BARRIER USAGE, AND ACCOUNT FOR APPLE DEPRECATING
				ITS RELEVANT FUNCTIONS, AND IN PARTICULAR, OSMemoryBarrier().
	- CONCURANCY LEVEL:
		- "pthread_setconcurrency.c", "pthread_getconcurrency.c"
		- THESE DO NOT DO ANYTHING, EVEN ON LINUX.
	- THREAD KILL:
		- ONLY SUPPORTED FOR THE 0 ARGUMENT, AND HENCE A NEW FUNCTION IS DEFINED INSTEAD,
				isThreadValid()
	- MUTEX ROBUSTNESS
		- pthread_mutex_consistent(), pthread_mutexattr_setrobust(), pthread_mutexattr_getrobust()
		- NOT FOUND ON FREEBSD UNTIL V11 IT SEEMS. NOT FOUND ON MACOS.
	- TIMEOUT FUNCTIONS:
		- pthread_mutex_timedlock(), pthread_rwlock_timedrdlock(), pthread_rwlock_timedwrlock() AND
				OTHERS
		- THESE DO NOT EXIST ON MACOS.
		- WAS SEEKING TO IMPLEMENT THEM MYSELF FOR MACOS, BUT THERE IS ANOTHER PROBLEM WHERE THEY
				ALL RELY ON "CLOCK_REALTIME" WHICH IS THE TIME ESSENTIALLY THAT USER SEES, AND THIS
				TME CAN BE MODIFIED, WHETHER BY THE USER OF THE SYSTEM FOR THINGS LIKE DAYLIGHT
				SAVING. IDEALLY, THESE FUNCTIONS SHOULD BE USING "CLOCK_MONOTONIC".
				BECAUSE OF THIS PROBLEM, I CAN NOT NORMALIZE THESE FUNCTIONS. HOWEVER I CAN 
				IMPLEMENT MY OWN FUNCTIONS FOR ALL SYSTEMS THAT EFFECTIELY USE "CLOCK_MONOTONIC".
				THIS IS POSSIBLE BECAUSE OF THE FUNCTION pthread_condattr_setclock(). HOWEVER,
				ON SOME SYSTEMS, THIS FUNCTIONS DOES NOT EXIST, INCLUDING MACOS. THERE ARE
				ALTERNATIVE
		- ALTERNATIVE TO pthread_condattr_setclock()
			- pthread_cond_timedwait_relative_np: MACOS(>=10.4), IOS(>=2.0)
			- pthread_cond_timedwait_monotonic_np
				- ANDROID(< 5.0). 
				- ON ANDOIRD, PTHREAD IS PART OF libc.so. HOWEVER, I WAS UNABLE TO TELL IF THERE IS
						A RELIABLE WAY OF LOADING THIS LIBRARY. UNTIL THEN, THE CHECKS WOULD REMAIN
						COMPILE TIME, AND THIS IS NOT ALLOWED BECAUSE I SEEK ALL ANDROID TO BE
						A FAMILY AS DEFINED IN MY STANDARD.
						NOTE THAT SDL2 SUPPORTS ANDROID 4.1 AND UP, WHICH IS MY AIM TOO.
						THIS SHALL BE LEFT FOR FUTURE WORK.
				- ANDROID(>= 5.0) HAS pthread_condattr_setclock().
		- pthread_timedjoin_np():
			- EXISTS ON FREEBSD 9.0 AND UP.
			- MY CURRENT CODE SKETCH USES THE IDEA OF CREATING A NEW THREAD TO DO THE WAIT WHICH IS
					INEFFICIENT. A MORE EFFICIENT IMPLEMENTATION WOULD REQUIRE A THREAD POOL
					WHICH I AM PLANNING TO IMPLEMENT. THE MOST EFFICIENT REQUIRES WRAPPING
					THE PTHREAD THREAD USER MAIN FUNCTION IN MY OWN MAIN FUNCTION (TODO) DURING 
					CREATION, AND HAVE THAT FUNCTION EXPLICITLY SEND OUT A SIGNAL ON CANCELATION. 
					THE CODE LISTENING TO THE CANCELATION SIGNAL, WOULD STILL NEED TO PROCEED TO
					WAIT FOR THE THREAD TO JOIN BUT IT IS NOT BAD BECAUSE THE THREAD SHOULD BE 
					ENDING SHORTLY.
					THIS INJECTED MAIN FUNCTION WOULD ALSO SOLVE THE PROBLEM OF SETTING A NAME TO
					THREAD AT CREATION TIME, THE MAILBOX PROBLEM AND THE THREAD POOL PROBLEM, AND 
					ANY OTHER PROBLEM THAT WOULD REQUIRE THE THREAD TO COOPERATE, OR DATA TO BE
					ASSOCIATED TO THE THREAD BUT ACCESSABILE BY OTHER THREADS.
					UPDATE: A THREAD POOL WOULD NOT WORK, BECAUSE IF pthread_timedjoin_np() TIMES
					OUT, THE THREAD FROM THE THREAD POOL CURRENTLY HANDLING THE TASK OF WAITING TO
					JOIN WITH THE PERTAINING THREAD WILL HAVE TO BE CANCELLED, WHICH WOULD BE
					CANCELATION OF A THREAD FROM THE THREAD POOL.					
			- NOTE THAT THE IDEA OF AN INJECTED MAIN FUNCTION YOU WOULD REQUIRE A TYPE TO WRAP 
					pthread_t. YOU CAN NOT RELY ON THREAD LOCAL STORAGE TO STORE DATA. THIS IS 
					BECAUSE THE FALLBACK IMPLEMENTATION OF pthread_timedjoin_np() WOULD NEED TO 
					ACCESS THIS DATA, AND THEREFORE IT NEEDS TO BE STORED IN THE OBJECT PASSED TO 
					IT, THE pthread_t. THREAD LOCAL STORAGE OF THE ASSOCIATED pthread_t WOULD NOT 
					BE AVAILABLE TO pthread_timedjoin_np().
			- TO HAVE A TYPE WRAPPING pthread_t WOULD REQUIRE CLEANING IT UP AFTER THE THREAD IS 
					DONE. CONSIDER THE FOLLOWING SCENARIOS
				- IF THE THREAD IS CREATED DETACHED, THE CLEANUP COULD HAPPEN IN THE INJECTED MAIN 
						FUNCTION. 
						
						UPDATE: MEANING, WHEN THE THREAD IS DONE, MEANING NOT CANCELLED OR EXITED
				- IF THE THREAD IS CREATED JOINABLE, THE CLEAN UP HAS TO HAPPEN IN THE JOINING 
						FUNCTIONS SUCH pthread_timedjoin_np(), pthread_join() AND 
						pthread_tryjoin_np(). 
						
						UPDATE: MEANING WHEN THE THREAD IS JOINED, AND IF THE THREAD JOINS, IT 
								JOINS BECAUSE IT IS DONE. MEANING, NOT CANCELLED OR EXITED.
				- IF THE THREAD IS CANCELLED OR EXITED, THE CLEANUP WOULD HAVE TO HAPPEN USING 
						pthread_cleanup_push() AND pthread_cleanup_pop(). HOWEVER, THIS IS NOT 
						POSSIBLE CURRENTLY BECAUSE THE ULTIMATE GOAL IS A DLL THAT WORKS UNDER C 
						AND C++, WHILE THE AFOREMENTIONED FUNCTIONS ARE MACROS AND CAN GENERATE 
						C++ CODE. SEE ABOVE ABOUT THE WORK RELATED TO CLEANING UP THIS PART OF THE 
						PTHREAD WIN32 ARCHITECTURE. WHILE THIS IS NO LONGER A PROBLEM FOR MY FORK 
						OF PTHREAD WIN32, IT REMAINS A PROBLEM FOR THIS LIBRARY AS A WHOLE AS IT 
						AIMS FOR OTHER PLATFORM'S PTHREAD IMPLEMENTATION. HENCE THIS APPROACH
						CAN NOT BE TAKEN. INSTEAD ONE HAS TO RELY ON THE NORMALIZATION FUNCTIONS 
						THAT ARE INTRODUCED TO NORMALIZED PTHREAD'S FUNCTIONS. CONSIDR THE FOLLOWING
						SCENARIOS
					- IF THE THREAD IS CREATED DETACHED, THE NORMALIZATION OF pthread_cancel()
							AND pthread_exit() WOULD DO THE CLEANUP BEFORE CALLING THE PTHREAD
							UNDERLYING FUNCTIONS. NOTICE THAT WHEN IT COMES TO CANCELATION,
							IT DOES MEAN THAT YOU NEED TO REMEMBER SOMEHOW THAT THE THREAD
							IS CANCELABLE, AND THAT IT IS ABRUBTLY(ASYNCHRONOUSLY) CANCELABLE, 
							AND THAT IT IS DETACHED. THIS WOULD REQUIRE WORK IN THE NORMALIZING 
							FUNCTIONS OF pthread_setcancelstate(), pthread_setcanceltype(), 
							pthread_detach() AND pthread_create(), IF NOT OTHERS MORE.
							IF THE THREAD IS NOT ABRUBTLY CANCELABLE, YOU ALSO HAVE TO RELY ON
							THE NORMALIZATION OF pthread_testcancel() WHERE YOU WOULD HAVE TO
							DO THE CLEANUP.
					- IF THE THREAD IS CREATED JOINABLE, THEN YOU WOULD ONLY CLEANUP IN THE
							NORMALIZATION OF THE "JOINNG" PTHREAD FUNCTIONS. HOWEVER, YOU ALSO
							NEED TO KEEP TRACK OF WHETHER THE THREAD IS CANCELLABLE, AND WHETHER
							IT IS ABRUBTLY CANCELABLE, FOR EXAMPLE.
			- ALL IN ALL, HAVING AN INJECTED MAIN AND A WRAPPER FOR pthread_t, YOU WOULD ALMOST BE
					REIMPLEMENTING PTHREAD CLEAN UP LOGIC FROM THE GROUND UP JUST TO CLEAN UP THE 
					NEW TYPE WRAPPING pthread_t, AND THAT WORK IS NOT WORTH IT CURRENTLY. UNTIL 
					THEN, THIS FUNCTION, pthread_timedjoin_np(), WILL NOT BE IMPLEMENTED. (TODO)
			- ANOTHER APPROACH IS TO LOOP CALLING A FUNCTION THAT CHECKS WHETHER THE THREAD IS ALIVE
					OR IS DONE BUT NOT YET JOINED. I SAW EXAMPLES USING pthread_kill()
							https://linux-il.linux.org.il.narkive.com/6ZbBavjB/posix-ntpl-is-particular-thread-alive-pthread-timedjoin-np
					BUT IT IS WRONG TO DO PER POSIX
							https://stackoverflow.com/questions/2156353/how-do-you-query-a-pthread-to-see-if-it-is-still-running
							https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_kill.html
					OR ONE COULD USE pthread_tryjoin_np() INSTEAD BUT THAT FUNCTION IS NOT ON MACOS.
					ONE COULD ALSO TRY AND USE pthread_getschedparam(), BUT IT IS STILL NOT SAFE
							https://stackoverflow.com/questions/76763717/is-it-possible-to-use-thread-info-or-pthread-mach-thread-np-to-know-if-a-thr
					I CHECKED THE OFFICIAL APPLE IMPLEMENTATION CODE AND DID NOT PROVE IT SAFE TO
					USE THE pthread_getschedparam() APPROACH.
	- pthread_tryjoin_np
		- DOES NOT EXIST ON FREEBSD, AND MACOS.
		- UNSURE ABOUT THE DEFINITION OF THIS FUNCTION, WHICH SAYS NO BLOCKING AT ALL UNDER THE
				LINUX DOCUMENTATION. I IMPLEMENTED AN ALTERNATIVE THAT ONLY RUNS OF THREAD MAIN
				HAS EXISTED, BUT IT CAN STILL BE BLOCKING BECAUSE OF CLEAN UP FUNCTIONS. THE
				ALTERNATIVE IS IMPLEMENTED ON ALL SYSTEMS, INCLUDING THOSE THAT HAVE THE
				FUNCTION, MEANING WINDOWS AND LINUX.
	- THREAD NAMES
		- THREAD NAMING IS ONLY ALLOWED UPON CREATION. AS A CONSQUENCE, THE FUNCTION
				pthread_setname_np() WILL NOT BE NORMALIZED. SEE NOTES ELSEWHERE ABOUT THIS
				FUNCTION.
		- NAMES ARE LIMITED TO 15 CHARACTERS (SINGLE BYTES). THIS IS BECAUSE OF THE LIMITATION
				ON LINUX. SEE: https://linux.die.net/man/3/pthread_setname_np
		- WHILE THE pthread_attr_t TYPE COULD BE USED TO FILL THE NAME THAT WILL BE SET UPON THE
				THREAD DURING CREATION, THE FUNCTIONS pthread_attr_getname_np AND
				pthread_attr_setname_np ARE NOT FOUND ON MOST SYSTEMS, AND THEREFORE THIS
				APPROACH WILL NOT BE SUPPORTED TO AVOID CREATING OUR OWN NORMALIZED
				pthread_attr_t. INSTEAD A NEW THREAD CREATING FUNCTION WILL BE DEFINED THAT
				ALLOWS A NAME.
		- THE FUNCTION pthread_getname_np WILL BE NORMALIZED.
		- NOTES:
			- pthread_setname_np: EXISTS ON LINUX, AND FREEBSD(>= 12.2), AND MACOS BUT WITH
					DIFFERENT PARAMETERS
	- SEMAPHORE
		- DOES NOT EXIST ON MACOS
		- sem_getvalue()
			- DECIDED NOT TO NORMALIZE THIS BECAUSE THE RETURN IS UNLIKELY TO BE USEFUL AND
					IMPLEMENTATION WOULD REQUIRE ATOMICS FOR THE MACOS FALLBACK. ON 
					THE MACOS FALLBACK THE NORMALIZATION CODE WOULD HAVE TO KEEP TRACK OF THE
					SEMAPHORE VALUE ITSELF, ATOMICALLY INCREMENTING AND DECREMENTING IT, SUCH 
					AS WHEN THIS FUNCTION IS CALLED IT CAN RETURN THE VALUE.
			- POSIX ALLOWS TWO POSSIBILITIES FOR THE RETURN OF THIS FUNCTION IF THERE IS AT
					LEAST ONE THREAD WAITING. EITHER 0, OR A NEGATIVE NUMBER WHOSE ABSOLUTE
					VALUE IS THE NUMBER OF THREADS CURRENTLY WAITING. ANOTHER REASON WHY I 
					DO NOT WISH TO NORMALIZE THIS FUNCTION. NOTE THAT BOTH FREEBSD AND LINUX
					DECIDED TO RETURN 0 INSTEAD.
		- FOR THE MACOS FALLBACK, COULD NOT USE BASIC WAIT FUNCTIONS BECAUSE THE MACOS WAIT
				FUNCTION, dispatch_semaphore_wait(), WOULD NOT ACT AS A CANCELLATION POINT LIKE
				sem_wait() WOULD.
	- MODE __PTW32_CLEANUP_MANUAL MACRO
		- REMEMBER, UNDER THIS MODE, WHICH IS THE INTENDED MODE THAT THE FINAL ABSTRACTION LIBRARY 
				OF PTHREADS ACROSS ALL SYSTEMS SHALL USE, THE PTHREAD ON WINDOWS, MEANING USING
				THIS PTHREAD WIN32 FORK, MUST BE PTHREAD OR AN IMPLCITIYL WRAPPED THREAD.
				THIS CAUSES A LOT OF PTHREAD WIN32 FACILITIES TO BE UNUSABLE IF THE UNDERLYING 
				THREAD IS NOT A PTHREAD OR AN IMPLICITLY WRAPPED THREAD ON WINDOWS. TIME PROVED THAT
				THIS RESTRICTION IS VERY PROBLOMATIC. CONSIDER THE NEED FOR A LOCK, A PTHREAD MUTEX,
				WHEN THE LIBRARY NEEDING THE LOCK IS NOT INVOLVED WITH THREADS AT ALL AND SIMPLY
				MAKING ITSELF SAFE IN A MULTITHREADED SITUATION. THE WORK HERE WAS DONE TO ALLOW
				SUCH FACILITIES TO WORK WITHOUT THE NEED OF AN UNDERLYING PTHREAD OR IMPLICITLY
				WRAPPED THREAD.
		- MUTEX: INTRODUCED THE FUNCTION pthread_mutex_init2_np() TO ALLOW USING THE PTHREAD MUTEX 
				WITHOUT REQUIRING THE UNDERLYING THREAD TO BE A PTHREAD OR IMPLICITLY WRAPPED 
				THREAD. THIS HOWEVER, FORBIDS THE MUTEX FROM BEING ROBUST, AND WILL RETURN AN ERROR 
				IF ROBUSTNESS IS REQUESTED.
		- SPIN LOCK: THIS SHOULD NO LONGER REQUIRE THAT THE UNDERLYING THREAD BE A PTHREAD OR AN
				IMPLICITLY WRAPPED THREAD.
		- TLS: TLS CAN NOW BE USED WHEN THE UNDERLYING THREAD IS NOT A PTHREAD NOR AN IMPLICITLY
				WRAPPED THREAD IF THE KEY IS NOT ON AN EXTENDED SLOT, NOR DOES IT HAVE A 
				'DESTRUCTOR' ASSOCIATED WITH IT.
	- TODO:
		- THREAD POOL: MAKE EACH THREAD ATTACHABLE TO A THREAD POOL. 
			- USE A LINKED LIST WITH FINITE SIZED SEGMENT THAT ALLOWS NO HOLES FOR THE MESSAGE 
					QUEUE.
		- MAILBOX: GIVE EACH THREAD A MAIL BOX. 
			- USE A LINKED LIST WITH FINITE SIZED SEGMENT THAT ALLOWS NO HOLES FOR THE MESSAGE 
					QUEUE WHEN TIMEOUT 0.
			- USE A BINARY HEAP TREE WHEN TIMEOUT > 0. AVOID OTHER HEAP IMPLEMENTATIONS.
			- ALLOW MESSAGES FROM THE THREAD ITSELF AND FROM OTHER THREAD TO PUT MESSAGES IN THE
					THREAD'S MAIL BOX.
			- MAKE SURE TO USE A RECURSIVE MUTEX FOR PROTECTING THE MAIL BOX.
		- EVENT: IMPLEMENT WINDOWS EVENTS USING CONDITION VARIABLE
			- IMPLEMENT MANUAL-RESET EVENT
			- IMPLEMENT AUTO-RESET EVENTS
			- NOTE THAT PULSE EVENTS ARE IMPOSSIBLE TO IMPLEMENT WITH CONDITION VARIABLES.
			- WILL RELY ON ARRAYS FOR STORING LINKED EVENTS, AND USE A HASH TABLE INSTEAD WHEN
					THE LIST BECOMES LARGE. REMEMBER THAT WHETHER ARRAY, OR HASHTABLE, THE
					LINKED EVENTS MUST BE UNIQUE.
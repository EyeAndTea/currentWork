These are notes pertaining to my fork

CURRENT WORK (FINISHED BUT THE NOTES NEED TO BE ARCHIVED PROPERY TO THIS FILE OR PERHAPS ELSEWHERE.):
	- The next merge has to be from the official commit of 2021-jan-30. This is because of the
			changes in the mysqli drive pertaining to ADOConnection::Execute(), and the later
			fix in January 30.
	- List of issues up to merge point indicated above:
		- MetaType(), ActualType() customization
			- This newly added feature is ill defined, and is to be removed, rejected.
		- Mysqli driver 'fix' for variable binding.
			- The implementation is ill defined because of the use of the newly added variable 
					"usingBoundVariables" to keep track of things. And also because the implemented
					Execute() function is different compared to the base Execute function. In this fork,
					overriding Execute is also effectively not allowed, because if doing it the code
					is likely doing something wrong.
					The implementation also gives the illusion, becuase of the variable useLastInsertStatement that
					mysqli_insert_id() does not work with prepared statements
			- The issue of why ADOConnection::Prepare() is not implemented has to do with the fact
					that prepared statements have their own API.
				- Querying:
					- If using normal statements, ::mysqli_query() is to be used with the sql string,
							and that returns a mysqli_result object or true. and reliably returns false if
							there is an error
					- If using prepared statements, one can use ::mysqli_prepare() on a string with placeholders,
							then use ::mysqli_stmt_bind_param() to bind the parameters to the placeholder
							then use ::mysqli_stmt_execute(), then call mysqli_stmt_get_results() which
							returns a mysqli_result object or false (no error), or false when error. To
							distinguish between the two "falses",  ::mysqli_stmt_errno() can be used for
							PHP >= v7.4.13, and ::mysqli_errno() otherwise. However, mysqli_stmt_get_results()
							is only available if mysqlnd extension is avaiable, which if for PHP v5.3 and up.
							
							Note that using ::mysqli_prepare() without placeholder will cause a warning
							unless disabled using ::mysqli_report()
							
							If mysqlnd is not avaiable, but mysqli is, one would have to use other functions,
							but they would not be equvilant, in the sense, that you would not end up with
							a mysqli_result object from what I saw.
				- Affected rows:
					- If using normal statements, one must use ::mysqli_affected_rows()
					- If using prepared statements, one must use ::mysqli_stmt_affected_rows() which can natuarly
							be used right after ::mysqli_stmt_execute()
				- Fetching results: Thankfuly there is a way under both approaches to end up with a mysqli_result
						object, which is what has the fetch methods.
				- Insert id: Thankfuly ::mysqli_insert_id() works for both approaches, and further more
						mysqli_stmt_insert_id(), which is special for prepared statements, is not even reliable!
						Thank fuly, also LAST_INSERT_ID() works for both cases.
			- Reference code, based from code in the official commit:
					$vPreparedStatement = $this->_connectionID->prepare($sql);
					$vReturn = false;
					
					if ($vPreparedStatement === false)
						{$this->outp_throw("error");}
					else
					{
						$nparams = $vPreparedStatement->param_count; //placeholder count
						$tArrayOfRefences = array();
						$tIsSuccess = false;

						//Must pass references into call_user_func_array
						foreach($inputarr as $key => $value)
							{$tArrayOfRefences[$key] = &$inputarr[$key];} //
							
						//call_user_func_array IS ONLY USED HERE BECAUSE WE DO NOT KNOW THE NUMBER OF PARAMETERS
						call_user_func_array(array($vPreparedStatement, 'bind_param'), $tArrayOfRefences);
				
						$tIsSuccess = mysqli_stmt_execute($vPreparedStatement);
						
						if($tIsSuccess != false) //NOT ERROR?
						{
							if ($vPreparedStatement->affected_rows > -1) //Is the statement a non-select
							{
								$this->statementAffectedRows = $vPreparedStatement->affected_rows;
								$vReturn = true;
							}
							else
								{$vReturn = $vPreparedStatement->get_result();}
						}
					}
			
					return $vReturn;
			- The proper approach is to change the driver to use prepared statements everywhere, or
					normal statements everywhere. Whether however one can use prepared statements everywhere
					is another matter. Would they work with transactions for example? I do not know.

	- fix how ADORecordSet instances are created in adodb-csv.inc.php, adodb-csvlib.inc.php, and the
			repairing of code pertaining to the old ADORecordSet_array

nOTE: check the following:
SetTransactionMode() from pdo. what happened to it?

- ABOUT ADODB IN GENERAL:
	- IN THIS FORK, CODE USES CLASS MEMBER ACCESSORS, AND LIKE THE MAIN FORK, USES __construct() FOR CONSTRUCTORS.
			THE SUPPORT IN THIS FORK IS FOR PHP 5 AND UP. ALL CODE CHECKS PERTAINING TO OLDER PHP HAS BEEN REMOVED
			IF THEY ARE SAFE TO REMOVE. SEE COMMIT  (10/1/2015 8:57:26 AM)
			ALL CLASS MEMBERS STARTING WITH AN UNDERSCORD WERE CONSIDERED PROTECTED, OTHERWISE THEY WERE CONSIDERED
			PUBLIC.
			AFTER COMMIT (7/26/2018 3:52:43 PM), ACTUAL SUPPORTED PHP VERSION WENT UP TO 5.2 IN THIS FORK.
			HOWEVER, YOU MIGHT WANT TO AMMEND THE WORK IN THAT COMMIT TO BRING DOWN THE SUPPORT TO 5.0.
			CODE THAT ADDS SUPPORT FOR PHP VERSIONS BETWEEN 5.0 AND 5.2 REMAINS AND IS STILL WELCOME.
			PAY ATTENTION TO "composer.json" FILE. MAKE SURE TO ALWAYS HAVE THE CORRECT PHP VERSIONS
			SET, WHICH WOULD NOT INCLUDE PHP V5.0, FOR EXAMPLE, IN THE MAIN FORK.

- ABOUT CONNECTION DRIVERS:
	- GENERAL:
		- IN THIS FORK EACH DRIVER HAS ITS OWN UNIQUE ADOConnection::$databaseType SUCH AS IT CAN BE USED TO RESOLVE
				THE DRIVER'S PHP FILE NAME, AND CLASS NAMES OF ASSOCIATED ADORecordSet CLASSES.
			- DRIVER'S PHP FILE NAMES WERE NORMALIZED ACCORDINGLY. SEE COMMIT (7/5/2015 12:46:37 PM)
				- "adodb-access.inc.php" WAS RENAMED TO "adodb-odbc_access.inc.php"
				- "adodb-sapdb.inc.php" WAS RENAMED TO "adodb-odbc_sapdb.inc.php"
				- "adodb-vfp.inc.php" WAS RENAMED TO "adodb-odbc_vfp.inc.php"
				- NOTE THAT GIT CONTINUES TO TRACK THE CHANGES ON THE RENAMED FILE FROM THE OLD NAMED FILES
						IN THE MAIN FORK.
			- DRIVER'S RELATED ADOConnection SUB CLASSES, AND RELATED ADORecordSet SUB CLASSES WERE CREATED OR
					RENAMED ACCORDINGLY.
			- SEE COMMIT (7/5/2015 12:46:37 PM)	
		- PAY ATTENTION TO THE FUNCTION _adodb_getdriver() WHEN ADDING A NEW DRIVER.
		- IN THIS FORK _adodb_getdriver() RETURNS SOMETHING THAT ALLOWS MAPPING TO DATA DICTIONARY FILES,
				PERF FILES. IN OTHER WORDS, NOT THE DRIVER FILES.
		- IN THIS FORK DRIVERS WERE FIXED TO USE THE ADOConnection::hasTransactions INSTANCE VARIABLE. THIS ONLY
				AFFECTS THE DRIVER IN THE FILE "adodb-sybase.inc.php"
		- IN THIS FORK, ADOConnection::BeginTrans() WAS NORMALIZED TO RETURN TRUE OR FALSE. THIS ONLY AFFECTED
				THE MYSQL DRIVER,  adodb-mysql.inc.php, WHICH USED TO THROW AN EXCEPTION INSTEAD FOR LACK OF SUPPORT.
		- IN THIS FORK, ADOConnection::CreateSequence() WAS NORMALIZED TO RETURN TRUE OR FALSE. IT WAS ALSO
				FIXED IN A NUMBER OF DRIVERS TO ENDURE COMPLIANT FUNCTION SIGNATURE.
				IT WAS ALSO NORMALIZED SUCH AS IT CAN NOT BE USED TO RESET A SEQUENCE, WHICH IS PER APPARANT
				SPECIFICATION. THIS AFFECTS "adodb-ado_mssql.inc.php", "adodb-mssql.inc.php" AND
				"adodb-mssqlnative.inc.php".
		- IN THIS FORK, ADOConnection::DropSequence() WAS FIXED IN A NUMBER OF DRIVERS TO ENSURE COMPLIANT FUNCTION
				SIGNATURE.
		- IN THIS FORK, AS A SIDE EFFECT OF THE NORMALIZATION, CODE PERTAINING TO ADOConnection::CreateSequence()
				NO LONGER EXISTS IN ADOConnection::GenID()
		- ADOConnection::GenID() IS DESIGNED, IT SEEMS, IN SUCH A WAY AS TO AVOID ANY TRANSACTIONAL FAILURE AT THE
				DATABASE LEVEL AND THE SERVER LEVEL. THERE ARE TWO SITUATIONS. 
				
				ONE A TRASACTION WAS ALREADY STARTED AND THEN ADOConnection::GenID() WAS CALLED AT SOME POINT. 
				THE CODE INSIDE ADOConnection::GenID() TRIES TO HIDE ANY ERRORS THAT ARISE FROM THIS AT THE SERVER LEVEL 
				BY MODIFYING THE $raiseErrorFn WHICH CAN HOLD EITHER THE VALUE OF ADODB_TransMonitor(), OR THE VALUE SET 
				ON THE CONSTANT ADODB_ERROR_HANDLER WHICH WOULD BE A STRING CONTAINING A FUNCTION NAME, OR A 
				USER DEFINED VALUE PASSED THROUGH ADOConnection::StartTrans(). HOWEVER, AN ISSUE REMAINS IF THE 
				DATABASE ITSELF DOES SOMETHING ON FAILURE. THE DRIVERS "adodb-ado_mssql.inc.php" AND 
				"adodb-mssql.inc.php" END UP STARTING NEW TRANSACTIONS AS TO AVOID THE FAILURE OF THE ENTIRE 
				TRANSACTION IF ADOConnection::GenID() HAPPENS TO FAIL. THEY DO THIS IN THE CODE OF 
				ADOConnection::CreateSequence(), WHICH ADOConnection::GenID() IS EXPECTED TO CALL. FOR MORE 
				INFORMATION, SEE THE COMMITS STARTING AT (7/25/2015 3:32:54 PM).
				
				TWO, A TRANSACTION BEGINS AFTER THE ADOConnection::GenID() IS CALLED, BUT THE END RESULT IS STILL THE
				SAME AS ABOVE. HENCE THE BEHAVIOR OF THE AFORE MENTIONED DRIVERS THAT ARE ABLE TO ENCAPSULTE A SUB PART
				OF A BIGGER TRANSACTION WITHOUT AFFECTING THE ENTIRE TRANSACTION.
				
				FURTHERMORE ADOConnection::GenID() WAS NORMALIZED TO NOT OUTPUT AN ERROR MESSAGE ON ERROR, WHICH IS
				PER APPARANT SPECIFICATION. THIS ONLY AFFECTED THE DRIVER  "adodb-ads.inc.php". ADOConnection::GenID()
				WAS ALSO NORMALIZED TO RETURN A POSITIVE NUMBER, OR ZERO ON ERROR. THESE AFFECT THE MSSQL DRIVERS.
				
				SOME TRACES OF ADOConnection::GenID() STILL EXIST IN SOME DRIVERS DUE TO
						"due to the existence of a loop that continuously tries to do the GenID() operation for a 
						number of times on failure before finally failing completely. These particular traces 
						however continue to rely on the core ADOConnection::GenID(), and hence continue to follow
						specification" MESSAGE OF COMMIT (8/9/2015 2:12:13 PM)
		- IN THIS FORK, ADOConnection::DropSequence(), ADOConnection::CreateSequence() DO NOT OUTPUT ERRORS ON ERROR.
				THIS WAS AGAINST APPARANT SPECIFICATION. SEE COMMIT (8/23/2015 2:11:21 PM) FOR MORE DETAILS.
		- IN THIS FORK, ADOConnection::MetaPrimaryKeys() WAS FIXED IN A NUMBER OF DRIVERS TO ENSURE COMPLIANT FUNCTION
				SIGNATURE. THIS AFFECTED "adodb-ibase.inc.php" AND "adodb-oci8.inc.php".
		- IN THIS FORK, ADOConnection::MetaColumns() WAS FIXED IN A NUMBER OF DRIVERS TO ENSURE COMPLIANT FUNCTION
				SIGNATURE. THIS AFFECTED "adodb-mssqlnative.inc.php".
		- IN THIS FORK, ADOConnection::_findschema() WAS REMOVED. THIS FUNCTION ACCEPTED A TABLE NAME THAT MIGHT
				CONTAIN A SCHEMA PART, AND ACCEPTED ANOTHER PARAMETER TO RETURN THE SCHEMA ON. THE TABLE NAME
				PARAMATER WAS ALSO MODIFIED TO CONTAIN ONLY THE TABLE.
		- IN THIS FORK, ADOConnection::$nameQuote IS EXPECTED TO BE SET BY THE ADODB_DataDict CLASSES, AND NOT BY THE
				SUBCLASSES OF ADOConnection, IN OTHER WORDS, THE DRIVERS. HENCE IN THIS FORK, THERE IS A CLASS MEMBER
				ADODB_DataDict::$nameQuote
		- NOTE THAT CONSTRUCTORS ARE INHERITED IN PHP, AND THE CODE FOLLOWS THE MAIN FORK IN TAKING ADVANTAGE
				OF THIS. THIS IS AGAINST MY FORMULATIONS, AND THE PERTAINING NORMAL FORM, BUT IS KEPT TO KEEP
				THE DIFFERENCES SMALL WITH THE MAIN FORK. SEE COMMIT (2/26/2016 11:48:37 AM)
		- PERTAINING TO FETCH MODE:
			- IN THIS FORK, ADOConnection::fetchMode WAS NORMALIZED TO ONLY HOLD THE OFFICIAL VALUES. PART OF THIS
					NORMALIZATION WAS THE INTRODUCTION OF THE FUNCTION mysql_getDriverFetchMode() FOR THE MYSQL DRIVER,
					AND THE FUNCTION  mysqli_getDriverFetchMode() FOR THE MYSQLI DRIVER, AND THE FUNCTION
					oci8_getDriverFetchAndOthersMode() FOR THE OCI8 DRIVER AND THE OCI8PO DIRVER, AND THE FUNCTION
					pdo_getDriverFetchMode() FOR THE PDO DRIVERS, AND THE postgres64_getDriverFetchMode FOR THE
					POSTRGRES64 DRIVER AND THE POSTGRESS 7 DRIVER, AND THE FUNCTION sqlite_getDriverFetchMode() FOR
					THE SQLITE DRIVER AND SQLITEPO DRIVER, AND THE FUNCTION sqlite3_getDriverFetchMode FOR THE SQLITE3 
					DRIVER, AND THE FUNCTION fbsql_getDriverFetchMode() FOR THE FBSQL DRIVER, 
					THESE FUNCTIONS ALSO REMOVED MUCH EVALUATION CODE IN THE CONSTRUCTORS THAT WOULD DO THE FECTH MODE
					CONVERSION THEMSELVES, AND STORE THE CONVERTED, DRIVER SPECIFIC, VALUE TO ADOConnection::fetchMode.
					IN THIS FORK THESE FUNCTION INSTEAD DO THE CONVERSION AT THE LAST POINT, KEEPING THE ADODB STANDARD
					VALUE IN ADOConnection::fetchMode.
					THIS CORRECTED THE APPLICATION OF $ADODB_FETCH_MODE, AND NORMALIZED THE SIGNATURE OF SetFetchMode() 
					
					VALID VALUES ARE: ADODB_FETCH_DEFAULT, ADODB_FETCH_NUM, ADODB_FETCH_ASSOC, ADODB_FETCH_BOTH
					WHICH ARE PHP CONSTANTS, AND ARE BIT FIELDS.
			- IN THIS FORK, ADOConnection::SetFetchMode2() WAS INTRODUCED AND DEFINED TO REPLACE A LOT OF DRIVER CODE THAT
					WHEN DOING QUERIES WOULD CHANGE THE FETCH MODE TO WHAT THEY NEEDED, THEN CHANGE IT BACK TO WHAT IT WAS. 
					ADOConnection::SetFetchMode2() IS SIMILAR TO ADOConnection::SetFetchMode() EXCEPT THAT 
					ADOConnection::SetFetchMode2() RETURNS THE PREVIOUS VALUE OF ADOConnection::fetchMode, WHILE 
					ADOConnection::SetFetchMode() WILL RETURN ADODB_FETCH_MODE IF ADOConnection::fetchMode WAS NOT SET.
					
					LATER, HOWEVER, IN THE DEFAULT CONSTRUCTOR OF ADOConnection ADOConnection::fetchMode WAS SET ACCOUNTING
					FOR $ADODB_FETCH_MODE. HENCE IT SHOULD NEVER HAVE THE false VALUE, BUT BECAUSE THE VARIABLE IS PUBLIC,
					CODE STILL HAS TO ACCOUNT FOR SUCH VALUE. HOWEVER THIS DID MEAN THAT CONSTRUCTORS FOR VARIOUS DRIVERS
					NO LONGER NEEDED TO ACCOUNT FOR $ADODB_FETCH_MODE, AND DRIVER THAT WERE NOT ACCOUNTING WERE NOW
					ACCOUNTING. SEE COMMITS STARTING FROM COMMIT (3/21/2016 11:07:43 AM)
					
					IN THIS FORK  ::ADODB_FETCH_MODE  MUST NOT BE USED WITHIN DRIVERS.
			- IN THIS FORK, THE FUNCTION ADOConnection::GetFetchMode() WAS INTRODUCED TO GET ADOConnection::fetchMode.
					ADOConnection::fetchMode IS TO BE TREATED AS IF PRIVATE, BUT IS KEPT PUBLIC FOR COMPATIBILITY.
					NOTE THAT ADOConnection::GetFetchMode() RETURNS THE EFFECTIVE FETCH MODE, ACCOUNTING FOR A VALUE OF
					false FOR ADOConnection::fetchMode. USE ADOConnection::GetFetchMode() WHEN CREATING INSTANCES OF
					ADORecordSet. NOTE THAT UNLIKE, ADOConnection::fetchMode, ADORecordSet::fetchMode DOES NOT ALLOW
					false.
			- IN THIS FORK, ADOConnection::MetaColumns() WAS FIXED TO OBEY THE ADOConnection::fetchMode VARIABLE, WHERE
					BEFORE THEY ONLY FOLLOWED THE ::ADODB_FETCH_MODE VALUE. SEE COMMIT (3/25/2016 7:35:06 AM) FOR DETAILS.
			- IN THIS FORK, ADOConnection::MetaColumns() WERE FIXED IN A NUMBER OF DRIVERS TO SET THE RETURN PER THE
					ADOConnection::fetchMode. AFFECTED DRIVERS ARE adodb-ado_mssql.inc.php, adodb-ado5.inc.php,
					adodb-db2.inc.php, adodb-fbsql.inc.php, adodb-informix72.inc.php, adodb-odbc.inc.php,
					adodb-odbc_sapdb.inc.php, adodb-odbtp.inc.php, AND adodb-sybase_ase.inc.php. SEE
					COMMIT (3/25/2016 9:39:25 AM)
					BECAUSE OF THE ABOVE, ADODB AXML IS MUCH MORE STABLE IN THIS FORK. SEE COMMIT (3/25/2016 10:56:24 AM).
		- THE MAIN FORK CHANGED THE ADOConnection::GetAssoc() FUNCTION AT SOME POINT, AND THIS COMMIT REVERTED TO ITS
				OWN OLD FIXED FUNCTION. THE FUNCTION IN THE MAIN FORK DOES NOT WORK. THE NEW VERSION OF THE FUNCTION
				INTRODUCED IN THE MAIN FORK ALSO CHANGED ITS SIGNATURE. THIS ALSO MEANS THE FUNCTIONS
				ADOConnection::walkGetAssocKeys() DOES NOT EXIST IN THIS FORK.
		- IN THIS FORK, THE FUNCTION ADOConnection::Fields() WAS NORMALIZED, AND ONLY NEED DRIVERS TO OVERRIDE IT
				IF THEY PROVIDE NO SUPPORT FOR ADODB_FETCH_ASSOC MODE, WHETHER NATIVE OR EMULATED. SEE
				COMMIT  (3/31/2016 10:35:36 AM)
		- IN THIS FORK, ADOConnection::nameQuote DOES NOT NECESSARY REPRESENT A SYMETRIC QUOTATION. CODE SHOULD
				USE ADOConnection::ForceNameQuote() FOR QUOTING UNQUOTED IDENTIFIER NAMES.
				ADOConnection::ForceNameQuote() WAS INTRODUCED IN THIS FORK.
	- PDO DRIVERS
		- IN THIS FORK THE PDO DRIVERS ANTI PATTERN IS FIXED, AND WITH THIS, PDO DRIVERS DO NOT NEED
				SPECIAL TREATMENT EVERY WHERE LIKE IN THE OFFICIAL FORK. ONE OF THE ISSUES FIXED WAS THE NORMALIZATION
				OF ADOConnection::$databaseType.
			- IN THIS FORK, THE PDO DRIVER CLASS VARIABLE _driver WAS REMOVED.
			- IN THIS FORK, ONE WOULD USE THE FORMAT pdo_x FOR THE DRIVERS. SEE COMMIT (8/5/2016 8:48:49 AM)
			- IN THIS FORK, ADODB_pdo::$dsnType IS MADE PROTECTED, NOT PUBLIC, AND ALL USES OF IT OUTSIDE
					OF THE BASE PDO DRIVER, AND ITS ASSIGNMENT IN THE OTHER PDO DRIVERS, IN ADODB HAVE BEEN
					REMOVED.
			- THE ANTI PATTERN THAT EXISTED IN THE MAIN FORK FOR PDO CONSISTED OF THE MAIN PDO DRIVER ENCAPSULATING AN INSTANCE
					OF A SPCIAILIZED PDO DRIVER. THIS FORK FIXED THIS, AND NOW THE SPECIALIZED PDO DRIVERS INHERIT
					THE MAIN PDO DRIVER.
		- IN THIS FORK, PDO DRIVERS ARE FIXED TO ALLOW THEM TO WORK WITH ADODB AXMLS. THIS INCLUDES ADDING A _MetaIndexes()
				FUNCTION FOR EACH OF THE DRIVERS
		- IN THIS FORK, PDO DRIVERS ARE GIVEN THE FUNCTION event_pdoConnectionEstablished() TO ALLOW DIFFERENT PDO DRIVER
				TO DO DRIVER SPECIFIC ACTIVITY ONCE A CONNECTION IS MADE.
		- IN THIS FORK, THE SPEICIALIZED PDO DRIVERS THEMSELVES SET THE PROPERTY ADODB_pdo::$dsnType
		- IN THIS FORK THE PLAIN PDO DRIVER SHOULD NOT BE USED, AND IS SIMPLY A BASE DRIVER FOR ALL OTHER PDO DRIVERS.
	- SQLITE DRIVERS:
		- IN THIS FORK, SQLITE AUTOMATICALLY CREATED INDICES ARE ACCOUNTED FOR TO AVOID ERRORS. SEE COMMIT
				(7/2/2015 9:49:04 AM) AND THE COMMIT AFTER.
	- MYSQL DRIVERS:
		- IN THIS FORK, AND PERTAINING TO THE "adodb-mysql.inc.php" DRIVER, THE FUNCTION ADOConnection::GenID() 
				EFFECTIVELY NO LONGER MAKES USE OF THE PHP FUNCTION mysql_insert_id() WHICH IS COMMENTED OUT
				FOR SOME REASON IN THE FUNCTION OVERRIDING ADOConnection::_insertid() IN THAT DRIVER , AND INSTEAD
				USES THE MYSQL SQL FUNCTION LAST_INSERT_ID(). MY NOTES FOR THE  COMMIT (8/9/2015 2:12:13 PM) 
				STATE THAT MY CHANGES PERTAINING TO ADOConnection::GenID() WERE SUCH AS IF 
				ADOConnection::_insertid() GOES BACK TO USING LAST_INSERT_ID(), THE OLD BEHAVIOR WHERE 
				ADOConnection::GenID() WAS USING mysql_insert_id(), IS RESTORED.
	- MMSSQL DRIVERS:
		- IN THIS FORK, THE DRIVER adodb-mssqlnative.inc.php, HAS THE VARIABLE $sequences REMOVED, WHICH I THINK WAS A
				CACHING MECHANISM OF SORT. THE VARIABLE WAS REMOVED TO ALLOW FACTORING.
		- IN THIS FORK, ADOConnection::MetaColumns() AND ADOConnection::MetaTables() FUNCTIONALITY TO MSSQL DRIVERS THAT
				DID NOT HAVE THEM.
	- FIRBIRD DRIVERS:
		- IN THIS FORK ChangeTableSQL() WAS ADDED TO THE FIREBIRD DRIVER TO SUPPORT ADODB AXMLS, AND SUPPORT WAS IMPROVED
				FOR IT IN THE SQLITE DRIVER. SEE COMMIT (4/18/2016 7:42:30 AM)
- ABOUT RECORD SETS:
	- IN THIS FORK ADORecordSet::adodbFetchMode WAS REMOVED.
	- IN THIS FORK, ADORecordSet CONSTRUCTOR EXPECTS ANOTHER PARAMETER FOR THE FETCH MODE. SEE
			COMMIT (3/15/2016 4:02:05 PM), AND COMMIT (3/23/2016 10:50:31 AM)
	- IN THIS FORK, THE FUNCTION ADORecordSet::_updatefields() HAS BEEN REMOVED.
			THE FUNCTION WAS CONVERTING THE KEY CASING OF THE VARIABLE ADORecordSet::$fields TO WHAT WAS SET BY THE
			USER I THINK. ALSO ADORecordSet::fields IS EXPECTED TO "HOLD THE RAW DATA FROM THE DRIVER".
			SEE COMMIT (3/31/2016 2:10:10 PM).
			
			IN THIS FORK, ADORecordSet::AssocCaseConvertFunction() WAS ALSO REMOVED.
	- IN THIS FORK, ADORecordSet::fields MUST NOT BE USED TO RETRIVE THE DATA USING ASSOCIATIVE KEYS. ONE MUST
			USE ADORecordSet::Fields() INSTEAD.
	- IN THIS FORK, ADORecordSet::Fields() IS CASE INSENSITIVE. THIS MEANS THAT IN THIS FORK, WHEN USING ADODB,
			NO TWO COLUMNS OF A  DATABASE TABLE MAY HAVE THE SAME NAME, CASE INDEPENDENT. THIS MAY OR MAY NOT 
			BE A PROBLEM DEPENDING ON THE DATABASE.
	- ADORecordSet::$bind ASSOCIATES NORMALIZED ASSOCIATIVE KEYS TO THE ENTRIES OF $fields WHICH MAY OR MAY NOT BE 
			KEYED ASSOCIATIVELY. IT MUST ASLO BE SET TO FALSE WHENEVER $fields IS CHANGED.
	- IN THIS FORK, THE VARIABLE ADORecordSet::$fromBindKeysToColumnNames WAS INTRODUCED. IT ASSOCIATES THE KEYS OF 
			ADORecordSet::$bind, WHICH ARE NORMALIZED, TO THE ORIGINAL COLUMN NAMES, AND IT IS INVALID IF 
			ADORecordSet::$bind IS false. ALSO SEE GetAssocKeys()
	- IN THIS FORK GetAssocKeys() DOES NOT ACCEPT A PARAMETER. IT ALSO HALTS THE APPLICATION IF A DATA
			ARRAY FROM THE DATABASE IS DETECTED TO HAVE A CONFLICT OF KEYS WHEN THE ARRAY IS BOTH NUMERIC AND
			ASSOCIATIVE.
	- ADORecordSet::fetchMode IS NOT THE SAME AS ADOConnection::fetchMode. ADORecordSet::fetchMode SIMPLY CAPTURES
			THE FETCH MODE WHEN THE RECORD SET WAS CREATED. I FORGET WHETHER THIS WAS ALSO INTENDED IN THE MAIN FORK,
			BUT ATLEAST IN THIS FORK, THIS IS GUARANTEED BY THE CHANGE OF THE CONSTRUCTOR OF ADORecordSet. IN THIS
			FORK DETECTION OF THE INTERNAL ARRAY TYPE OF THE VARIABLE HOLDING THE DATABASE ROW DATA WAS NO LONGER
			NEED BEAUSE THE RECORD SET SIMPLY KNOWS. IN THIS FORK, ADORecordSet::fetchMode IS READONLY TO
			FUNCTIONS NOT PART OF ADORecordSet OR ITS SUB CLASSES.
	- IN THIS FORK Both ADORecordSet::GetAssocKeys() AND ADORecordSet::GetRowAssoc() SHOULD NOW WORK PER APPARENT
			SPECIFICATION IN ALL FETCH MODES.
	- THE FUNCTION ADORecordSet::GetRowAssoc() IS FOR EMULATING ASSOCIATED ARRAY RETRIEVAL WHEN THE DATABASE NATIVE
			DRIVER DOES NOT SUPPORT IT.
			IN THIS FORK, ADORecordSet::GetEmulatedRowAssoc() WAS INTRODUCED TO REPLACE ADORecordSet::GetRowAssoc().
			IN THIS FORK, ADORecordSet::GetRowAssoc() SHOULD NO LONGER BE USED.
	- IN THIS FORK, ADODB_FETCH_DEFAULT EVALUATES TO ADODB_FETCH_BOTH. THIS IS IMPORTANT FOR CLIENT CODE TO NOTE
			IF THE DRIVER THEY ARE USING DOES NOT SUPPORT EITHER OF ADODB_FETCH_NUM OR ADODB_FETCH_ASSOC.
	- ADORecordSet::GetAssocKeys() AND ADORecordSet::GetRowAssoc() ARE NOT MEANT TO BE PUBLIC.
			
			
- ABOUT ACTIVE RECORD IN THIS FORK:
	- SWITCHED TO USING AN INTERNAL DATA ARRAY, ADODB_Active_Record::$_data ON THE ACTIVE RECORD FOR DATABASE 
			TABLE FIELDS, INSTEAD OF PROPERTIES ON THE OBJECT ITSELF TO ALLOW PROPER OOP WHEN NEEDED.
	- ADDED SUPPORT FOR TABLE PREFIXING USING THE STATIC VARIABLE ADODB_Active_Record::$_tablePrefix.
			THIS VARIABLE IS CAPTURED WHEN INSTANCES OF THE ACTIVE RECORD ARE CREATED ON THE INSTANCE
			VARIABLE ADODB_Active_Record::$_currentRecordPrefix, AND CAN BE CHANGED TO AFFECT NEW INSTANCES.
	- BECAUSE OF THE TABLE PREFIX, INTERNALLY, ONE MUST USE ADODB_Active_Record::GetTableName(), INSTEAD OF
			ADODB_Active_Record::_table
	- THE TABLE PREFIXING MIRRORS AN ALREADY EXISTING FEATURE IN ADODB AXMLS. HENCE THE RULES FOR WHAT PREFIX
			IS ACCEPTED FOLLOWS THOSE IN ADODB AXMLS. SEE adodb_active_GetTableNamePrefix(), 
			adoSchema::SetPrefix()

- ABOUT ADODB DATA DICTIONARY:
	- DATA DICTIONARY APPEARS TO HAVE BEEN MADE FOR ADODB SCHEMA.
	- IN THIS FORK DATA DICTIONARY IS SET AS ONE ENTRY FOR EACH DATABASE, AND NOT ONE FOR EACH DRIVER. THIS WAS
			DEDUCED FROM THE APPARANT SPEICIFCATION. HENCE, DATA DICTIONARIES SPECIFIC TO DRIVERS WERE REMOVED, 
			BUT THEIR CODE CAREFULY MERGED TO THE CORRECT DATA DICTIONARY.
	- IN THIS FORK EACH DRIVER INSTANCE HAS A DATA DICTIONARY INSTANCE ASSOCIATED WITH IT USING THE VARIABLE
			ADOConnection::_dataDict. IN TURN THE THE DATA DICTIONARY INSTANCE HAS A REFERENCE TO THE DRIVER
			CONTAINING IT. THIS IS SET BY THE FUNCTION DEFINED IN THIS FORK, ADODB_DataDict::SetConnection()
	- IN THIS FORK EACH DATA DICTIONARY BUILD ITSELF AN INFORMATION ASSCOIATIVE ARRAY ABOUT THE DATABASE ITSELF.
			THIS HAPPENS ONLY WHEN A DRIVER IS ATTACHED USING ADODB_DataDict::SetConnection(), AND THE ARRAY
			IS BUILT USING ADOConnection::ServerInfo()
	- IN THIS FORK, THE FUNCTION ADODB_DataDict::event_connectionSet() IS INTRODUCED TO LET DICTIONARIES
			SET PARAMETERS BASED ON THE DRIVERS ASSOCIATED. THE FUNCTION IS CALLED WHEN THE DRIVER IS SET.
	- IN THIS FORK, A LOT OF FACTORING WAS DONE IN THE DIFFERENET DATA DICTIONARIES SUCH AS CLASSES DEFINE
			ONLY WHAT IS CHANGED FROM THE BASE CLASS, AND SQL CODE IS REMOVED FROM THE DRIVERS TO THE
			DICTIONARIES. SEE COMMIT  (7/18/2015 2:11:10 PM).
		- ADOConnection::$concat_operator, ADOConnection::sysDate, ADOConnection::sysTimeStamp, 
				WHICH PERTAIN TO ADOConnection::SQLDate(). THESE WERE MOVED TO THE DATA DICTIONARIES UNDER THE
				NAMES "sql_sysTimeStamp", "sql_sysDate", AND "$sql_concatenateOperator", AND ARE COPIED 
				FROM THE DATA DICTIONARIES DURING SET UP. HENCE THESE MUST NOT BE SET IN THE DRIVERS, BUT 
				BE SET ON THE CORRESPONDING VARIABLE IN THE DICTIONARIES.
				SEE ADODB_DataDict::SetConnection().
		- ADOConnection::$nameQuote IS COPIED FROM THE DATA DICTIONARIES, UNDER "ADODB_DataDict::nameQuote", 
				AND MUST NOT BE SET IN THE DRIVERS, BUT INSTEAD SET IN THE DATA DICTIONARIES.
				SEE ADODB_DataDict::SetConnection().
		- ADOConnection::$sysUTimeStamp WAS DELETED.
	- IN THIS FORK FUNCTIONS ENDING WITH 'SQL' INSIDE THE ADODB DATA DICTIONARY CLASSES, WERE INTRODUCED AND
			ARE FUNCTIONS MEANT TO PRODUCE SQL STRING ARRAYS. FUNCTIONS INTRODUCED INCLUDE:
		- FormatDateSQL(), _FormatDateSQL(): _FormatDateSQL() IS TO REPLACE THE DIRECT OVERRIDE OF SQLDate()
				IN ADOConnection, MEANING THE DRIVERS. OVERRIDING SHOULD HAPPEN IN THE DATA DICTIONARY SUBCLASSES
				THAT SHOULD OVERRIDE _FormatDateSQL() INSTEAD. FormatDateSQL(), WHICH CALLS _FormatDateSQL(), 
				ACCEPTS A COLUMN NAME IN THE FORMAT DEFINED IN ADODB_DataDict::ParseIdentifierName().
		- RowLockSQL(): IS TO REPLACE THE DIRECT OVERRIDE OF RowLock() IN ADOConnection, MEANING THE DRIVERS.
				OVERRIDING SHOULD HAPPEN IN THE DATA DICTIONARY SUBCLASSES THAT SHOULD OVERRIDE
				RowLockSQL() INSTEAD. RowLockSQL DOES NOT CURRENTLY ACCEPT THE FORMAT DEFINED IN 
				ADODB_DataDict::ParseIdentifierName() BECAUSE ADOConnection::RowLock() ACCEPTS A "TABLE
				NAME SQL SEGMENT" WHICH IS THE PART OF THE SQL CONTAINING ONE OR MORE TABLES, WHICH IS
				CONTRARY TO THE DEFINITION IN THE DOCUMENTATIONS. BECAUSE ALL DRIVERS EXCEPT ONE, IT IS
				TABLES INSTEAD OF TABLE, THIS FORK GOES BY THAT DEFINITION FOR ADOConnection::RowLock()
		- CreateSequenceSQL(), _CreateSequenceSQL(): _CreateSequenceSQL() IS TO REPLACE THE DIRECT OVERRIDING
				OF CreateSequence() IN ADOConnection, MEANING THE DRIVERS. OVERRIDING SHOULD HAPPEN IN THE
				DATA DICTIONARY SUBCLASSES WHICH SHOULD OVERRIDE _CreateSequenceSQL(). THE pSequenceName PARAMETER
				OF CreateSequence ACCEPT THE FORMAT DEFINED IN  ADODB_DataDict::ParseIdentifierName()
				IN RELATION, THE VARIABLE ADOConnection::_genSeqSQL WAS REMOVED IN THIS FORK.
		- DropSequenceSQL(), _DropSequenceSQL(): _DropSequenceSQL() IS TO REPLACE THE DIRECT OVERRIDING
				OF DropSequence() IN ADOConnection, MEANING THE DRIVERS. OVERRIDING SHOULD HAPPEN IN THE
				DATA DICTIONARY SUBCLASSES WHICH SHOULD OVERRIDE _DropSequenceSQL(). THE pSequenceName PARAMETER
				OF DropSequence ACCEPT THE FORMAT DEFINED IN  ADODB_DataDict::ParseIdentifierName()
				IN RELATION, THE VARIABLE ADOConnection::_dropSeqSQL WAS REMOVED IN THIS FORK.
		- GenIDSQL(), _GenIDSQL(), _event_GenID_calculateAndSetGenID: _GenIDSQL() IS TO REPLACE THE DIRECT OVERRIDING
				OF GenID() IN ADOConnection, MEANING THE DRIVERS. OVERRIDING SHOULD HAPPEN IN THE
				DATA DICTIONARY SUBCLASSES WHICH SHOULD OVERRIDE _GenIDSQL(). THE pSequenceName PARAMETER
				OF DropSequence ACCEPTS THE FORMAT DEFINED IN  ADODB_DataDict::ParseIdentifierName().
				IN RELATION, THE VARIABLE ADOConnection::_genIDSQL WAS REMOVED IN THIS FORK.
	- IN THIS FORK DATA DICTIONARIES SHOULD CONTAIN ALL SQL GENERATION FUNCTION, AND THE DRIVERS SHOULD CONTAIN
			NON. THE DATA DICTIONARIES SHOULD NOT EXECUTE THE SQL STATEMENTS, BUT THE DRIVERS DO.
	- IN THIS FORK THE schema PARAMATER OF ADODB_DataDict::MetaColumns() WAS REMOVED. THE PARAMETER WAS NOT
			USED ANYWHERE. THIS IS LIKELY RETLATED TO THE NORMALIZATION OF THE SIGNATURE OF 
			ADOConnection::MetaColumns(), AND IN PARTICULAR THE MSSQLNATIVE DRIVER WHICH HAD THE PARAMETER,
			WHICH WAS NOT PER APPARANT SPEICIFCATION.
		- IN THIS FORK IT IS MADE CLEAR, AND ENFORCED THAT THE RETURN OF THIS FUNCTION, WHICH IS AN ARRAY,
				IS NUMERICALLY INDEXED ONLY IF THE FETCH MODE IS ADODB_FETCH_NUM, OTHERWISE IT IS ONLY
				ASSOCIATIVELY INDEXED AND WITH THE KEYS UPPER CASED.
	- IN THIS FORK, VARIABLES WERE INTRODUCED TO ADODB_DataDict THAT WOULD BE COPIED OVER TO THE DRIVER CLASSES.
			THEY ARE OF THE FORM $sql_nameOfVariableInTheDriver. THESE INCLUDE,  
	- IN THIS FORK POSTGRES DATA DICTIONARY HAS A CHANGE TABLE SQL FOR VERSIONS 8 AND UP FOR POSTGRES.
	
	
ABOUT ADO FIELD OBJECTS:
	- IN THIS FORK, THE FUCNTION ADOFieldObject::FillFromObject() WAS DEFINED TEMPORARILY TO FIX DRIVERS THAT WERE
			WERE NOT RETURNING AN INSTANCE OF ADOFieldObject FOR THEIR IMPLEMENTATION OF 
			ADOConnection::FetchField(). SEE COMMIT (3/30/2016 2:34:06 PM).
	
	
	
- IN THIS FORK THERE ARE FUNCTIONS KNOWN AS THE "META FAMILY OF FUNCTIONS".
	- THESE ARE: ADODB_DataDict::MetaColumns(), ADODB_DataDict::MetaPrimaryKeys, ADODB_DataDict::MetaIndexes,
			AND THEIR EQVUIVILANT FUNCTIONS ON ADOConnection, AS WELL AS ADOConnection::MetaColumnNames().
	- THE "META FAMILY OF FUNCTIONS" FOUND ON ADODB_DataDict ARE EXPECTED TO CALL THEIR EQUIVILANT ON
			ADOConnection
	- THESE FUNCTIONS ACCEPT TABLE NAMES IN THE FORMAT DEFINED IN ADODB_DataDict::ParseIdentifierName() 
			WHICH IS DEFINED IN THIS FORK. THE FORMAT IS DEFINED SUCH AS TO RETAIN BACKWARD COMPATIBILITY.
			IT IS STRONGLY RECOMMENDED TO NORMALIZE TABLE NAMES BASED ON WHETHER THE DATABASE IS CASE SENSITIVE
			WITH QUOTATION OR NOT. YOU WILL FIND MUCH CODE OF THE FOLLOWING FORMAT:
					$table = $this->NormaliseIdentifierNameIf((!$pParsedTableName['table']['isToQuote'] ||
							$pParsedTableName['table']['isToNormalize']),
							$pParsedTableName['table']['name']);
			THIS IS ONLY FOUND IN THE LEGACY DB2 DRIVER THAT THIS FORK INTRODUCED, IN THE pdo_oci, odbc_oracle
			AND oci8, DRIVERS.
			OR
					$table = $this->NormaliseIdentifierNameIf($pParsedTableName['table']['isToNormalize'],
							$pParsedTableName['table']['name']);
			WHICH IS FOUND EVERYWHERE ELSE.
			
			I THINK THE REASON BEHIND THE FIRST FORM WAS BECAUSE THE DRIVER WAS ALWAYS NORMALIZING, AND HENCE
			TO KEEP BACKWARD COMPATIBILITY, NORMALIZATION WAS DONE WHEN THE NAME WAS NOT QUOTED. REMEMBER THAT
			QUOTATION SUPPORT FROM THE SYNTAX INTRDOCUED IN THIS FORK BY THE FORMAT DEFINED IN
			ADODB_DataDict::ParseIdentifierName()
	- NOTICE HOW THE table PARAMETERS, ARE NOT PURE TABLE NAMES, BUT ARE IN THE FORMAT  DEFINED IN
			ADODB_DataDict::ParseIdentifierName().
	- THE FUNCTIONS MUST NOT MODIFY THE CASE OF RETURNED DATA FROM THE DATABASE. THE DATA MUST REMAIN
			IN ITS CASE AS RETURNED. SENSITIVITY IS CONSIDERED FOR THE TABLE NAMES BECAUSE
			IT IS EVENTUALLY AN INTPUT TO THE DATABASE THROUGH SQL AND DRIVER FUNCTIONS, NOT AN OUTPUT FROM
			FROM THE DATABASE.
	- GENERALY IMPLEMENTING DRIVERS MUST NOT IMPLEMENT THESE FUNCTIONS, BUT INSTEAD IMPLEMENT
			THE FUNCTIONS WITH THE SAME NAME THAT ARE PROTECTED AND START WITH UNDERSCORE. SO INSTEAD
			OF IMPLEMENTING ADOConnection::MetaColumns(), SUB CLASSES MUST IMPLEMENT
			ADOConnection::_MetaColumns(). THESE UNDERSCORED FUNCTIONS NO LONGER WORRY ABOUT THE "isNotToNormalize"
			PARAMETER, AND INSTEAD FOLLOW THE INSTRUCTION IN THE PARSED TABLE NAME DATA STRUCTURE. SEE THE CODE.
			AS FOR WHAT THE DRIVERS DO WITH THESE INSTRUCTIONS, HOWEVER, IS SUCH AS THEY REMAIN BACKWARD COMPATIBLE.
			ALSO NOTICE THAT "isNotToNormalize" NOW USES A DEFAULT VALUE OF NULL INSTEAD OF TRUE OR FALSE.
	- NOT ALL FUNCTION STARTING WITH Meta ARE PART OF THE "META FAMILY OF FUNCTIONS". IDEALLY, THEY PROBABLY ALL
			SHOULD BE. WHAT FUNCTIONS MADE IT INTO THE FAMILY ARE THOSE THAT ARE EVENTUALLY READING RAW XML ATTRIBUTE
			DATA FROM ADODB AXML. FOR EXAMPLE, ADODB_DataDict::MetaTables() IS NOT PART OF THE FAMILY. THIS FUNCTION
			DOES APPEAR IN ADODB AXML, BUT IS NEVER USED TO READ IN XML, BUT INSTEAD IT IS USED TO EXPORT TO XML.
			AT THE SAME TIME THE FUNCTION IS NOT AFFECTED AT ALL BY THE ISSUES OF NORMALIZATION AND QUOTING.
			SIMLARLY, ADOConnection::MetaForeignKeys() IS NOT PART OF THIS FAMILY, AND DOES NOT EVEN HAVE A COUNTER
			PART IN ADODB_DataDict, ALTHOUGH IT MIGHT NEED ONE IN THE FUTURE, AND ALTHOUGH THE FUNCTION CAN BE
			AFFECTED BY THE ISSUES OF NORMALIZATION AND QUOPTING BECAUSE IT ACCEPTS A $table PARAMATER, IT
			DOES NOT APPEAR AT ALL IN THE CODE OF ADODB AXML.
	- ADOConnection::MetaColumns() FUNCTION, PER APPARANT SPECIFICATION, MUST UPPER CASE THE 
			ASSOCIATIVE KEYS OF THE ARRAY THAT IS RETURNED.
	- The semantics of the "$primary" parameter of ADOConnection::MetaIndexes, and by extension in this
			fork, ADOConnection::_MetaIndexes, is highly irregular. Two interpertations exist, and both
			are popular among drivers. Excluding odbtp and odbc family of drivers, behavior is consistant
			among all drivers for the same database. Including odbtp and odbc family of drivers, behavior
			is consistant among all drivers for the same database except for the drivers of DB2 and MSSql.
			
			UPDATE: IN THIS FORK, ALL INSTANCES OF ADOConnection::MetaIndexes, AND BY EXTENSION
			ADOConnection::_MetaIndexes WERE CHANED TO ONE BEHAVIOR FOR THE "$primary" PARAMETER. THIS
			WAS	AFTER THE OFFICIAL FORK 'FIXED' ONE OF THE DRIVERS. THANKFULY, THIS WAS A DRIVER USING THE
			POPULAR INTERPRETATION. SEE THE SURVEY BELOW. SEE COMMIT (4/24/2021 7:05:53 PM)
			
- IN THE OFFICIAL FORK, ADODB DATA DICTIONARY IS AWARE OF BACK QUOTES, BUT ADODB IS NOT, AND ADODB IS AWARE OF
		CASE NORMALIZATION, BUT DATA DICTIONARY IS NOT. REMEBER THAT IN THIS FORK, 
		ADODB_DataDict::ParseIdentifierName() IS EVENTUALLY AIMED AT ADODB AXMLS, BECAUSE DATA DICTIONARY, 
		JUDGING FROM HISTROY, IS MADE FOR ADODB AXMLS, AND THIS UNDERSTANDING IS A FOUNDATION IN THIS FORK.
		HENCE THE FORMAT DEFINED IN ADODB_DataDict::ParseIdentifierName() IS DEFINED SUCH AS WHEN THE SPECIAL
		FORMS EXISTS, THE ASSUMPTION IS THAT THE CALL IS EVENTUALLY COMING FROM ADODB AXMLS. HENCE WHY ONLY
		"FORM 1", SEE ADODB_DataDict::ParseIdentifierName(), ACKNOLOWDGES THE "isNotToNormalize" PARAMETER.
		ALSO NOTE THAT DATA DICTIONARY AWARE OF BACK QUOTES MEANS THAT ADODB AXMLS SUPPORTED THEM BEFORE THIS FORK.

- IN THIS FORK ADODB PERFORMANCE CLASSEES, adodb_perf, LIKE ADODB DATA DICTIONARY CLASSES, ARE ONE FOR EACH
		DATABASE ENGINE, NOT EACH DATABASE DRIVER. THIS IS PER APPARANT SPECIFICATION.


- THE MAIN FORK INTRODUCED THE CONSTANT ADODB_DEFAULT_METATYPE, AND THIS FORK ACCEPTED. HOWEVER SOME DRIVERS
		STILL NEED CORRECTNG.

- A MAJOR TEST WAS DONE AFTER COMMIT (4/6/2016 12:40:09 PM). THE DRIVERS TESTED WERE:
		mysql, mysqlpo, mysqlt, mysqli, pdo_mysql, sqlite3, pdo_sqlite, postgres7, postgres8, postgres9,
		pdo_pgsql, odbc_mssql, mssqlnative, pdo_sqlsrv, ado_mssql, ado_access, odbc_access.
		THE TESTS PERTAINED TO ADODB, ADODB DATA DICTIONARY, ADODB AXMLS AND ADODB ACTIVE RECORD.
- ADORecordSet::_fetch() WAS NOT A FUNCTION DEFINED IN THE MAIN FORK, BUT YET, DEFINED IN SOME OF THE SUBCLASSES
		IN CERTAIN DRIVERS, AND FURTHER MORE THE CODE OF ADORecordSet DID REFERENCE THE FUNCTION!
		IN THIS FORK, DRIVERS THAT THAT DEFINED _fetch() IN THEIR PERTAINING ADORecordSet SUB CLASSES
		HAD THE FUNCTION RENAMED TO DRIVER_NAME__fetch. THIS AFFECTED adodb-ads.inc.php AND
		adodb-odbc.inc.php. SEE COMMIT (4/6/2016 12:40:09 PM).
- IN THIS FORK, ADOConnection::NormaliseIdentifierNameIf() AND ADOConnection::BuildTableName()
		WERE INTRODUCED TO AID WITH DEALING WITH THE PARSED IDENTITY NAMES. THIS IS USUALLY IN THE META
		FAMILY OF FUNCTIONS. SEE COMMIT (4/8/2016 2:17:15 PM).
- IN THIS FORK, ADODB_DataDict::NormaliseIdentifierName() WAS INTRODUCED. THIS FUNCTION MUST NORMALIZE BASED
		ON THE DATABASE OWN NORMALIZATION BEHAVIOR IF IT EXISTS, OR SIMPLY UPPER CASE. SEE THE FUNCTION'S NOTES.
		SEE COMMIT (4/8/2016 2:17:15 PM).
- IN THIS FORK, THE VARIABLE ADOFieldObject::$type WAS GIVIEN THE DEFINITION,
				"a value understandable by ADORecordSet::MetaType()"
		THIS IS BECUASE SOME IMPLEMENTATIONS OF ADORecordSet::MetaType() UNDERSTAND THE DATABASE NATIVE NAMES 
		OF TYPES, WHILE OTHERS, LIKE THE DEFAULT IMPLEMENTATION, ALSO UNDERSTAND ADODB'S NORMALIZED TYPES. SEE
		COMMIT (4/11/2016 9:03:50 AM)
- IN THIS FORK _generateMetaColumnsSQL() WAS ADDED TO A NUMBER OF DRIVERS TO AID INTERNAL CODE. THIS IS NOT PART
		OF THE MAIN DRIVER CLASS, ADOConnection. SEE COMMIT (5/6/2016 10:24:39 AM) 
- IN THIS FORK ADODB_Session::driver() DEFAULT TO MYSQL IF THE PHP VERSION IS BEFORE 7, OTHERWISE IT DEFAULTS
		TO MYSQLI. IN THE MAIN FORK, THE DEFAULT WAS CHANGED FROM ALWAYS MYSQL TO ALWAYS MYSQLI.
- IN THIS FORK, ADODB_ASSOC_CASE AND $ADODB_ASSOC_CASE  ARE CONSIDERED PARASITIC. DRIVER MUST RETAIN THE
		ORIGINAL CASE OF FIELDS. THESE SOLVE NO ISSUE IN THIS FORK BECAUSE IN THIS FORK 
		ADORecordSet::Fields() IS CASE INSENSITIVE. VIOLATIONS WERE REMOVED. SOME CONSEQUENCES OF THIS IN THIS
		FORK INCLUDE:
				- THE CLASS ADORecordSet_assoc_postgres7 WAS REMOVED.
				- THE CLASS ADORecordSet_assoc_postgres8 WAS REMOVED.
				- THE CLASS ADORecordSet_assoc_postgres9 WAS REMOVED.
				
		IN THIS FORK, THE CONSTANT ADODB_ASSOC_CASE WAS FULLY REMOVED, BUT NOT THE VARIABLE $ADODB_ASSOC_CASE.
		
		IN THIS FORK, ALTHOUGH CONSTANTS ADODB_ASSOC_CASE_XXX REMAIN, THEY NO LONGER AFFECT THE RECORD SET
		fields INSTANCE VARIABLE.

		IN THIS FORK, THE DEFAULT VALUE FOR ADOConnection::GetRowAssoc IS ADODB_ASSOC_CASE_UPPER. USERS WHO WANT
		A DIFFERENT VALUE EXPLICITLY ASK FOR ONE, AND CAN NOT RELY ON THE REMOVED ADODB_ASSOC_CASE

		THE OFFICIAL FORK REMOVED $ADODB_ASSOC_CASE AND TURNED IT TO ADODB_ASSOC_CASE. SEE 
		COMMIT (3/31/2021 10:43:12 AM). THIS CHANGE OF SEMANTICS INTRODUCES ALL	SORT OF BUGS, AND THE EVENTUAL
		EXISTANCE OF THE DECISION TO MAKE THIS CHANGE IS A TESTIMONY OF THE FACT THAT ADODB_ASSOC_CASE WAS
		INDEED PARASATIC. SEE COMMIT (4/10/2021 8:34:26 AM) FOR THE FIRST EXAMPLE OF A BUG INTRODUCED
		IN THE MAIN FORK BECAUSE OF THE CHANGE. AFTER THAT OFFICIAL COMMIT, THIS FORK HAS TO BE CAREFUL
		WITH ANY FUTURE MERGING WORK WITH OFFICIAL COMMITS PERTAINING TO ADODB ACTIVE RECORD, AND THE 
		ADODB DICTIONARIES, AND BOTH THEIR DEPENDENCIES FROM THE DRIVERS, SUCH AS THE META FAMILY OF 
		FUNCTIONS.
- IN THIS FORK, THE EXISTENCE OF ADODB_EXTENSION IS NOT DETECTED AS AN ERROR. SEE COMMIT (9/14/2016 1:47:50 PM).
		IT APPEARS THAT THE MAIN FORK incorrectLY associatED the ADODB_ASSOC_CASE_xxx constants with the ADODB php
		extension, BUT I FORGET IF THIS WAS RELATED TO THE DECISION OF KEEPING ADODB_EXTENSION, BUT MY MEMORY SUGGESTS
		YES. SEE COMMIT (9/14/2016 1:40:50 PM)
- ADORecordSet::FetchField() USES -1 TO INDICATE THAT NO VARIABLE WAS PASSED, AND THE BEHAVIOR THEN IS DRIVER
		DEPENDENT. SOME DRIVERS WILL FAIL, AND SOME WILL PASS THE NEXT FIELD, AND SOME WILL PASS THE FIRST
		FIELD.
		IN THIS FORK, ALL PDO DRIVERS RETURN THE FIRST FIELD IF NO VARIABLE WAS PASSED. SEE
		COMMIT (9/16/2016 12:11:54 PM)
- IN THIS FORK ADORecordSet::Init() CAN NO LONGER BE OVERRIDEN. SEE COMMIT (10/13/2016 1:30:45 PM)
- IN THIS FORK ADORecordSet_array HAS BEEN REMOVED APART FROM ITS SIGNATURE. THE CLASS ADORecordSet
		HAS BEEN AMENDED TO DO ITS JOB.

		IN THIS FORK, ADORecordSet::$fields IN THE DRIVER adodb-oci8.inc.php CAN NO LONGER BE EXPECTED TO BE AN ARRAY
		WHEN ADORecordSet::$EOF IS TRUE. THIS IS PER APPARENT SPECIFICATION. SEE COMMIT (10/13/2016 1:30:45 PM)
		
		IN THIS FORK, ADORecordSet HAS A NEW "OPERATION MODE" ADDED TO IT CALLED BUFFER MODE, WHERE UNDER THIS
		MODE THE CLASS ACTS ROUGHLY LIKE THE ADORecordSet_array CLASS. TWO NEW FUNCTIONS WERE INTRODUCED,
		ADORecordSet::SwitchToBufferMode() AND ADORecordSet::InitializeBufferWith(). IN BUFFER MODE
		THE CLASS FULLY FETCHES THE DATA FROM THE DATABASE, SEE ADORecordSet::SwitchToBufferMode(),
		OR FROM PASSED DATA FROM CODE, SEE ADORecordSet::InitializeBufferWith().
		
		SUB CLASSES OF ADORecordSet CONTINUE TO, AND MUST, BE OBLIVIOUS TO BUFFER MODE.
		
		IN THIS FORK, THE FUNCTION ADOConnection::_rs2rs() MUST NO LONGER BE USED, AND ALL TRACES OF USING IT WERE
		REMOVED AND REPLACED WITH CALLS TO ADORecordSet::SwitchToBufferMode(). EVEN ADOConnection::_rs2rs()
		INTERNALLY USES ADORecordSet::SwitchToBufferMode(). HOWEVER THIS CHANGES ITS BEHAVIOR FROM CREATING
		A NEW RECORD SET TO MODIFYING THE PASSED RECORD SET. FOR SIMILAR REASONS, THE FUNCTION
		ADOConnection::Transpose() MODIFIES THE PASSED IN RECORD SET IN THIS FORK, INSTEAD OF CREATING A NEW ONE.
		
		IN THIS FORK, ADOConnection::_initrs() AND ADOConnection_fetch() WERE ADDED FOR SUB CLASSES TO IMPLEMENT.
		
		IN THIS FORK, ADORecordSet::_callFetch() WAS ADDED, AND SUB CLASSES MUST CALL THIS FUNCTION INSTEAD
		OF ADORecordSet::_fetch().
		
		IN THIS ADORecordSet_array, ADORecordSet::$_queryID DEFINITION WAS CHANGED TO 
				"This variable keeps the result link identifier.	-1: indicates unset.  
				false: indicates set but closed or not a resource(used in buffer mode)"
		
		IN THIS FORK, THE VARIABLES ADORecordSet::_isBufferMode, ADORecordSet::_array, ADORecordSet::_fieldobjects,
		ADORecordSet::affectedrows, ADORecordSet::insertid, ADORecordSet::compat WERE ADDED.
		
		IN THIS FORK, ADORecordSet::_initrsForBufferMode WAS ADDED.
		
		IN THIS FORK, ADORecordSet::_seek WAS ADDED FOR CHILD CLASSES TO IMPLEMENT WHEN NEEDED. 
		CHILD CLASSES MAY NOT CALL THIS FUNCTION, AND MUST INSTEAD CALL THE NEWLY ADDED FUNCTION 
		ADORecordSet::_callSeek()
		
		IN THIS FORK ADORecordSet::_GetArrayLimit() WAS ADDED FOR CHILD CLASSES TO IMPLEMENT, INSTEAD OF
		ADORecordSet::GetArrayLimit() WHICH WAS MADE FINAL.
		
		IN THIS FORK ADORecordSet::_MoveFirst() WAS ADDED FOR CHILD CLASSES TO IMPLEMENT, INSTEAD OF
		ADORecordSet::MoveFirst() WHICH WAS MADE FINAL.
		
		IN THIS FORK ADORecordSet::_MoveLast() WAS ADDED FOR CHILD CLASSES TO IMPLEMENT, INSTEAD OF
		ADORecordSet::MoveLast() WHICH WAS MADE FINAL.
		
		IN THIS FORK ADORecordSet::_MoveNext() WAS ADDED FOR CHILD CLASSES TO IMPLEMENT, INSTEAD OF
		ADORecordSet::MoveNext() WHICH WAS MADE FINAL.
		
		IN THIS FORK ADORecordSet::_FetchField() WAS ADDED FOR CHILD CLASSES TO IMPLEMENT, INSTEAD OF
		ADORecordSet::FetchField() WHICH WAS MADE FINAL.

		IN THIS FORK ADORecordSet::_FetchField__bufferMode() FOR SUB CLASSES TO IMPLEMENT. THIS IS NEEDED
		BECAUSE THE BEHAVIOR OF ADORecordSet:FetchField() WHEN NO PARAMETER IS PASSED DIFFERS BETWEEN DRIVERS, 
		AND HENCE DRIVERS THAT WANT CONSISTENT BEHAVIOR IN THEIR OWN IMPLEMENTATION IN NORMAL AND BUFFER MODE
		CAN OVERRIDE ADORecordSet::_FetchField__bufferMode().
		
		IN THIS FORK, ADORecordSet::ReInit() WAS ADDED.
		
		IN THIS FORK ADORecordSet::InitArray(), AND ADORecordSet::InitArrayFields WERE ADDED FOR BACKWARD
		COMPATIBILTY. THEY ESSENTIALLY WERE ON THE ADORecordSet_array CLASS.
		
		
		IN THIS FORK SUB CLASSES OF ADORecordSet_array MUST SET THE DEFAULT FIRST PARAMATER OF THE CONSTRUCTOR
		TO false. THEY MUST ALSO INHERIT FROM THEIR CORRESPONDING DRIVER ADORecordSet.
		
		AN IMPORTANT DIFFERENCE BETWEEN BUFFER MODE, AND THE OLD ADORecordSet_array IMPLEMENTATION IS
		THAT IN THIS FORK, ADORecordSet CAN SWITCH BETWEEN BUFFER MODE AND NORMAL MODE, WHILE IN THE
		ORIGINAL IMPLEMENTATION, ADORecordSet_array IS ALWAYS BUFFER MODE.
		
		FOR MORE INFORMATION ABOUT THE ABOVE, SEE COMMIT (10/28/2016 6:29:50 PM)

- IN THIS FORK ADORecordSet::_NextRecordSet() WAS INTRODUCED TO SUB CLASSES TO OVERRIDE INSTEAD OF 
		ADORecordSet::NextRecordSet(). SUB CLASSES MAY NOT OVERRIDE ADORecordSet::NextRecordSet()
		BUT CURRENTLY THE FUNCTION IS NOT MARKED FINAL.
- IN THIS FORK ADORecordSet::Close() IS NOT CALLED AUTOMATICALLY WHEN THE INSTANCE IS DESTROYED. THIS IS
		PER APPARANT SPEICIFCATION. USER CODE MUST HANDLE MEMORY MANAGEMENT THEMSELVES WHEN NEEDED, BUT
		GENERALLY THIS IS NOT NEEDED. SEE COMMIT: (2/5/2021 9:23:59 AM). SEE COMMIT (4/10/2021 8:51:14 AM)
		FOR AN EXAMPLE OF A BUG THAT EXISTS BECAUSE OF CALLING ADORecordSet::Close() AUTOMATICALLY IN THE
		MAIN FORK.
- IN THIS FORK $ADODB_QUOTE_FIELDNAMES RETAINS ITS ORIGINAL DEFINITION. IT IS ONLY MEANT TO AFFECT
		ADOConnection::autoExecute() WHICH IN TURN AFFECTS ADOConnection::GetInsertSQL() 
		WHICH AFFECTS _adodb_getinsertsql(), AND AFFECTS ADOConnection::GetUpdateSQL() WHICH AFFECTS
		_adodb_getupdatesql(). SEE COMMIT (2/7/2021 9:59:40 AM)
- IN THIS FORK, ADODB ACTIVE RECORD IS EXPECTED TO PRESERVE SQL IDENTEFIERS. CURRENTLY IT BUILDS ON TOP
		OF THE SEEMINGLY INCOMPLETE WORK RELATED TO THE FUNCTION ADODB_Active_Record::_QName().
		IN THIS FORK, ADODB_Active_Record::$_quoteNames RETAINS ITS OLD MEANING. SEE COMMIT (2/7/2021 9:59:40 AM)
- IN THIS FORK, ::ADODB_Error_Handler() WORKS WHEN THE $sql PARAMATER IS AN ARRAY. THIS IS NOT A FEATURE, BUT
		A FIX TO A BUG ON THE MAIN FORK.
- IN THIS FORK, ADODB_db2::getMetaCasedValue(), ADODB_db2::setTableCasing(), ADODB_db2::getTableCasing(), 
		ADODB_db2::getTableCasedValue() and the constants ADODB_db2::TABLECASE_LOWER, 
		ADODB_db2::TABLECASE_UPPER, ADODB_db2::TABLECASE_DEFAULT, were removed from the new DB2 driver. 
- IN THIS FOR PHP'S assert SHOULD NOT BE USED CURRENTLY. THIS IS TO KEEP COMPATIBILITY WITH PHP 5.X
	- assert() CALLS IN "adodb-compress-bzip2.php" AND "adodb-compress-gzip.php" HAVE BEEN COMMENTED OUT.
- AVOID USING instanceof
- USE CODE SIMILAR TO (strncmp($zthis->databaseType,'postgres',8) == 0) FOR COMPARING WITH databaseType.
- IN THIS FORK, ::_adodb_getmenu() ::_adodb_getmenu_gp(),AND BY EXTENSION ADORecordSet::GetMenu(), 
		ADORecordSet::GetMenu2() AND ADORecordSet::GetMenu3(), EXPECT THE FIELDS TO BE AT LEAST NUMERICALLY
		INDEXED, BUT IS RECOMMENDED TO BE NUMERICALLY INDEXED ONLY.
	- IN THIS FORK, THE FUNCTION ADORecordSet::getMenuGrouped() WAS REMOVED. SEE COMMIT (4/3/2021 10:37:55 AM),
			WHICH IS A POSLIMINARY COMMIT. BECAUSE OF THE PERTAINING COMMIT, THE BEHAVIOR OF 
			ADORecordSet::GetMenu2() AND ADORecordSet::GetMenu3() MIGHT BE DIFFERENT NOW FROM THE OFFICIAL
			FORK, BUT IF IT IS, IT WOULD BE THE OFFICIAL FORK THAT CHANGED THE ORIGINAL BEHAVIOR, NOT THIS
			FORK.
- IN THIS FORK, THE CONSTANT ADODB_FUTURE_DATE_CUTOFF_YEARS, AND FUNCTION ::adodb_last_date_status()
		HAVE BEEN REMOVED, THE FUNCTION ::adodb_mktime() HAS BEEN FIXED FROM ITS INEFFICENCY. SEE COMMIT
		(3/31/2021 9:06:00 AM)
- IN THIS FORK, THE CLASS VARIABLE "metaDefaultsSQL" FROM REMOVED FROM THE POSTGRESS DRIVERS, AND INSTEAD
		THE CLASS FUNCTION Postgres_GetMetaDefaultSql() WAS ADDED TO THE POSTGRESS DATA DICTIONARY.
- THE FUNCTION ADOConnection::SetDateLocale() IS ILL DEFINED. THIS FUNCTION SETS 
		ADOConnection::$fmtTimeStamp, BUT NO DRIVER OVERRIDES THE FUNCTION, BUT INSTEAD DRIVERS
		DO OVERRIDE ADOConnection::$fmtTimeStamp.
- IN THIS FORK, IF ANY CHANGES MADE TO "adodb-firebird.inc.php"  BROKE BACKWARD COMPATIBILITY, EXPECT THE
		SAME FROM THE DRIVER "adodb-pdo_firebird.inc.php" WHICH WAS ADDED RECENTLY, AND VERBATIM CODE
		WAS RECOGNIZED BASED ON THE MAIN FORK, AND HENCE THE SAME MODIFICATION WAS MADE TO IT AS THE
		MODIFICATION MADE TO "adodb-firebird.inc.php" IN THIS FORK. SEE COMMIT (4/3/2021 1:23:51 PM)
- IN THIS FORK, THE DRIVER "adodb-pdo_dblib.inc.php", IS ASSUMED FOR MSSQL ONLY. THE UNDERLYING ADODB PDO
		DRIVER ADDS AN ARTIFICIAL DSN, dblib_mssql, BUT ALSO WORKS WITH dblib LIKE THE MAIN FORK BUT IT
		EXPLICITLY ASSUMES MSSQL, NOT SYBASE. SEE COMMIT (4/4/2021 10:30:48 AM)
- THE IMPLEMENTATIONS OF ADOConnection::MetaForeignKeys() ARE HIGHLY DIVERGENT AMONG DRIVERS. THIS 
		FUNCTION MAY NOT BE USED WITHIN ADODB TO ACHIEVE ITS OWN FUNCTIONS. NORMALIZATION WAS 
		AVOIDED TO RETAIN BACKWARD COMPATIBILITY. SEE COMIT  (4/5/2021 12:44:29 PM)
- IN THIS FORK, IN THE OCI8 DRIVER, adodb-oci8.inc.php, ADOConnection::_insertid()
		ADODB_oci8::$useCompactAutoIncrements, ADODB_oci8::$schema AND ADODB_oci8::$seqPrefix
		HAVE BEEN REMOVED. THESE WERE ALL ADDED RECENTLY, RELATIVELY SPEAKING. SEE 
		COMMIT (4/8/2021 10:05:42 AM)
- IN THIS FORK, THE NEWLEY ADDED "adodb-loadbalancer.inc.php" FEATURE WILL NOT BE SUPPORTED, AND MIGHT GET
		REMOVED IT ENDS UP BEING PARASATIC. SEE COMMIT (4/9/2021 3:26:49 PM)
- IN THIS FORK, ADORecordSet::$connection MUST ALWAYS BE SET. THIS IS PER APPARANT SPECIFICATION. THE
		FEW DRIVERS THAT VIOLATED THIS WERE FIXED. ALSO THE FUNCTION ADORecordSet::SerializableRS(), 
		WHICH VIOLATED THIS, WAS ALSO FIXED. THE FIX CAME THROUGH ADOConnection::newADORecordSet().
		SEE COMMIT (4/14/2021 6:11:39 PM)
- IN THIS FORK, THE FUNCTION ADOConnection::newADORecordSet()  WAS INTRODUCED, AND DRIVERS, AND EXTERNAL
		CODE MUST CALL THIS FUNCTION WHEN CREATING INSTANCES OF ADORecordSet. SEE 
		COMMIT (4/14/2021 6:11:39 PM)
- IN THIS FORK, ADORecordSet::$datetime WAS REMOVED. IT WAS NOT USED ANYWHERE IN ADOdb AND WAS REMOVED. IN 
		THE PAST THE VARIABLE SERVED A PURPOSE IN ADORecordSet::MetaType(). ABOUT 16 YEARS AGO, THE
		VARIABLE WAS MOVED IMPLICITLY TO ADOConnection, BUT WAS NEVER DECLARED THERE. ONLY ONE DRIVER
		DECLARED IT, "adodb-oci8.inc.php". SEE COMMIT (4/14/2021 6:11:39 PM).
- IN THIS FORK, THE ODBPT DRIVER, "adodb-odbtp.inc.php", CAN NO LONGER BE USED FOR DB2 AND MYSQL. THE 
		IMPLEMENTATION WAS INCOMPLETE, AND INCOMPLETE ENOUGH TO MAKE IT BROKEN. HOWEVER I INTEND TO 
		ADD SUPPORT FOR DB2 AND MYSQL IF REQUESTED. SEE COMMIT (4/14/2021 6:11:39 PM)
- IN THIS FORK, ADODB_pdo::$stmt, WHICH IS FROM THE PDO DRIVER, WAS REMOVED. IT WAS NOT ANYWHERE IN THE
		ADODB CODE, AND APPEARS TO HAVE BEEN MEANT TO BE THE IMPLICITLY DECLARED VARIABLE 
		ADODB_pdo::$_stmt. IN THIS FORK, ADODB_pdo::$_stmt WAS ADDED EXPLICITLY. SEE 
		COMMIT (4/14/2021 6:11:39 PM)
- IN THIS FORK A MINOR BUG IN "adodb-postgres64.inc.php" IMPLEMENTATION OF ADOConnection::_connect() 
		PERTAINING TO ADODB_postgres64::$noBlobs WAS FIXED. THE BUG IS OLD IF I REMEMBER CORRECTLY.
		SEE COMMIT (4/14/2021 6:11:39 PM)
- IN THIS FORK, THE DRIVER "adodb-pdo_sqlite.inc.php" WAS UPDATED TO INTEGRATE THE PHP FUNCTIONS
		::adodb_date() AND ::adodb_date2() INTO THE SQL, TO KEEP TO THE BEHAVIOR OF THE OTHER SQLITE DRIVERS.
		SEE COMMIT (4/14/2021 6:11:39 PM)
- ABOUT ADORecordset::MetaType():
	- HISTORY:
					"It appears that ADORecordset::MetaType() came first to translate driver specific 
					types to ADOdb types. Later, the data dictionaries came, and it was decided convenient 
					that the MetaType() function be available on them giving birth to 
					ADODB_DataDict::MetaType(). This was a mistake because these functions are about the 
					driver, yet their output is tied to the specification of dbTable::addField() which is 
					part of ADOdb Schema which itself is the apparent reason for why the ADODB Data 
					Dictionary was made, hence the whole confusion. Given the mistake, it was no surprise 
					that later the implementation of ADODB_DataDict::MetaType() had to check first if a 
					driver existed on the ADODB_DataDict instance before calling ADOConnection::MetaType(), 
					and if not, supplying its own result and exasperating the problem instead of solving the
					original mistake. About a year later "adodb-replicate.inc.php" was introduced to ADOdb
					and made direct use of ADODB_DataDict::MetaType(). As for ADOConnection::MetaType(), 
					it itself would create an internal instance of ADORecordset just to call 
					ADORecordset::MetaType(), a product of another problem related to the code 
					architecture."	COMMIT (4/15/2021 6:54:59 PM)
	- IN THIS FORK, ADORecordset::MetaType() IMPLEMENTATIONS HAVE BEEN MOVED TO THE CORRESPONDING
			ADOConnection IMPLEMENTATIONS. ADORecordset::MetaType() IS STILL A VALID FUNCTION, AND SIMPLY 
			FORWARDS THE CALL TO ADOConnection::MetaType(). AS A CONSEQUENCE, ADORecordset::blobSize WAS ALSO 
			REMOVED, AND SET ON ADOConnection INSTEAD. THIS BREAKS BACKWARD COMPATIBILITY, AND USER 
			CODE SHOULD SWITCH TO USING ADOConnection::blobSize INSTEAD. ANOTHER CONSEQUENCE IS THAT
			THE ORIINAL SLOW ADOConnection::MetaType() IS NO LONGER SLOW, AND THE IMPLICIT VARIABLE,
			ADOConnection::_metars, WHICH WAS USED TO HOLD AN ISNTANCE OF ADORecordset JUST TO CALL
			ADORecordset::MetaType() WAS REMOVED. SEE COMMIT (4/15/2021 6:54:59 PM)			
	- IN THIS FORK, ADODB_DataDict::MetaType() IMPLEMENTATIONS HAVE BEEN REMOVED, AND SO WAS 
			ADODB_DataDict::blobSize. THIS AFFECTS NO CODE IN ADODB EXCEPT "adodb-replicate.inc.php". 
			ADODB_DataDict::MetaType() IS STILL A VALID FUNCTION, AND SIMPLY FORWARDS THE CALL TO
			ADOConnection::MetaType(). SEE COMMIT (4/15/2021 6:54:59 PM)
	- IN THIS FORK, ADOConnection::MetaType() IS EXPLICITLY DEFINED TO TRANSFORM THE VALUE OF
			ADOFieldObject::type, WHOSE VALUES ARE DRIVER SPECIFIC, TO ONE OF THE STANDARD ADODB TYPES
			AS DEFINED IN THE SPECIFICATION OF dbTable::addField(), AND IT IS EXPLICITLY ALLOWED
			TO RETURN THE SAME VALUE FOR DIFFERENT TYPES MAKING IT NON INVERTIBLE. THIS IS PER APPARANT
			SPECIFICATION.
			
			GIVEN THE SAME ANALYSIS IT WAS FOUND THAT adoSchema::ExtractSchema(), FOR BOTH
			"adodb-xmlschema.inc.php" AND "adodb-xmlschema03.inc.php" IS ILL DEFINED. TO BE WELL DEFINED
			THE FOLLOWING NECESSARY, BUT INSUFFICIENT, CONDITIONS MUST BE MET IF I AM NOT WRONG:
					- ADODB_DataDict::ActualType(x) != ADODB_DataDict::ActualType(y) FOR ALL x != y
					- GIVEN
									y = ADODB_DataDict::ActualType(x)
									z = ADOFieldObject::type of a database table column created using y
							THE FOLLOWING MUST HOLD TRUE:
									ADOConnection::MetaType(z) == x
			THE ABOVE CONDITIONS ASSUME A SIMPLER REQUIREMENT THAT THE FOLLOWING FUNCTION IS ONLY
			VALID IF THE DATABASE WAS ORIGINALLY CREATED USING ADODB SCHEMA. TO UNDERSTAND WHY
			THE CONDITIONS ARE WHAT THEY ARE, SEE HOW THE CODE CREATES THE DATABASE FROM THE SCHEMA
			IN THE FIRST PLACE.
			
			{DEPRECATED		NEEDS FIXING
			IT IS VERY IMPORTANT TO REMEMBER THAT ADODB_DataDict::ActualType() IS NOT THE INVERSE
			FUNCTION OF ADOConnection::MetaType(). THIS IS PER APPARANT SPECIFICATION, A RESULT
			OF THE AFOR MENTIONED CODE ANALYSIS. BUT IT WOULD BE NEEDED THAT ADOConnection::MetaType()
			BE THE INVERSE OF ADODB_DataDict::ActualType() LEADING TO THE CONCLUSION THAT 
			ADOConnection::MetaType() IS TO HANDLE BOTH DRIVER SPECIFIC VALUES, AND OTHER VALUES, WHICH
			ARE THE SQL SYNTAX GENERALLY, TO ALLOW IT BE THE INVERSE OF ADODB_DataDict::ActualType()
			SEE COMMIT (4/16/2021 10:29:03 AM) WHICH WAS
			WORK IN ANTICIPATION OF MERGING THE OFFICIAL COMMIT AT 
			"https://github.com/ADOdb/ADOdb/commit/8856265c933087030627484c53d36ed5dae29e86", 
			OR THE EASIER TO FOLLOW:
			"https://github.com/ADOdb/ADOdb/commit/3c8d1e5f20aab232a68853f93532a5d840f38e09"
			THIS OFFICIAL COMMIT TREATED ADODB_DataDict::ActualType() AND ADOConnection::MetaType()
			AS INVERSES OF EACH OTHER, AND ALSO FORGOT THAT THE STANDARD ADODB TYPES ARE DEFINED
			ADODB SCHEMA, AND IN PARTICULAR IN THE SPECIFICATION OF dbTable::addField(), AND
			ADODB SCHEMA EXPLICITLY DEFINES THESE TYPES IN ITS DTD FOR XML VERIFICATION. IT IS ALSO
			POSSIBLE THAT PHRASE "DICTIONARY TYPE" WAS MEANT FOR THOSE OTHER NON DRIVER SPECIFIC
			VALUES THAT ADOConnection::MetaType() CAN HANDLE, BUT THAT OFFICIAL COMMIT INTRODUCES
			A VALUE FOR "DICTIONARY TYPE", AND NEVER USES DEMONSTRATING THE ENTIRE CONFUSION. IF
			MY ANALYSIS OF THE CONFUSION IS CORRECT, THEN:
					ADOConnection::MetaType():		"ACTUAL TYPE" OR "DICTIONARY TYPE" => "META TYPE"
					ADODB_DataDict::ActualType():	"META TYPE" => "DICTIONARY TYPE"
			IN THIS OFFICIAL COMMIT, IN THE CODE:
					"ACTUAL TYPE" 		WOULD BE customMetaTypes[M]['actual']
					"DICTIONARY TYPE"	WOULD BE customMetaTypes[M]['dictionaryType']
					"META TYPE"			WOULD BE THE "M", THE INDEX OF customMetaTypes
			BUT THEN AGAIN, A CUSTOM TYPE AS THE ORIGINAL OFFICIAL COMMIT WAS TRYING TO ACHIEVE, COULD
			NOT POSSIBLY DEFINE AN "ACTUAL TYPE", BUT THAT COMES FROM THE ACTUAL DRIVER.
			
			THERE ARE DRIVERS THAT DIFFERENTIATE BETWEEN THE DRIVER SPECIFIC INPUT TO
			ADOConnection::MetaType(), AND THE OTHER INPUT. THE "adodb-db2.inc.php" AND THE
			"adodb-db2Legacy.inc.php" DRIVERS BOTH DO THIS, AND INTRODUCE A DIFFERNT FUNCTION FOR
			HANDLING THE DRIVER SPECIFIC VALUES, AND NEVER ASSIGN THESE VALUES TO ADOFieldObject::type,
			AND THEY LEAVE ADOConnection::MetaType() TO SIMPLY HANDLE THE OTHER VALUES. ANOTHER
			DRIVER THAT DOES THIS, WHICH HAS BEEN DOING THIS AS FAR THE HISTORY OF GIT TAKES ME (2005)
			IS "adodb-odbc.inc.php", BUT YET THE DRIVER "adodb-mysqli.inc.php" DOES NOT, AND ALSO HAS NOT
			SINCE AS FAR THE GIT HISTORY TAKES ME. 
			}
	- SURVEY OF ADOFieldObject::type IN THE EARLIEST COPY OF ADODB AVAILABLE ON GIT HISTORY. (2005)
		- ADOFieldObject::type APPEARS TO BE SET IN THE DRIVERS IN TWO PLACES ONLY, 
				ADOConnection::Metacolumns(), AND ADORecordSet:FetchField().
		- THIS SURVEY WAS DONE SEARCHING FOR THE TEXT:
						"->type", "MetaType", AND "FetchField".
		- OFTEN WITH ADORecordSet::FetchField(), THE IMPLEMENTATION IS CALLING DRIVER SPECIFIC FUNCTIONS,
				AND SOME TIMES I SIMPLY FAILED TO KNOW THE TYPE OF THE 'type' FIELD RETURN FROM THESE
				FUNCTIONS. THESE FUNCTIONS TENDED TO RETURN AN OBJECT THAT HAD SOMEWHAT STANDARD 
				PROPERTIES AMONG ALL DRIVERS, AND ONE OF THEM BEING type.
		- THE SURVEY CATEGORIES THE VALUES SET ON ADOFieldObject::type IN TWO CATEGORIES, "BASIC" AND
				"DRIVER SPECIFIC". "BASIC" SIMPLY MEANS THE TYPE VALUE IS A STRING, AND EVERY WHERE THAT
				IS THE CASE, THE VALUE IS SOME THING YOU SEE IN SQL OR C LIKE PROGRAMMING LANGUAGES.
				"DRIVER SPECIFIC" IS A NUMBER OR SOMETHING MORE COMPLICATED. IF THE DRIVER
				STORES A "DRIVER SPECIFIC" ON ADOFieldObject::type THE VALUE IS JUST A NUMBER. IF
				THE DRIVER DOES A CONVERSION FIRST TO "BASIC" BEFORE STORING, THE ORIGINAL VALUE MIGHT
				HAVE BEEN A NUMBER OR SOMETHING MORE COMPLEX SUCH AS THE DRIVER'S CODE CHECKS OTHER THINGS
				BEFORE DECIDING ON THE TYPE.
		- RESULTS:
			- DRIVERS THAT WERE ASSIGNING "DRIVER SPECIFIC" TO ADOFieldObject::type:
				- adodb-mysqli.inc.php
			- DRIVERS THAT WERE CONVERTING A "DRIVER SPECIFIC" TO "BASIC" THEN ASSIGNING TO TO 
					ADOFieldObject::type:
				- adodb-ado.inc.php
				- adodb-ado5.inc.php
				- adodb-ibase.inc.php	IN ANOTHER CONTEXT
						THIS WAS ASSIGNING DIRECTLY TO ADOFieldObject::type, AND IT APPEARED THE VALUE
						IS NOT DRIVER SPECIFIC VALUE, AND SIMPLY BASIC SQL
				- adodb-informix72.inc.php  THE CONVERSION WITH THIS 
						ONE IS NOT STRAIGHT FARWARD AT ALL, AND IN ANOTHER CONTEXT THIS WAS ASSIGNING
						DIRECTLY TO ADOFieldObject::type, AND IT APPEARED THE VALUE IS NOT DRIVER 
						SPECIFIC VALUE, AND SIMPLY BASIC SQL, BUT I AM UNSURE BECAUSE IF FOUND A FAINT SUGGESTION
						THAT THEY ARE INDEED RAW DRIVER SPECIFIC VALUES.
				- adodb-odbc.inc.php
				- adodb-pdo.inc.php NOTE THAT IN ONE PART OF
						"adodb-pdo_mysql.inc.php" THE DRIVER SIMPLY ASSIGNS WHAT APPEARS TO BE A NOTHING
						SPECIAL VALUE TO ADOFieldObject::type. "adodb-pdo_oci.inc.php" ALSO HAS THE SAME
						STORY AS THE "adodb-oci8.inc.php" DRIVER FOR ONE PART OF IT (IN MetaColumns()). 
						"adodb-pdo_pgsql.inc.php" HAS SAME STORY FOR ONE PART OF IT AS THAT OF 
						"adodb-oci8.inc.php" (IN MetaColumns())
			- DRIVERS THAT WERE ASSIGNING THE RAW VALUE AS IS ON ADOFieldObject::type, BUT THE VALUE
					APPEARS "BASIC":
				- adodb-fbsql.inc.php
				- adodb-mysql.inc.php		NOTE: CONFIRMED THAT
						mysql_fetch_field() DOES NOT RETURN DRIVER SPECIFIC VALUES.
				- adodb-netezza.inc.php
				- adodb-odbtp.inc.php
				- adodb-oracle.inc.php
				- adodb-oci8.inc.php 	NOTE: IT DOES DO A MINOR
						NON TRIVIAL CONVERSION IN ONE INSTANCE.
				- adodb-postgres64.inc.php HAS SAME STORY AS 
						"adodb-oci8.inc.php"
				- adodb-sapdb.inc.php
				- adodb-sqlite.inc.php
				- adodb-sybase.inc.php
		- NOTE THAT FOR THE THIRD CATEGORY IN THE RESULTS, I COULD BE WRONG FOR SOME DRIVERS.
		- "adodb-ado5.inc.php" WAS USING ADOConnection::MetaType() ITSELF TO ASSIGN TO 
				ADOFieldObject::type, DURING WHICH THE FUNCTION CONVERTS FROM 
				"DRIVER SPECIFIC" TO "BASIC". ADOConnection::MetaType() IS SUPPOSED TO BE READING
				FROM INSTEAD ADOFieldObject::type INSTEAD.
	- CONCLUSIONS:
		- {DEPRECATED NEES FIXING
				IT LOOKS LIKE "BASIC" SHOULD HAVE BEEN THE TYPE TO STORE IN ADOFieldObject::type. THIS MIGHT
				SUGGEST THAT ORIGINALLY THERE WAS A DEFINED SET OF VALUES ALLOWED FOR
				ADOFieldObject::type AND THAT I SHOULD PROCEED TO MAKE ALL DRIVERS COMPLIANT, BUT
				UNFORTUANETLY EVEN THOUGH FIXING "adodb-mysqli.inc.php" WOULD MAKE ALL DRIVERS
				RETURN BASIC, IT IS NOT A GUARANTEE THAT THESE RETURNED VALUES ARE THE SAME FOR
				ALL DRIVERS, AND HENCE WE WOULD ACHEIVE NOTHING, AND THE SITUATION REMAINS AS IS,
				ADOFieldObject::type IS DRIVER SPECIFIC. A QUICK SURVEY ON THAT SAME OLD
				ADODB VERSION HAS SHOWN THAT INDEED THOSE STRING VALUES DIFFER. }
		- IT APPEARS THAT THE WAY FARWARD IS FOR A NEW FIELD ON ADOFieldObject TO CONTAIN THE ADODB 
				STANDARD TYPE. ELSEWHERE, SQL GENERATING CODE, SUCH AS THAT FOR GENERATING TABLES
				AND SIMILAR, WOULD ONLY DEAL WITH THE ADODB STANDARD TYPES. CALLING SOMETHING LIKE 
				ADODB_DataDict::ActualType() BECOMES AN IMPLEMENTATION DETAIL CONCERNED WITH CONVERTING
				THE ADODB STANDARD TYPES INTO SQL, AND NOT SOMETHING THAT GIVE YOU A TYPE. WHAT THIS
				MEANS THAT THE OUTPUT OF ADODB_DataDict::ActualType() AS AN INPUT TO 
				ADOConnection::MetaType() WOULD BECOME NONSENSE, WHICH INCLUDES THE CONDITION:
								ADOConnection::MetaType(ADODB_DataDict::ActualType(x)) == x.
				WITH THIS, CALLS TO ADOConnection::MetaType() WOULD NO LONGER APPEAR ANYWHERE IN THE CODE, 
				AND ADOFieldObject::type FIELD BECOMES INDEED THE RAW VALUE RETURNED BY THE DATABASE, 
				AND DRIVERS CONVERTING THIS VALUE TO "BASIC" WOULD BE WRONG IN DOING SO, AND I THINK 
				THAT THIS WAS INDEED THE ORIGINAL INTENT FOR THAT VARIABLE, BECAUSE OF HOW SIMILAR THE 
				RETURNED FIELD INFO STRUCTURE IS FROM THE ACTUAL PHP DRIVERS, MEANING THAT ADOFieldObject
				WAS SIMPY TRYING TO NORMALIZE THOSE STRUCTURES, BUT THE GIT HISTORY DOES NOT GO BACK FAR
				ENOUGH TO PROVE IF INDEED THIS WAS THE ORIGINAL INTENT.
				
				UPDATE: AFTER FURTHER ANALYSIS, THE OUTPUT OF ADODB_DataDict::ActualType() AS AN INPUT TO 
				ADOConnection::MetaType() IS INDEED NONESENSE. MUCH OF THE COMMENTS ABOVE ARE NOW MARKED
				DEPRECATED.
					
					
- THE FORMER ADODB_DataDict::blobSize, WHICH THIS FORK REMOVED, IS SET BY THE ADODB DATA DICTIONARY 
		FOR FIREBIRD. THE VALUE IS KEPT FOR REFERENCE, BUT IT WOULD HAVE ONLY AFFECTED
		"adodb-replicate.inc.php". HENCE, THE VALUE WAS NOT MOVED TO THE "adodb-firebird.inc.php" DRIVER.
		SEE COMMIT (4/15/2021 6:54:59 PM)
- IN THIS FORK, THE DATA DICTIONARY, "datadict-frontbase.php" WAS INTRODUCED. THIS PERTAINED TO THE DRIVER
		"adodb-fbsql.inc.php". SEE COMMIT (4/15/2021 6:54:59 PM).
- IN THIS FORK, ADOConnection::MetaType() FOR THE DRIVER "adodb-ado5.inc.php" WAS RENAMED TO ADO5Types().
		THIS IS BECAUSE THE FUNCTION WAS USED TO ASSIGN TO ADOFieldObject::type INSTEAD OF TRANSLATING
		FROM ADOFieldObject::type, WHICH IS FUNDAMENTALLY WRONG. SEE COMMIT (4/15/2021 6:54:59 PM)
- THE FUNCTION adoSchema::ExtractSchema() IS ILL DEFINED.
- IN THIS FORK, ADOConnection::_bindInputArray IS A PROTECTED VARIABLE. SEE COMMIT (4/22/2021 8:34:23 AM)
- IN THIS FORK ADODB_postgres64::postgres64__setIsToEnableNativeSqlParameterBinding() WAS INTRODUCED TO THE
		"adodb-postgres64.inc.php" DRIVER TO ALLOW SETTING ADOConnection::_bindInputArray BY EXTERNAL CODE. 
		CLIENT CODE SETTING THIS VARIABLE BEFORE MUST SWITCH TO USING 
		ADODB_postgres64::postgres64__setIsToEnableNativeSqlParameterBinding() INSTEAD. 
		OTHER AFFECTED DRIVERS INCLUDE "adodb-postgres7.inc.php", "adodb-postgres8.inc.php", AND
		"adodb-postgres9.inc.php". SEE COMMIT (4/22/2021 8:34:23 AM)
- IN THIS FORK, THE FUNCTION ADODB_odbtp::odbtp__setIsToEnableNativeSqlParameterBinding() WAS INTRODUCED TO 
		THE "adodb-odbtp.inc.php" DRIVER TO ALLOW SETTING ADOConnection::_bindInputArray BY EXTERNAL CODE. 
		CLIENT CODE SETTING THIS VARIABLE BEFORE, MUST SWITCH TO USING 
		ADODB_odbtp::odbtp__setIsToEnableNativeSqlParameterBinding() INSTEAD. SEE COMMIT (4/22/2021 8:34:23 AM)
- DRIVERS SETTING ADOConnection::$_bindInputArray TO true MUST READ NOTES OF ADOConnection::$_bindInputArray CAREFULLY.
- IN THIS FORK, THE IMPLICIT FUNCTION  ADOConnection::_query() IS PROTECTED, AND CALLS TO THE FUNCTION MUST NOT
		APPEAR ANYWHERE EXCEPT IN ADOConnection::_Execute(). SEE COMMIT (4/22/2021 8:34:23 AM)
- ADOConnection::_query() HAS MORE DUTIES IF VALUE OF ADOConnection::$_bindInputArray IS true. ALL DRIVERS, 
		EXCEPT  "adodb-ads.inc.php", IGNORE THESE EXTRA DUTIES WHEN THEY HAVE ADOConnection::$_bindInputArray
		SET TO FALSE AND ARE NOT CURRENTLY SUB CLASSED BY ANOTHER DRIVER. SEE COMMIT (4/22/2021 8:34:23 AM)
- ADOConnection::Prepare() MUST RETURN ITS PARAMETER AS IS IF ADOConnection::$_bindInputArray IS SET TO false.
		IN THIS FORK, ALL OVERRIDES WERE MADE TO CHECK ADOConnection::$_bindInputArray AND ACT ACCORDINGLY EVEN
		IF THE VALUE IS SET TO true BY THE DRIVER. SEE COMMIT (4/22/2021 8:34:23 AM)
- ADOConnection::_Execute(), UNLIKE ADOConnection::_query(), MUST ALWAYS ACCOUNT FOR THE SQL PARAMETER TO BE AN 
		ARRAY PER THE SPECIFICATION OF THE RETURN OF ADOConnection::Prepare(). SEE COMMIT (4/22/2021 8:34:23 AM)
		IN THIS FORK, A FIX WAS MADE IN THE "adodb-db2oci.inc.php" DRIVER PERTAINING TO THIS. 
		SEE COMMIT (4/22/2021 8:34:23 AM)
- IN THIS FORK, THE CLASS VARIABLE $useFetchArray, WHICH WAS FOUND IN SOME DRIVERS, IN THEIR SUB CLASSES OF
		ADOConnection AND ADORecordset, WAS REMOVED. THE VARIABLE WAS NOT DOING ANYTHING BY THE TIME IT WAS
		REMOVED. SEE COMMIT (4/22/2021 8:34:23 AM)
- IN THIS FORK, THE DRIVER "adodb-sqlanywhere.inc.php" WAS RENAMED TO "adodb-odbc_sqlanywhere.inc.php".
		SEE COMMIT (4/22/2021 8:34:23 AM)
- ADOConnection::Exectue():
	- PSEUDO CODE OF ADOConnection::Exectue()
			function Exectue(sql, inputarr=false)
			{
				IF this->fnExecute IS DEFINED
					DELEGATE TO this->fnExecute BY CALLING this->fnExecute(this, sql, inputarr)
				END
				
				IF inputarr WAS PASSED, MEANING WE ARE DEALING WITH A STATEMENT WITH 
						PLACEHOLDERS IN IT SUCH AS A NATIVE PREPARED STATEMENT
					
					FORCE inputarr TO BE AN ARRAY BECAUSE IT MIGHT JUST BE A SINGLE NON ARRAY VALUE
					
					SET FLAG array2d IF THE FIRST ELEMENT OF inputarr IS AN ARRAY. WHEN THIS IS THE CASE
							WE ASSUME ALL ELEMENTS OF inputarr ARE ARRAYS. THIS IS ONLY ALLOWED IF BULK BINDING
							IS ENABLED BY SETTING this->bulkBind TO true. 

					IF sql IS NOT AN ARRAY, MEANING IT IS A STRING, AND THIS DRIVER DOES NOT NATIVELY SUPPORT STATEMENTS WITH 
							PLACEHOLDERS; IT CAN NOT PREPARE THEM. WHETHER DRIVERS NATIVELY SUPPORT BULK BINDING IS INDICATED
							BY this->_bindInputArray
						
						IF NOT(array2d) MEANING WE DO NOT HAVE THE BULK BINDING SITUATION
							WRAP inputarr IN ANOTHER ARRAY. WITH THIS WE GUARANTEE THAT WE ALWAYS HAVE AN ARRAY OF ARRAYS.
						ELSE
							ENSURE THAT ALL THE ARRAYS PASSED WHEN WE HAVE THE BULK BINDING SITUATION HAVE THE SAME LENGTH
									WHICH IS JUST A NECESSARY BUT INSUFFICIENT CONDITION THAT THEY ALL HAVE THE CORRECT
									NUMBER OF VALUES FOR THE PLACEHOLDERS IN THE SQL STRING.
						END
						
						ENSURE THAT THE FIRST ELEMENT OF inputarr, WHICH IS CERTAIN TO BE AN ARRAY AT THIS POINT, HAS
								THE CORRECT NUMBER OF VALUES FOR THE PLACEHOLDER IN THE SQL STRING.
					
						FOR EACH arr IN inputarr
							BUILD sql2, THE SQL STRING, WHILE DOUBLE CHECKING INDEED WE HAVE THE RIGHT NUMBER OF PARAMETERS
							
							EXECUTE THE SQL USING this->_Execute(sql2)
							
							IF(this->_Execute RETURNED FALSY)
								RETURN FALSY
							END
						END
						
						RETURN RESULT OF LAST this->_Execute CALL
					ELSE (MEANING THAT THE DRIVERS DO THEIR OWN PREPERATION. NOTICE HOW IT IS ASSUMED THAT this->_bindInputArray
							IS true HERE, REGARDLESS OF ITS ACTUAL VALUE. THIS IS PROBABLY A BUG. LATER THIS
							FORK EXPLICITLY CHECKS THAT this->_bindInputArray IS true )
						IF array2d, MEANING WE HAVE THE BULK BINDING SITUATION
							IF sql IS A STRING, MEANING IT IS NOT PREPARED YET FOR THE PLACEHOLDER WORK
								CALL this->Prepare(sql) AND STORE AT stmt
							ELSE (MEANING THE STATEMENT IS ALREADY PREPARED)
								JUST ASSIGN sql TO stmt
							END
							
							FOR EACH arr IN inputarr   (NOTE arr MAY OR MAY NOT BE AN ARRAY, BUT IT IS LEFT TO
									THE DRIVERS TO DEAL WITH IT BECAUSE PERHAPS SOME NATIVE DRIVERS HAVE THEIR OWN
									RULES ABOUT WHAT HAPPENS IF YOU PASS LESS PARAMETERS THAN THE NUMBER OF PLACEHOLDERS
									IN A PREPARED STATENENT.)
								CALL this->_Execute(stmt,arr)
								
								IF(this->_Execute RETURNED FALSY)
									RETURN FALSY
								END
							END
						ELSE
							CALL this->_Execute(stmt,arr)
						END
						
						RETURN RESULT OF LAST this->_Execute CALL
					ELSE *  (THIS is AFTER THE CHANGE IN THIS FORK EXPLCITLY CHECKING THAT this->_bindInputArray IS true)
						REPORT ERROR
					END
				ELSE (MEANING WE DO NOT HAVE STATEMENT WITH PLACE HOLDERS SITUATION.
					CALL this->_Execute(stmt,arr) AND RETURN RESULT
				END
			}
			*: IN THIS FORK IT BECAME MANDATORY THAT this->_bindInputArray BE TRUE AND CHECKED HERE. THIS WAS WERE APPRENT
					SPECIFICATION WHICH WAS DEDUCED AFTER MUCH ANALYSIS OF ALL DRIVERS BECAUSE IT WAS NOT SO EASILY APPARENT.
					SEE COMMIT (4/22/2021 8:34:23 AM)
	- BIND IN ADODB DOES NOT REFER TO BINDING TO PHP VARIABLES, BUT SIMPLY TO FILLING IN THE GAPS IN THE SQL STRING
			WITH PLACEMENT MARKERS WITH SOME DATA. FOR WHATEVER REASON THAT DATA IS SAID TO BE BOUND.
	- EFFECTIVELY ADODB PROVIDES TWO MECHANISM FOR EMULATING PREPARING OF SQL STATEMENTS CONTAINING PALCEHOLDERS.
			THE FIRST APPROACH WOULD REQUIRE OVERRIDING ADOConnection::Prepare() AND ADOConnection::_query()
			AND PERHAPS OTHER FUNCTIONS, AND TO THE BASE CLASS IT WOULD LOOK AS IF THE DRIVER NATIVELY
			SUPPORTS THIS, MEANING ADOConnection::_bindInputArray IS SET TO TRUE.
			
			THE SECOND MECHANISM KICKS IT WHEN ADOConnection::_bindInputArray IS SET TO FALSE, AND CAN ONLY
			BE OVERRIDEN BY OVERRIDING ADOConnection::Execute() WHICH IS WHAT "adodb-oci8.inc.php" WAS DOING.
			THIS FORK ALMOST FORBIDS OVERRIDING ADOConnection::Execute(), AND THIS FORK IS LIKELY TO MAKE IT FINAL
			IN THE FUTURE. HENCE TWO FUNCTIONS WERE INTRODUCED, ADOConnection::Execute__EmulatePrepare() AND
			ADOConnection::Execute__BuildSqlFromEmulatePrepareStatement() FOR THIS SECOND MECHANISM. THIS SECOND
			MECHANISM IS ALMOST CERTAINLY REDUNDANT, BUT WAS KEPT FOR THIS TIME. GIVEN THIS HOWEVER, IT IS EXPLICLTY
			SPECIFIC IN THIS FORK THAT WITH THIS MECHANISM ALL DRIVERS WOULD HAVE THE SAME SYNTAX FOR PLACEHOLDERS
			IN THE SQL. "adodb-oci8.inc.php" IS IN VIOLATION OF THIS SPECIFICATION. SEE BELOW. ONE COULD
			SAY THAT THIS PER APPARANT SPECIFCATION, BUT UNSURE, BUT ONE THING FOR CERTAIN, THE ONLY DRIVER OVERRIDING
			ADOConnection::Execute(), "adodb-oci8.inc.php", AND ALSO BREAKING THIS SPECIFICATION WAS SUBCLASSED BY
			ANOTHER DRIVER, "adodb-oci8po.inc.php", THAT ENDED UP RETURNING THE OLD SYNTAX, AND INSTEAD DOING THE
			EMULATING USING THE FIRST MECHANISM, MEANING USING ADOConnection::Prepare().
			
			SEE COMMIT (4/22/2021 3:26:51 PM)
	- IN THIS FORK, ADOConnection::Exectue() OVERRIDES WERE REMOVED. THE ONLY DRIVER OVERRIDING IT AT THE TIME WAS
			"adodb-oci8.inc.php". ANOTHER DRIVER WAS OVERRIDING, "adodb-oci8po.inc.php", BUT ONLY TO BYPASS THE 
			OVERRIDING OF "adodb-oci8.inc.php" BECAUSE "adodb-oci8po.inc.php" WAS A SUBCLASS OF IT. THIS WAS ALSO
			REMOVED.
			
			THE VARIABLE ADODB_oci8::gOci8_isToRevertToAdodbPlaceHolderFormatWhenEmulatingBinding WAS INTRODUCED TO
			THE "adodb-oci8.inc.php" DRIVER BECAUSE THE DRIVER'S CHANGE TO THE SYNTAX OF PLACEHOLDERS WHEN
			OVERRIDING ADOConnection::Exectue() BEFORE THE OVERRIDES REMOVAL. THE VARIABLE, WHEN TRUE,
			REVERTS TO THE OLD SYNTAX, BUT IS CURRENTLY PROTECTED AND IS ONLY OVERRIDEN BY "adodb-oci8po.inc.php"
			TO ALLOW THE REMOVAL OF THE ADOConnection::Execute() OVERRIDE THERE. THIS OF COURSE, MEANS
			THAT "adodb-oci8.inc.php" IS STILL IN VIOLATION, AND IN THE FUTURE I MIGHT MAKE MODIFYING
			ADODB_oci8::gOci8_isToRevertToAdodbPlaceHolderFormatWhenEmulatingBinding AVAILABLE TO CLIENT CODE, BUT
			FOR THE TIME BEING IT IS NOT URGENT BECAUSE OF THE EXISTENCE OF "adodb-oci8po.inc.php". 
			SEE COMMIT (4/22/2021 3:26:51 PM)
	- NOTE THAT THE $inputarr PARAMETER OF ADOConnection::Exectue() CAN EITHER BE AN ARRAY OF ARRAYS, OR AN ARRAY OF 
			PRIMITIVES. ON THE OTHER HAND, THE $inputarr PARAMETER OF ADOConnection::_Exectue() CAN ONLY BE AN 
			ARRAY OF ARRAYS IFF THE sql PARAMETER IS AN ARRAY AND ADOConnection::bulkBind IS SET TO false. 
			THE SAME APPLIES TO ADOConnection::_query(). WHEN YOU HAVE ARRAY OF ARRAYS IT IS TO SUPPORT THE
			"BULK BINDING" BUSINESS, WHICH IS ENABLED OR DISABLED USING ADOConnection::bulkBind. WHEN ENABLED,
			IT MEANS THAT  ADOConnection::Exectue() WILL AUTOMATICALLY TURN THE SINGLE CALL OF 
			ADOConnection::Exectue() TO BE EFFICETIVELY MULTIPLE CALLS OF IT. IF UNCLEAR WHAT BULK BIND IS,
			SEE https://adodb.org/dokuwiki/doku.php?id=v5:userguide:learn_bind:bulkbinding.
- IN THIS FORK, A BUG WAS FIXED IN THE MYSQL DRIVERS, "adodb-pdo_mysql.inc.php", "adodb-mysqli.inc.php" AND 
		"adodb-mysql.inc.php', INTRODUCED BY NEWELY ADDED CODE FROM THE MAIN FORK, WHERE CODE WAS USING
		ADOConnection::databaseName, WHICH DOES NOT EXIST, INSTEAD OF ADOConnection::database. SEE
		COMMIT (4/22/2021 3:26:51 PM)
- IN THIS FORK, THE NEWLY INTRODUCED CUSTOM META TYPES MECHANISM, WHICH IS ILL DEFINED, INTO THE MAIN
		FORK WAS REMOVED. SEE COMMIT (4/24/2021 2:00:11 PM). AS A CONSEQUENCE,  THE NEWLY ADDED VARIABLES,
		ADOConnection::customMetaTypes, ADOConnection::customActualTypes, ADORecordSet::customMetaTypes AND
		ADORecordSet::customActualTypes AND THE NEWLY ADDED FUNCTIONS ADOConnection::setCustomMetaType() AND 
		ADOConnection::getCustomMetaTypes() WERE REMOVED.
- IN THIS FORK, THE FUNCTION ADODB_DataDict::ActualType() REMAINS CASE INSENSITIVE IN THIS FORK. 
		SEE COMMIT (4/24/2021 2:00:11 PM).
- IN THIS FORK, THE DRIVER "adodb-mysqli.inc.php" WAS FIXED SUCH AS PREPARE STATEMENTS USE THE NATIVE
		DRIVER FUNCTIONALITY, AND AT THE SAME TIME THE ILL DEFINED NEWLY ADDED OFFICIAL FORK FIX FOR THIS 
		WAS REMOVED. SEE COMMIT (4/24/2021 7:05:53 PM)
- IN THIE FORK, THE OLD MEMCACHE IMPLEMENTATION WAS RENAMED TO "adodb-memcachelegacy.lib.inc.php". THE OFFICIAL
		FORK COMPLETELY REWRITTEN THE IMPLEMENTATION. HOWEVER THE USER THE LEGACY IMPLEMENTATION IS NOT SUPPORTED
		BY THE CODE ITSELF, AND INSTEAD ONE MUST RENAME THE FILE OVERRIWTING THE NEW FILE. SEE 
		COMMIT (4/24/2021 7:05:53 PM). BY THE TIME OF SAID COMMIT, I ALREADY SAW AT LEAST ONE BUY IN THE NEW
		IMPLEMENTATION.
- IN THIS FORK, "perf-sqlite3.inc.php"  WAS RENAMED TO "perf-sqlite.inc.php". SEE COMMIT (4/24/2021 7:05:53 PM)
- IN THIS FORK, THE MAGIC QUOTES STUFF IS RETAINED, HOWEVER IT DOES NOT MEAN THAT I KNOW HOW TO MAINTAIN. I ONLY
		KEPT THE OLD CODE. THE MAGIC QUOTES STUFF IS ILL DEFINED, AND HENCE I NEVER USED IT MYSELF. 
		SEE COMMIT  (4/25/2021 9:19:02 AM)
- THE OFFICIAL FORK ADDED A ADODB_DataDict::ChangeTableSQL() IMPLEMENTATION TO "datadict-postgres.inc.php" WHICH
		APPEARS BASED ON THE OLD MERGE REQUEST I MADE. IN THIS FORK, THE NEWLY ADDED FUNCTION REMAINS,
		BUT IS QUOTED OUT. IDEALLY I WOULD WANT IT TO REPLACE MY IMPLEMENTATION IN THIS FORK, ESPECIALLY IF
		IT IS MORE PERFORMANT.
		SEE COMMIT (4/25/2021 9:19:02 AM)
- CODE DEALING WITH MAGIC QUOTES IS KEPT. BECAUSE OF THIS, THE FUNCTIONS ::_adodb_getupdatesql(),
		::_adodb_getinsertsql(), ::_adodb_column_sql_oci8(), AND ::_adodb_column_sql(), HAVE A DIFFERENT
		INCOMPATIBLE SIGNATURE WITH THE ONES IN THE MAIN FORK. BE CAREFUL. SEE COMMIT (4/25/2021 9:19:02 AM).
- THIS FORK RETAINS THE FUNCTION ADOConnection::QMagic(), AND RETAINS THE SEMANTIC PERTAINING TO 
		MAGIC QUOTES FOR THE FUNCTIONS ADOConnection::AutoExecute(), ADOConnection::GetUpdateSQL(),
		ADOConnection::escape(), ADOConnection::addq(), AND ADOConnection::qstr()
		SEE COMMIT (4/25/2021 9:19:02 AM).
- BE CAREFUL WITH ADOConnection::addq(), GIVEN THE WAY IT SEEMS TO BE INTENDED TO BE USED, IT IS ILL
		DEFINED BECAUSE IT CAN NOT BE DEFINED PER SAID INTENTION IN TERMS OF ADOConnection::qstr().
		IN THIS FORK, ADOConnection::qstr() IN THE BASE CLASS CONTINUES TO HAVE ITS SEPERATE CODE,
		AND NOT MAKE CALLS TO ADOConnection::addq(). SEE COMMIT (4/26/2021 10:37:32 AM).
- IN THIS FORK, ADOConnection::addq() IS MADE FINAL. SEE COMMIT (4/26/2021 10:37:32 AM).
- IN THIS FORK, A FIX WAS MADE TO ADOConnection::qstr() AND ADOConnection::addq() IN THE BASE CLASS PERTAINING TO
		THE WAY THEY HANDLED THE INI SETTING, magic_quotes_sybase. THE FIX WAS DEDUCED FROM OTHER DRIVERS, THE GIT
		HISTORY, AND REFERENCES AROUND THE WEB, BUT WAS NOT TESTED. SEE COMMIT (4/26/2021 10:37:32 AM).
- IT APPEARS THAT ADOConnection::Affected_Rows() IS ONLY RELIABLE IF THE SQL STATEMENT IS EXECUTED BY
		ADOConnection::Execute(). THIS NEEDS CHECKING, BUT IF I AM WRONG, THEN MY FIX FOR "adodb-mysqli.inc.php"
		DRIVER WHICH INCORPORATED THE NATIVE PREPARE FUNCTINALITY IS ILL DEFINED.


		
- ISSUES, TO DO:
	- COMMIT (6/18/2015 9:34:31 AM): NO ATTENTION TO PERFORMANCE WAS PAID WHEN IMPLEMENTING ChangeTableSQL 
			FOR THE PostgreeSQL DATA DICTIONARY.
			NOTE: THE OFFICIAL FORK FINALLY ADDED ITS OWN IMPLEMENTATION, BUT IT APPEARS BASED ON WHAT IS IN
			THIS FORK, OR MORE CORRECTLY THE MERGE REQUEST I MADE YEARS AGO (~2015). SEE
			COMMIT (4/25/2021 9:19:02 AM)
	- COMMIT (7/6/2015 9:34:03 AM): MOVE ALL SQL GENERATION FROM DRIVERS TO THE DATA DICTIONARIES, IF NOT
			DONE SO ALREADY.
	- COMMIT (7/11/2015 4:00:59 PM): ALTHOUGH ADODB IS NOT AWARE OF THE QUOTATION FEATURE OF ADODB DATA DICTIONARY,
			SOME DRIVERS SHOW OF SIGNS OTHERWISE. I NO LONGER REMEMBER WHAT AND WHAT I DID NOT CHANGE, BUT I
			BELIEVE I KEPT EVERYTHING AS IS TO AVOID BREAKING BACKWARD COMPATIBILITY.
	- COMMIT (7/12/2015 9:52:23 AM): AFTER REPAIRING THE PDO DRIVERS ANTI PATTERN, THERE IS NO LONGER
			 A DEFAULT DRIVER. THE CODE FOR HANDLING THE LACK OF A SPECIALIZED PDO DRIVER WAS KEPT, BUT NOT
			 STABLE ACCORDING TO THE NOTES. IF I DID NOT ALREADY, I NEED TO MAKE THE CODE DIE SHOULD THE SITUATION
			 ARISE. I DOUBT ANYTHING ELSE CAN BE DONE WHILE REATINING NORMALIZATION TO KEEP BACK WARD COMPATIBILY,
			 AND THEN AGAIN, IT IS UNLIKELY ANY ONE WAS USING, OR ABLE TO USE, THIS DEFAULT STATE, I THINK.
	- COMMIT (7/18/2015 2:11:10 PM): SOME TRACES OF MOVED SQL VARIABLES FROM THE DRIVERS TO THE DATA DICTIONARIES
			STILL REMAIN IN THE SQLITE DRIVERS. I FORGOT WHETHER I FINALLY REMOVED THEM OR NOT.
			SOME INSTANCE OF THE NEW FUNCTION INTRODUCED, ADODB_DataDict::FormatDateSQL() MAKE CALLS TO FUNCTIONS
			INSIDE THE DRIVERS, WHICH IS NOT PROPER.
	- COMMIT (7/19/2015 2:03:21 PM): ADOConnection::RowLock() DOES NOT CURRENTLY SUPPORT THE FORMS DEFINED IN
			ADODB_DataDict::ParseIdentifierName(). IN THE FUTURE, ADD SUPPORT, BUT BE CAREFUL, THE SQL SEGMENT 
			PASSED TO THE FUNCTION MIGHT NOT NECESSARILY BE A COMMA SEPERATED LIST OF TABLE NAMES.
			ADOConnection::RowLock() STILL EXISTS IN SOME DRIVERS DUE TO THEIR DIFFERENT BEHAVIORS.
	- COMMIT (7/25/2015 3:32:54 PM): THE DRIVER, adodb-ads.inc.php, IGNORES THE START ID PARAMETER OF
			ADOConnection::CreateSequence().
			THERE STILL REMAIN INSTANCES WHERE THE FUNCTION CREATESEQUENCE() DOES NOT RETURN A SOLID BOOLEAN.
			THERE MIGHT OTHER THINGS THAT NEED ATTENDING TO IN THIS COMMIT THAT I MISSED.
	- COMMIT (7/26/2015 10:10:30 AM): THE PARASITIC VARIABLE $_genSeqSQL STILL EXISTS IN adodb-odbtp.inc.php
			ADOConnection::CreateSequence() STILL EXISTS IN SOME DRIVERS WHERE IT COULD BE FACTORED OUT.
	- COMMIT (8/1/2015 2:22:50 PM): TRACES OF ADOConnection::DropSequence STILL EXIST IN THE DRIVER adodb-odbtp.inc.php
	- COMMIT (8/9/2015 2:12:13 PM): WORK PERTAINING TO ADOConnection::GenID() AND THE DATA DICTIONARIES IS
			STILL ERQUIRED FOR THE ODBTP DRIVERS, AND THE SQL SERVER DRIVERS.
	- COMMIT (11/30/2015 10:22:02 AM): NameQuote() IMPLEMENTATION FOR THE FIREBIRD DATA DICIONARY DRIVER WAS 
			CHANGED TO ADHERE TO APPARANT SPECIFICATIONS. CONSEQUENCES OF THIS WERE NOT INVESTIGATED.
	- COMMIT (3/3/2016 12:41:18 PM): CORRECT USAGE OF ADODB_DEFAULT_METATYPE IN SOME DRIVERS. WHICH INCLUDE
			adodb-ads.inc.php, adodb-db2.inc.php, adodb-odbc.inc.php, AND adodb-oracle.inc.php.	SEE COMMIT
			FOR DETAILS.
	- COMMIT (3/23/2016 9:39:22 AM): ADODB_CACHE_MODE APPEARS TO BE PARASITIC.
	- COMMIT (4/1/2016 11:41:39 AM): WORK ON ADORecordSet::GetAssocKeys() AND RELATED ISSUES COULD NOT BE
			APPLIED TO THE DRIVER adodb-ldap.inc.php.
	- COMMIT (4/5/2016 9:05:42 AM): "The fixes for the ado based drivers are not ideal."
	- COMMIT (4/11/2016 9:03:50 AM): ADOConnection::MetaTables() functionality WAS ADDED TO MSSQL DRIVERS THAT 
			WERE MISSING THEM, BUT THE ADDED ADOCONNECTION::METATABLES() WERE NOT TESTED.
			ADORecordSet::MetaType() IS ILL DEFINED.
			UPDATE: THE ILL DEFINITION OF ADORecordSet::MetaType() WAS FIXED. SEE 
					COMMIT (4/15/2021 6:54:59 PM). HOWEVER WHETHER THIS FIXED THE ORIGINAL REASON THE
					FUNCTION WAS SEEN AS ILL DEFINED I DO NOT KNOW, BUT JUDGING FROM THE EXPLICIT
					DEFINITION OF ADOFieldObject::type THAT THIS FORK ADDS, IT APPEARS VERY LIKELY.
	- COMMIT (4/22/2016 8:16:30 AM): ADOFieldObject::max_length IS ILL DEFINED. IT MEANS DIFFERENT THINGS FOR
			DIFFERENT DRIVERS, AND DIFFERENT THINGS FOR THE SAME DRIVER DEPENDING ON THE DATATYPE. 
			THE ISSUE APPEARS NON FIXABLE WITHOUT LARGELY BREAKING BACKWARD COMPATIBILITY.
	- COMMIT (5/6/2016 10:24:39 AM): FAILED AT TRYING TO WELL DEFINE ADOFieldObject::scale AND
			ADOFieldObject::precision
	- COMMIT (10/28/2016 6:29:50 PM): THE DRIVER adodb-csvlib.inc.php REQUIRES FURTHER TESTING DUE TO THE REMOVAL
			OF THE ADORecordSet_array CALSS CODE.
			ADORecordSet TRANSPOSE FUNCTIONS REQUIRE FURTHER TESTING.
			rsfilter.inc.php REQUIRES FURTHER TESTING.
			A POSSIBLE BUG WAS FOUND IN THE DRIVER adodb-text.inc.php. SEE THE NOTE ON ADORecordSet_text's 
			CONSTRUCTOR.
			ELEMINATE ADOConnection::$arrayClass, WHICH STILL REMAINS BECAUSE OF THE CODE IN 
			adodb-csvlib.inc.php
	- COMMIT: IN THIS FORK dbTable::addTableOpt() MAKES USE OF upperName FROM THE DATA DICTIONARY CLASS, WHICH
			IS AN EDUCATED GUESS, AND NOT HOW THE MAIN FORK DOES IT. dbTable::addTableOpt() REQUIRES TESTING.
			FURTHER MORE, THE CLASS VARIABLE upperName IS ILL DEFINED AND REQUIRE FIXING. THE VARIABLE
			IS NOT EXPLICITLY DEFINED ANYWHERE, AND JUST ATTACHED LATER ON.
	- THE CLASS VARIABLE "$connectStmt", FOUND IN THREE OR FOUR OF THE DRIVERS IS ANOTHER OF THOSE 
			DRIVER SPECIFIC PARAMETERS TO BE USED DURING CONNECTION, WHICH IS BETTER NORMALIZED.
	- ADD _connect TO THE BASE DRIVER, ADOConnection, HAVING IT INDICATE AN ERROR FOR NOT BEING IMPLEMENTED.
	- INVESTIGATE IF RECORD SET WORKS IS SUPPOSED TO WORK AS AN ARRAY, AND IF SO WHETHER IT WORKS PROPERLY
			AS AN ASSOCIATIVE ARRAY AND A NUMERIC ARRAY.
	- REMOVE USAGE OF THE NATIVE FUNCTION "create_function()" WHICH IS REMOVED IN PHP8
	- IN THE DATA DICTIONARY OF DB2, NOTICE HOW ChangeTableSQL() WORKS DESPITE BEING PASSED THE FORMAT AS
			DEFINED IN THIS FORK OF THE ADODB_DataDict::ParseIdentifierName(). WORK WILL PROBABLY HAS TO BE DONE
			TO MAKE SURE THIS FUNCTION, AND OTHER SIMILAR FUNCTION, WORK. CURRENTLY, THEY ONLY WORK, IT SEEMS,
			IF THE FUNCTION ADODB_DataDict::NameQuote() DOES NOT DETECT AN UNUSUAL CHARACTER IN ONE
			OF ITS CODE BRANCHES, BUT OTHER WISE IT WILL LIEKLY CAUSE A DOUBLE QUOTE. FURTHER MORE,
			THINGS LIKELY DO NOT WORK IF A SCHEMA NAME IS INCLUDED AS PART OF THE FORMATED NAME
			AS IT MAKES IT TO ADODB_DataDict::NameQuote(). REMEMBER, THE FORMATTING IS PER THE FORMATTING
			INTRODUCED IN THIS FORK, AND DEFINED IN THE FUNCTION ADODB_DataDict::ParseIdentifierName().
	- SQL in ::_adodb_getcount() is a candidate for moving to the data dictionaries.
	- REFER TO "https://github.com/ADOdb/ADOdb/pull/423".
			DID MS SQL ALWAYS REQUIRE AN ALIAS? IF SO, MAKE CHANGES TO ::_adodb_getcount() ACCOUNT FOR 
			OTHER MSSQL DRIVERS, INCLUDING THOSE OF ODBC, AND THOSE OF ODBTP. SEE COMMIT 
	- FIX THE SETTING OF FETCH MODE IN THE FUNCTION _MetaColumns OF THE LEGACY DB2 DRIVER.
	- REMOVE THE VARIABLE dataProvider FROM THE ADO RECORD SET CLASS.
	- MIGHT WANT TO REMOVE THE VARIABLE databaseType FROM THE ADO RECORD SET CLASS.
	- REMOVE REDUNTANT ADOConnection::UpdateBlob DEFINITIONS IN THE DRIVERS.
	- REMOVE $useFetchArray FROM DRIVERS.
	- FIX THE RETURN OF ADOConnection::IgnoreErrors()
	- FIX THE FUNCTION NAMING OF ADOConnection::MetaForeignKeys(), AND ADOConnection::GetAssoc(); 
			FIX THE CAPITALIZATION.
	- ANALYZE THE ADODB_FORCE_NULL_AND_ZERO FAMILY OF CONSTANTS. ADODB_FORCE_NULL_AND_ZERO IN PARTICULAR WAS
			ADDED RELATIVELY RECENTLY. SEE COMMIT (3/28/2016 1:49:42 PM).
	- adodb-odbc_sapdb.inc.php 
					" WHERE UPPER(TABLENAME)=$table".
	- IS ADOConnection::arrayClass STILL USED IN THIS FORK? IT APPEARS NOT, BUT DID TRACES RE APPEAR AFTER MERGER?
	- THE FUNCTION ADORecordSet_postgres64::_fixblobs() IS POSSIBLY A SYMPTOM OF A PROBLEM THAT DOES NOT EXIST IN
			THIS FORK. IT NEEDS FURTHER INVESTIGATION.
	- CONFIRM SPECIFICATION IN THE DTD IS PER WHAT THE ACTUAL CODE IS DOING IN THE ADODB XML SCHEMA PART.
	- TEST NEW ADOConnection::_MetaColumns() IN THE MYSQL DRIVERS PERTAINING TO MYSQL 8. SEE 
			COMMIT (4/12/2021 10:10:45 AM)
	- THE DRIVER, "adodb-odbtp.inc.php", WHICH IS MULTIPLE DRIVERS ALL IN A SINGLE INSTACE, WILL
			CREATE A NEW INTERNAL DATA DICTIONARY EVERY TIME A NEW CONNECTION IS MADE ON IT.
			THIS IS BECAUSE THE NEW CONNECTION MIGHT BE FOR A DIFFERENT DATABASE. SEE
			COMMIT (7/18/2015 2:11:10 PM). LATER I ADDED CODE TO ONLY CREATE A NEW DATA DICTIONARY
			IF THE DATABASE CHANGED WHEN CONNECTING. SEE COMMIT (4/14/2021 6:11:39 PM)
			HOWEVER, THIS IS STILL NOT PERFECT, BECAUSE CONCEPTUALLY EACH DATABASE HAS A DIFFERENT
			DRIVER, WHILE WITH THE ODPTP DRIVER, IT IS AS IF THE DRIVER	CHANGES ITSELF AT RUNTIME,
			WHICH IS NATUARLY CONTRARY TO ALL OTHER DRIVERS. IDEALLY THE DATABASE OF THE DRIVER 
			MUST BE KNOWN FROM CREATION, BUT AT LEAST WE COULD MAKE IT TO NEVER CHANGE AFTER THE 
			FIRST CONNECT.
			IN THE SAME COMMIT, "adodb-odbtp.inc.php" NO LONGER WORKS WITH OTHER DATABASES, SUCH AS
			DB2 OR MYSQL, THAT IT MIGHT HAVE PARTIALLY WORKED WITH BEFORE.
	
	
		
DATABASE SURVEY:
	- IS CASE SENSITIVE WITH QUOTATION, AND NOT OTHERWISE?
			DB: 		YES
			POSTGRES:	YES
			
DRIVERS SURVEY:
	- SEMANTICS OF primary PARAMETER OF _MetaIndexes:
		- SURVEY:
			- odbc_db2:		RETURN PRIMARY INDEX IF primary ELSE RETURN ALL INDICES.
							UPDATE(24-APRIL-2021)
							RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- db2:			RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- db2legacy:	RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- oci8:			RETURN PRIMARY INDEX IF primary ELSE RETURN ALL INDICES.
							UPDATE(24-APRIL-2021)
							RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- pdo_oci:		RETURN PRIMARY INDEX IF primary ELSE RETURN ALL INDICES.
							UPDATE(24-APRIL-2021)
							RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- mysqli:		RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- mysql:		RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- pdo_mysql:	RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- mssqlnative:	RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- mssql:		RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- pdo_mssql:	RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- odbc_mssql:	RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- odbtp_mssql:	RETURN PRIMARY INDEX IF primary ELSE RETURN ALL INDICES.
							UPDATE(24-APRIL-2021)
							RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- pdo_sqlsrv:	RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- ibase:		UNKOWN. COULD NOT UNDERSTAND, BUT APPEARS TO BE:
							RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- firebird:		UNKOWN. COULD NOT UNDERSTAND, BUT APPEARS TO BE:
							RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- sqlite3:		RETURN PRIMARY INDEX IF primary ELSE RETURN ALL INDICES.
							UPDATE(24-APRIL-2021)
							RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- sqlite:		RETURN PRIMARY INDEX IF primary ELSE RETURN ALL INDICES.
							UPDATE(24-APRIL-2021)
							RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- pdo_sqlite:	RETURN PRIMARY INDEX IF primary ELSE RETURN ALL INDICES.
							UPDATE(24-APRIL-2021)
							RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- postgres64:	RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- pdo_pgsql:	RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
			- odbc_sapdb:	RETURN ALL INDICES IF primary ELSE RETURN ALL INDICES WITHOUT PRIMARY.
		- NOTE THAT THE SURVEY ALSO GIVES AN INDICATION OF WHICH DRIVERS IMPLEMENT _MetaIndexes,
				AND WHICH DO NOT. odbtp BASED DRIVERS MIGHT BENEFIT FROM NORMALIZING, FROM PORTING
				PORTING _MetaIndexes FROM OTHER PERTAINING DRIVERS. ONLY odbtp_mssql CURRENTLY 
				IMPLEMENTS IT. IT IS LIKELY HOWEVER THAT I ALREADY TRIED THIS BEFORE. ALSO NOTE
				THAT ALL odbtp BASED DRIVERS ARE IN THE SAME PHP FILE.
	- MetaForeignKeys()
		- RETURNS ARRAY OF ARRAYS, OR NOT.
			- sqlite3:		RETURNS ARRAY OF ARRAYS.
			- postgres7:	RETURNS ARRAY OF ARRAYS.
			- postgres8:	RETURNS ARRAY OF ARRAYS.
			- postgres9:	RETURNS ARRAY OF ARRAYS.
			- pdo_sqlite:	RETURNS ARRAY OF ARRAYS.
			- odbtp_mssql: 	RETURNS ARRAY OF ARRAYS.
			- odbtp_access:	RETURNS ARRAY OF ARRAYS.
			- odbtp_vfp:	RETURNS ARRAY OF ARRAYS.
			- odbtp_oci8:	RETURNS ARRAY OF ARRAYS.
			- odbtp_sybase: RETURNS ARRAY OF ARRAYS.
			- oci8:			RETURNS ARRAY.
			- oci8quercus:  RETURNS ARRAY.
			- oci805:		RETURNS ARRAY.
			- oci8po:		RETURNS ARRAY.
			- mysqli:		RETURNS ARRAY OF ARRAYS.
			- db2:			RETURNS ARRAY.
			- mssqlnative:	RETURNS ARRAY OF ARRAYS.
			- mysql:		RETURNS ARRAY OF ARRAYS.
			- informix72:	RETURNS ARRAY OF ARRAYS.
			- informix:		RETURNS ARRAY OF ARRAYS.
			- dblegacy:		RETURNS ARRAY OF ARRAYS.
		- RETURNS ARRAY OF ASSOCIATE ARRAYS OR NOT (ARRAY OF NON ASSOCIATE ARRAYS)
			- sqlite3:		YES, IFF FETCH MODE IS ADODB_FETCH_ASSOC. ALSO ACCEPTS $associative PARAMETER
			- postgres7:	NO.
			- postgres8:	NO.
			- postgres9:	NO.
			- pdo_sqlite:	YES, IFF FETCH MODE IS ADODB_FETCH_ASSOC. ALSO ACCEPTS $associative PARAMETER
			- odbtp_mssql: 	NO.
			- odbtp_access:	NO.
			- odbtp_vfp:	NO.
			- odbtp_oci8:	NO.
			- odbtp_sybase: NO.
			- oci8:			NOT APPLICABLE.
			- mysqli:		YES, IFF FETCH MODE IS ADODB_FETCH_ASSOC. ALSO ACCEPTS $associative PARAMETER
			- db2:			NOT APPLICABLE.
			- mssqlnative:	NO.
			- mysql:		YES, IFF FETCH MODE IS ADODB_FETCH_ASSOC. ALSO ACCEPTS $associative PARAMETER
			- informix72:	NO.
			- informix:		NO.
			- dblegacy:		YES.
		- SUPPORTS $upper PARAMETER (THIS AFFECTS THE OUTER ARRAY, NOT INNER):
			- sqlite3:		YES, IFF ASSOCIATIVE, BUT WOULD LOWER CASE IF $upper IS FALSE
			- postgres7:	YES.
			- postgres8:	YES.
			- postgres9:	YES.
			- pdo_sqlite:	YES, IFF ASSOCIATIVE, BUT WOULD LOWER CASE IF $upper IS FALSE
			- odbtp_mssql: 	YES.
			- odbtp_access:	YES.
			- odbtp_vfp:	YES.
			- odbtp_oci8:	YES.
			- odbtp_sybase: YES.
			- oci8:			NO.
			- mysqli:		YES.
			- db2:			NO.
			- mssqlnative:	YES.
			- mysql:		YES.
			- informix72:	YES.
			- informix:		YES.
			- dblegacy:		NO.
		- FORMAT OF RETURN:
			- sqlite3:		(ASSOCIATIVE):	{FOREIGN_KEY_COLUMN_NAME => {FOREIGN_KEY_COLUMN_NAME => "REFERENCE_COLUMN_NAME"}}
							(NUMERIC):		{FOREIGN_KEY_COLUMN_NAME => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- postgres7:	(NUMERIC):		{REFERENCE_TABLE_NAME 	 => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- pdo_sqlite:	(ASSOCIATIVE):	{FOREIGN_KEY_COLUMN_NAME => {FOREIGN_KEY_COLUMN_NAME => "REFERENCE_COLUMN_NAME"}}
							(NUMERIC):		{FOREIGN_KEY_COLUMN_NAME => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- odbtp_mssql: 	(NUMERIC):		{REFERENCE_TABLE_NAME 	 => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- odbtp_access:	(NUMERIC):		{REFERENCE_TABLE_NAME 	 => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- odbtp_vfp:	(NUMERIC):		{REFERENCE_TABLE_NAME 	 => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- odbtp_oci8:	(NUMERIC):		{REFERENCE_TABLE_NAME 	 => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- odbtp_sybase: (NUMERIC):		{REFERENCE_TABLE_NAME 	 => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- oci8:				NA	 :		?
			- mysqli:		(ASSOCIATIVE):  {REFERENCE_TABLE_NAME 	 => {REFERENCE_COLUMN_NAME => "FOREIGN_KEY_COLUMN_NAME"}
							(NUMERIC):		{REFERENCE_TABLE_NAME 	 => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- db2:				NA	 :		{REFERENCE_TABLE_NAME	 => "FOREIGN_KEY_NAME"}
			- mssqlnative:	(NUMERIC):		{REFERENCE_TABLE_NAME	 => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}
			- mysql:		(ASSOCIATIVE):  {REFERENCE_TABLE_NAME 	 => {REFERENCE_COLUMN_NAME => "FOREIGN_KEY_COLUMN_NAME"}
							(NUMERIC):		{REFERENCE_TABLE_NAME 	 => { => "FOREIGN_KEY_COLUMN_NAME=REFERENCE_COLUMN_NAME"}}
			- informix72:	(NUMERIC):		?
			- informix:		(NUMERIC):		?
			- dblegacy:		(ASSOCIATIVE)	{FOREIGN_KEY_TABLE_NAME  => {FOREIGN_KEY_COLUMN_NAME => "REFERENCE_COLUMN_NAME"}}


	
FINISHED ISSUES:
	- COMMIT (5/27/2016 7:08:42 PM): THE FUNCTIONS ADOConnection::SqlDate(), AND CONSEQUENTLY, 
			ADOConnection::month(), ADOConnection::day() AND ADOConnection::year() IN THE SQLLITE DRIVERS DO
			NOT CORRECTLY HANDLE THE ADODB BACK QUOTES FEATURE, AND THE BRACKETS FEATURE INTRODUCED IN THIS
			FORK.
			UPDATE: THE SQLITE DRIVERS ISSUE WAS FIXED. SEE COMMIT (4/14/2021 6:11:39 PM)
			
			
			
OBSELETE NOTES:
	- IN THIS FORK ADORecordSet::Transpose() WAS ADDED. 
			UPDATE: ADOConnection::Transpose() WAS LATER REMOVED BY THE OFFICIAL COMMIT, AND
					SO ADORecordSet::Transpose() WAS ALSO REMOVED, WHICH WAS INTRODUCED DURING THE
					ADORecordSet_array RELATED WORK. THE FUNCTION WAS IN ADORecordSet_array AS
					ADORecordSet_array::_transpose() SEE COMMIT (4/24/2021 2:00:11 PM)